From 3657765af335a2d9ed35d5d9207eb8875ba65c8f Mon Sep 17 00:00:00 2001
From: Pierre FICHEUX <pierre.ficheux@openwide.fr>
Date: Tue, 2 Sep 2014 12:22:36 +0200
Subject: [PATCH] Added Adafruit TS support to BR 2014.08

---
 .../config-linux-3.6.11-adafruit_ts+git            | 3485 ++++++++
 ...nux-3.6.11-0001-Added-Adafruit-TS-support.patch | 9407 ++++++++++++++++++++
 board/raspberrypi/adafruit_ts/overlay/etc/fstab    |   10 +
 .../adafruit_ts/overlay/etc/init.d/S11touchscreen  |   27 +
 board/raspberrypi/adafruit_ts/overlay/etc/inittab  |   43 +
 .../overlay/etc/udev/rules.d/95-stmpe.rules        |    1 +
 .../adafruit_ts/overlay/root/.directfbrc           |    2 +
 .../raspberrypi/adafruit_ts/overlay/root/.profile  |    9 +
 board/raspberrypi/build_sdcard.sh                  |   87 +
 board/raspberrypi/cmdline.txt                      |   12 +
 configs/raspberrypi_qt4_ts_defconfig               |   53 +
 11 files changed, 13136 insertions(+)
 create mode 100644 board/raspberrypi/adafruit_ts/config-linux-3.6.11-adafruit_ts+git
 create mode 100644 board/raspberrypi/adafruit_ts/linux-3.6.11-0001-Added-Adafruit-TS-support.patch
 create mode 100644 board/raspberrypi/adafruit_ts/overlay/boot/.empty
 create mode 100644 board/raspberrypi/adafruit_ts/overlay/etc/fstab
 create mode 100755 board/raspberrypi/adafruit_ts/overlay/etc/init.d/S11touchscreen
 create mode 100644 board/raspberrypi/adafruit_ts/overlay/etc/inittab
 create mode 100644 board/raspberrypi/adafruit_ts/overlay/etc/udev/rules.d/95-stmpe.rules
 create mode 100644 board/raspberrypi/adafruit_ts/overlay/root/.directfbrc
 create mode 100644 board/raspberrypi/adafruit_ts/overlay/root/.profile
 create mode 100755 board/raspberrypi/build_sdcard.sh
 create mode 100644 board/raspberrypi/cmdline.txt
 create mode 100644 configs/raspberrypi_qt4_ts_defconfig

diff --git a/board/raspberrypi/adafruit_ts/config-linux-3.6.11-adafruit_ts+git b/board/raspberrypi/adafruit_ts/config-linux-3.6.11-adafruit_ts+git
new file mode 100644
index 0000000..34deade
--- /dev/null
+++ b/board/raspberrypi/adafruit_ts/config-linux-3.6.11-adafruit_ts+git
@@ -0,0 +1,3485 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.6.11 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_FIQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_NEED_MACH_IO_H=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION="-adafruit_ts+git"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FHANDLE=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_MEMCG is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+CONFIG_BLK_DEV_THROTTLING=y
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+CONFIG_ARCH_BCM2708=y
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_GPIO_PCA953X is not set
+
+#
+# Broadcom BCM2708 Implementations
+#
+CONFIG_MACH_BCM2708=y
+CONFIG_BCM2708_GPIO=y
+CONFIG_BCM2708_VCMEM=y
+# CONFIG_BCM2708_NOL2CACHE is not set
+CONFIG_BCM2708_DMAER=m
+CONFIG_BCM2708_SPIDEV=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_ARM_ERRATA_326103 is not set
+CONFIG_ARM_ERRATA_411920=y
+# CONFIG_ARM_ERRATA_364296 is not set
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_CLEANCACHE=y
+CONFIG_FRONTSWAP=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_SECCOMP=y
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=m
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+CONFIG_ARM_BCM2835_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=m
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_ROUTE_CLASSID=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IPGRE=m
+# CONFIG_NET_IPGRE_BROADCAST is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_IPVTI is not set
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=m
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+# CONFIG_IPV6_MIP6 is not set
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_ZONES=y
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+CONFIG_NF_CONNTRACK_TIMESTAMP=y
+CONFIG_NF_CT_PROTO_DCCP=m
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_BROADCAST=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_SNMP=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE_CT is not set
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_NETFILTER_XTABLES=m
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_CONNMARK=m
+CONFIG_NETFILTER_XT_SET=m
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_AUDIT=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+CONFIG_NETFILTER_XT_TARGET_HMARK=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_CPU=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DEVGROUP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ECN=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+# CONFIG_NETFILTER_XT_MATCH_IPVS is not set
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_SET=m
+CONFIG_IP_SET_MAX=256
+CONFIG_IP_SET_BITMAP_IP=m
+CONFIG_IP_SET_BITMAP_IPMAC=m
+CONFIG_IP_SET_BITMAP_PORT=m
+CONFIG_IP_SET_HASH_IP=m
+CONFIG_IP_SET_HASH_IPPORT=m
+CONFIG_IP_SET_HASH_IPPORTIP=m
+CONFIG_IP_SET_HASH_IPPORTNET=m
+CONFIG_IP_SET_HASH_NET=m
+CONFIG_IP_SET_HASH_NETPORT=m
+CONFIG_IP_SET_HASH_NETIFACE=m
+CONFIG_IP_SET_LIST_SET=m
+CONFIG_IP_VS=m
+# CONFIG_IP_VS_IPV6 is not set
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_AH_ESP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+CONFIG_IP_VS_PROTO_SCTP=y
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS SH scheduler
+#
+CONFIG_IP_VS_SH_TAB_BITS=8
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+CONFIG_IP_VS_NFCT=y
+CONFIG_IP_VS_PE_SIP=m
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_NF_NAT_SNMP_BASIC=m
+CONFIG_NF_NAT_PROTO_DCCP=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_PROTO_UDPLITE=m
+CONFIG_NF_NAT_PROTO_SCTP=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=m
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=m
+# CONFIG_NET_SCTPPROBE is not set
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+CONFIG_SCTP_HMAC_SHA1=y
+# CONFIG_SCTP_HMAC_MD5 is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_L2TP=m
+# CONFIG_L2TP_DEBUGFS is not set
+# CONFIG_L2TP_V3 is not set
+CONFIG_STP=m
+CONFIG_GARP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFB=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_CHOKE=m
+CONFIG_NET_SCH_QFQ=m
+CONFIG_NET_SCH_CODEL=m
+CONFIG_NET_SCH_FQ_CODEL=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_SCH_PLUG=m
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+# CONFIG_NET_EMATCH_IPSET is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_NET_ACT_SIMP=m
+CONFIG_NET_ACT_SKBEDIT=m
+CONFIG_NET_ACT_CSUM=m
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+CONFIG_BATMAN_ADV=m
+CONFIG_BATMAN_ADV_BLA=y
+# CONFIG_BATMAN_ADV_DEBUG is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+CONFIG_AX25=m
+CONFIG_AX25_DAMA_SLAVE=y
+CONFIG_NETROM=m
+CONFIG_ROSE=m
+
+#
+# AX.25 network device drivers
+#
+CONFIG_MKISS=m
+CONFIG_6PACK=m
+CONFIG_BPQETHER=m
+CONFIG_BAYCOM_SER_FDX=m
+CONFIG_BAYCOM_SER_HDX=m
+CONFIG_YAM=m
+# CONFIG_CAN is not set
+CONFIG_IRDA=m
+
+#
+# IrDA protocols
+#
+CONFIG_IRLAN=m
+CONFIG_IRNET=m
+CONFIG_IRCOMM=m
+CONFIG_IRDA_ULTRA=y
+
+#
+# IrDA options
+#
+CONFIG_IRDA_CACHE_LAST_LSAP=y
+CONFIG_IRDA_FAST_RR=y
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=m
+
+#
+# Dongle support
+#
+# CONFIG_DONGLE is not set
+CONFIG_KINGSUN_DONGLE=m
+CONFIG_KSDAZZLE_DONGLE=m
+CONFIG_KS959_DONGLE=m
+
+#
+# FIR device drivers
+#
+CONFIG_USB_IRDA=m
+CONFIG_SIGMATEL_FIR=m
+CONFIG_MCS_FIR=m
+CONFIG_BT=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=m
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIBTUSB=m
+# CONFIG_BT_HCIBTSDIO is not set
+# CONFIG_BT_HCIUART is not set
+CONFIG_BT_HCIBCM203X=m
+CONFIG_BT_HCIBPA10X=m
+CONFIG_BT_HCIBFUSB=m
+CONFIG_BT_HCIVHCI=m
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_BT_ATH3K=m
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=m
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_LIB80211=m
+CONFIG_LIB80211_CRYPT_WEP=m
+CONFIG_LIB80211_CRYPT_CCMP=m
+CONFIG_LIB80211_CRYPT_TKIP=m
+# CONFIG_LIB80211_DEBUG is not set
+CONFIG_MAC80211=m
+CONFIG_MAC80211_HAS_RC=y
+CONFIG_MAC80211_RC_PID=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+CONFIG_MAC80211_MESH=y
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+CONFIG_WIMAX=m
+CONFIG_WIMAX_DEBUG_LEVEL=8
+CONFIG_RFKILL=m
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_RFKILL_GPIO is not set
+CONFIG_NET_9P=m
+# CONFIG_NET_9P_DEBUG is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+CONFIG_NFC=m
+# CONFIG_NFC_NCI is not set
+# CONFIG_NFC_HCI is not set
+# CONFIG_NFC_LLCP is not set
+
+#
+# Near Field Communication (NFC) devices
+#
+# CONFIG_PN544_NFC is not set
+CONFIG_NFC_PN533=m
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+CONFIG_CONNECTOR=m
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_DEV_DRBD=m
+# CONFIG_DRBD_FAULT_INJECTION is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+CONFIG_RPI_PWM=m
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+CONFIG_EEPROM_93CX6=m
+# CONFIG_EEPROM_93XX46 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_BCM2708_VCHIQ=y
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=y
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_ISCSI_TCP=m
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+# CONFIG_MD_LINEAR is not set
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID456=m
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+# CONFIG_DM_THIN_PROVISIONING is not set
+CONFIG_DM_MIRROR=m
+CONFIG_DM_RAID=m
+CONFIG_DM_LOG_USERSPACE=m
+CONFIG_DM_ZERO=m
+# CONFIG_DM_MULTIPATH is not set
+CONFIG_DM_DELAY=m
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+CONFIG_BONDING=m
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+CONFIG_MACVLAN=m
+# CONFIG_MACVTAP is not set
+CONFIG_NETCONSOLE=m
+# CONFIG_NETCONSOLE_DYNAMIC is not set
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_TUN=m
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+CONFIG_NET_VENDOR_CIRRUS=y
+# CONFIG_CS89x0 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_FARADAY=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_FTGMAC100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_AX88796 is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_SEEQ=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_SMC91X is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+CONFIG_MDIO_BITBANG=m
+# CONFIG_MDIO_GPIO is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=m
+# CONFIG_PPTP is not set
+# CONFIG_PPPOL2TP is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_SLIP=m
+CONFIG_SLHC=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+# CONFIG_SLIP_MODE_SLIP6 is not set
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_CDC_NCM=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=y
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_ZAURUS=m
+CONFIG_USB_NET_CX82310_ETH=m
+CONFIG_USB_NET_KALMIA=m
+CONFIG_USB_NET_QMI_WWAN=m
+# CONFIG_USB_HSO is not set
+CONFIG_USB_NET_INT51X1=m
+CONFIG_USB_IPHETH=m
+CONFIG_USB_SIERRA_NET=m
+CONFIG_USB_VL600=m
+CONFIG_WLAN=y
+CONFIG_LIBERTAS_THINFIRM=m
+# CONFIG_LIBERTAS_THINFIRM_DEBUG is not set
+CONFIG_LIBERTAS_THINFIRM_USB=m
+CONFIG_AT76C50X_USB=m
+CONFIG_USB_ZD1201=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_RTL8187=m
+CONFIG_RTL8187_LEDS=y
+CONFIG_MAC80211_HWSIM=m
+CONFIG_ATH_COMMON=m
+# CONFIG_ATH_DEBUG is not set
+CONFIG_ATH9K_HW=m
+CONFIG_ATH9K_COMMON=m
+CONFIG_ATH9K_BTCOEX_SUPPORT=y
+CONFIG_ATH9K=m
+# CONFIG_ATH9K_AHB is not set
+# CONFIG_ATH9K_DEBUGFS is not set
+CONFIG_ATH9K_RATE_CONTROL=y
+CONFIG_ATH9K_HTC=m
+# CONFIG_ATH9K_HTC_DEBUGFS is not set
+CONFIG_CARL9170=m
+CONFIG_CARL9170_LEDS=y
+CONFIG_CARL9170_WPC=y
+# CONFIG_CARL9170_HWRNG is not set
+# CONFIG_ATH6KL is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_BRCMFMAC is not set
+CONFIG_HOSTAP=m
+# CONFIG_HOSTAP_FIRMWARE is not set
+CONFIG_LIBERTAS=m
+CONFIG_LIBERTAS_USB=m
+CONFIG_LIBERTAS_SDIO=m
+# CONFIG_LIBERTAS_SPI is not set
+# CONFIG_LIBERTAS_DEBUG is not set
+# CONFIG_LIBERTAS_MESH is not set
+CONFIG_P54_COMMON=m
+CONFIG_P54_USB=m
+# CONFIG_P54_SPI is not set
+CONFIG_P54_LEDS=y
+CONFIG_RT2X00=m
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+CONFIG_RT2800USB_RT53XX=y
+CONFIG_RT2800USB_UNKNOWN=y
+CONFIG_RT2800_LIB=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_RT2X00_LIB_LEDS=y
+# CONFIG_RT2X00_DEBUG is not set
+# CONFIG_WL_TI is not set
+CONFIG_ZD1211RW=m
+# CONFIG_ZD1211RW_DEBUG is not set
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+# CONFIG_MWIFIEX_USB is not set
+CONFIG_RTL8192CU=m
+
+#
+# WiMAX Wireless Broadband devices
+#
+CONFIG_WIMAX_I2400M=m
+CONFIG_WIMAX_I2400M_USB=m
+CONFIG_WIMAX_I2400M_DEBUG_LEVEL=8
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=m
+CONFIG_INPUT_POLLDEV=m
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+CONFIG_TOUCHSCREEN_STMPE=m
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_AD714X=m
+CONFIG_INPUT_AD714X_I2C=m
+CONFIG_INPUT_AD714X_SPI=m
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+# CONFIG_INPUT_KXTJ9 is not set
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_UINPUT=m
+# CONFIG_INPUT_PCF8574 is not set
+CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
+CONFIG_INPUT_ADXL34X=m
+CONFIG_INPUT_ADXL34X_I2C=m
+CONFIG_INPUT_ADXL34X_SPI=m
+CONFIG_INPUT_CMA3000=m
+# CONFIG_INPUT_CMA3000_I2C is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=m
+CONFIG_SERIO_SERPORT=m
+# CONFIG_SERIO_AMBAKMI is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+CONFIG_GAMEPORT=m
+CONFIG_GAMEPORT_NS558=m
+CONFIG_GAMEPORT_L4=m
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_CONSOLE_POLL=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+CONFIG_TTY_PRINTK=y
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=m
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_ATMEL is not set
+# CONFIG_HW_RANDOM_EXYNOS is not set
+CONFIG_HW_RANDOM_BCM2708=m
+# CONFIG_R3964 is not set
+CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=256
+# CONFIG_TCG_TPM is not set
+CONFIG_BRCM_CHAR_DRIVERS=y
+CONFIG_BCM_VC_CMA=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=m
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+CONFIG_I2C_BCM2708=m
+CONFIG_I2C_BCM2708_BAUDRATE=100000
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BCM2708=m
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=m
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+CONFIG_GPIO_STMPE=y
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+CONFIG_W1=m
+CONFIG_W1_CON=y
+
+#
+# 1-wire Bus Masters
+#
+CONFIG_W1_MASTER_DS2490=m
+CONFIG_W1_MASTER_DS2482=m
+CONFIG_W1_MASTER_DS1WM=m
+CONFIG_W1_MASTER_GPIO=m
+
+#
+# 1-wire Slaves
+#
+CONFIG_W1_SLAVE_THERM=m
+CONFIG_W1_SLAVE_SMEM=m
+CONFIG_W1_SLAVE_DS2408=m
+CONFIG_W1_SLAVE_DS2423=m
+CONFIG_W1_SLAVE_DS2431=m
+CONFIG_W1_SLAVE_DS2433=m
+# CONFIG_W1_SLAVE_DS2433_CRC is not set
+CONFIG_W1_SLAVE_DS2760=m
+CONFIG_W1_SLAVE_DS2780=m
+# CONFIG_W1_SLAVE_DS2781 is not set
+# CONFIG_W1_SLAVE_DS28E04 is not set
+CONFIG_W1_SLAVE_BQ27000=m
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+CONFIG_RPI_POWER_SWITCH=m
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_BCM2835=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+CONFIG_BCM2708_WDT=m
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+CONFIG_MFD_STMPE=y
+
+#
+# STMPE Interface Drivers
+#
+CONFIG_STMPE_I2C=y
+CONFIG_STMPE_SPI=y
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=m
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+# CONFIG_VIDEO_V4L2_SUBDEV_API is not set
+CONFIG_DVB_CORE=m
+CONFIG_DVB_NET=y
+
+#
+# Media drivers
+#
+CONFIG_RC_CORE=m
+CONFIG_RC_MAP=m
+CONFIG_RC_DECODERS=y
+CONFIG_LIRC=m
+CONFIG_IR_LIRC_CODEC=m
+CONFIG_IR_NEC_DECODER=m
+CONFIG_IR_RC5_DECODER=m
+CONFIG_IR_RC6_DECODER=m
+CONFIG_IR_JVC_DECODER=m
+CONFIG_IR_SONY_DECODER=m
+CONFIG_IR_RC5_SZ_DECODER=m
+CONFIG_IR_SANYO_DECODER=m
+CONFIG_IR_MCE_KBD_DECODER=m
+CONFIG_RC_DEVICES=y
+CONFIG_RC_ATI_REMOTE=m
+CONFIG_IR_IMON=m
+CONFIG_IR_MCEUSB=m
+CONFIG_IR_REDRAT3=m
+CONFIG_IR_STREAMZAP=m
+CONFIG_IR_IGUANA=m
+CONFIG_RC_LOOPBACK=m
+CONFIG_IR_GPIO_CIR=m
+CONFIG_MEDIA_ATTACH=y
+CONFIG_MEDIA_TUNER=m
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+
+#
+# Customize TV tuners
+#
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_MEDIA_TUNER_MT2063=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_MEDIA_TUNER_MT2131=m
+CONFIG_MEDIA_TUNER_QT1010=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_XC4000=m
+CONFIG_MEDIA_TUNER_MXL5005S=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_MEDIA_TUNER_MAX2165=m
+CONFIG_MEDIA_TUNER_TDA18218=m
+CONFIG_MEDIA_TUNER_FC0011=m
+CONFIG_MEDIA_TUNER_FC0012=m
+CONFIG_MEDIA_TUNER_FC0013=m
+CONFIG_MEDIA_TUNER_TDA18212=m
+CONFIG_MEDIA_TUNER_TUA9001=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_VIDEOBUF_GEN=m
+CONFIG_VIDEOBUF_VMALLOC=m
+CONFIG_VIDEOBUF_DVB=m
+CONFIG_VIDEO_TVEEPROM=m
+CONFIG_VIDEO_TUNER=m
+CONFIG_VIDEOBUF2_CORE=m
+CONFIG_VIDEOBUF2_MEMOPS=m
+CONFIG_VIDEOBUF2_VMALLOC=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_IR_I2C=m
+
+#
+# Audio decoders, processors and mixers
+#
+CONFIG_VIDEO_MSP3400=m
+CONFIG_VIDEO_CS53L32A=m
+CONFIG_VIDEO_WM8775=m
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+CONFIG_VIDEO_SAA711X=m
+CONFIG_VIDEO_TVP5150=m
+
+#
+# Video and audio decoders
+#
+CONFIG_VIDEO_CX25840=m
+
+#
+# MPEG video encoders
+#
+CONFIG_VIDEO_CX2341X=m
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+CONFIG_VIDEO_MT9V011=m
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Miscelaneous helper chips
+#
+CONFIG_VIDEO_VIVI=m
+CONFIG_V4L_USB_DRIVERS=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+CONFIG_USB_M5602=m
+CONFIG_USB_STV06XX=m
+CONFIG_USB_GL860=m
+CONFIG_USB_GSPCA_BENQ=m
+CONFIG_USB_GSPCA_CONEX=m
+CONFIG_USB_GSPCA_CPIA1=m
+CONFIG_USB_GSPCA_ETOMS=m
+CONFIG_USB_GSPCA_FINEPIX=m
+CONFIG_USB_GSPCA_JEILINJ=m
+CONFIG_USB_GSPCA_JL2005BCD=m
+CONFIG_USB_GSPCA_KINECT=m
+CONFIG_USB_GSPCA_KONICA=m
+CONFIG_USB_GSPCA_MARS=m
+CONFIG_USB_GSPCA_MR97310A=m
+CONFIG_USB_GSPCA_NW80X=m
+CONFIG_USB_GSPCA_OV519=m
+CONFIG_USB_GSPCA_OV534=m
+CONFIG_USB_GSPCA_OV534_9=m
+CONFIG_USB_GSPCA_PAC207=m
+CONFIG_USB_GSPCA_PAC7302=m
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_USB_GSPCA_SE401=m
+CONFIG_USB_GSPCA_SN9C2028=m
+CONFIG_USB_GSPCA_SN9C20X=m
+CONFIG_USB_GSPCA_SONIXB=m
+CONFIG_USB_GSPCA_SONIXJ=m
+CONFIG_USB_GSPCA_SPCA500=m
+CONFIG_USB_GSPCA_SPCA501=m
+CONFIG_USB_GSPCA_SPCA505=m
+CONFIG_USB_GSPCA_SPCA506=m
+CONFIG_USB_GSPCA_SPCA508=m
+CONFIG_USB_GSPCA_SPCA561=m
+CONFIG_USB_GSPCA_SPCA1528=m
+CONFIG_USB_GSPCA_SQ905=m
+CONFIG_USB_GSPCA_SQ905C=m
+CONFIG_USB_GSPCA_SQ930X=m
+CONFIG_USB_GSPCA_STK014=m
+CONFIG_USB_GSPCA_STV0680=m
+CONFIG_USB_GSPCA_SUNPLUS=m
+CONFIG_USB_GSPCA_T613=m
+CONFIG_USB_GSPCA_TOPRO=m
+CONFIG_USB_GSPCA_TV8532=m
+CONFIG_USB_GSPCA_VC032X=m
+CONFIG_USB_GSPCA_VICAM=m
+CONFIG_USB_GSPCA_XIRLINK_CIT=m
+CONFIG_USB_GSPCA_ZC3XX=m
+CONFIG_USB_PWC=m
+# CONFIG_USB_PWC_DEBUG is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+CONFIG_VIDEO_CPIA2=m
+CONFIG_USB_ZR364XX=m
+CONFIG_USB_STKWEBCAM=m
+CONFIG_USB_S2255=m
+CONFIG_USB_SN9C102=m
+
+#
+# Webcam and/or TV USB devices
+#
+CONFIG_VIDEO_EM28XX=m
+CONFIG_VIDEO_EM28XX_ALSA=m
+CONFIG_VIDEO_EM28XX_DVB=m
+CONFIG_VIDEO_EM28XX_RC=m
+
+#
+# TV USB devices
+#
+CONFIG_VIDEO_AU0828=m
+CONFIG_VIDEO_PVRUSB2=m
+CONFIG_VIDEO_PVRUSB2_SYSFS=y
+CONFIG_VIDEO_PVRUSB2_DVB=y
+# CONFIG_VIDEO_PVRUSB2_DEBUGIFC is not set
+CONFIG_VIDEO_HDPVR=m
+CONFIG_VIDEO_TLG2300=m
+CONFIG_VIDEO_CX231XX=m
+CONFIG_VIDEO_CX231XX_RC=y
+CONFIG_VIDEO_CX231XX_ALSA=m
+CONFIG_VIDEO_CX231XX_DVB=m
+CONFIG_VIDEO_TM6000=m
+CONFIG_VIDEO_TM6000_ALSA=m
+CONFIG_VIDEO_TM6000_DVB=m
+CONFIG_VIDEO_USBVISION=m
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_SI470X is not set
+CONFIG_USB_MR800=m
+CONFIG_USB_DSBR=m
+CONFIG_RADIO_SHARK=m
+CONFIG_RADIO_SHARK2=m
+CONFIG_I2C_SI4713=m
+CONFIG_RADIO_SI4713=m
+CONFIG_USB_KEENE=m
+CONFIG_RADIO_TEA5764=m
+CONFIG_RADIO_SAA7706H=m
+CONFIG_RADIO_TEF6862=m
+# CONFIG_RADIO_WL1273 is not set
+
+#
+# Texas Instruments WL128x FM driver (ST based)
+#
+# CONFIG_RADIO_WL128X is not set
+CONFIG_DVB_MAX_ADAPTERS=8
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_DVB_CAPTURE_DRIVERS=y
+CONFIG_TTPCI_EEPROM=m
+
+#
+# Supported USB Adapters
+#
+CONFIG_DVB_USB=m
+# CONFIG_DVB_USB_DEBUG is not set
+CONFIG_DVB_USB_A800=m
+CONFIG_DVB_USB_DIBUSB_MB=m
+CONFIG_DVB_USB_DIBUSB_MB_FAULTY=y
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_DVB_USB_M920X=m
+CONFIG_DVB_USB_GL861=m
+CONFIG_DVB_USB_AU6610=m
+CONFIG_DVB_USB_DIGITV=m
+CONFIG_DVB_USB_VP7045=m
+CONFIG_DVB_USB_VP702X=m
+CONFIG_DVB_USB_GP8PSK=m
+CONFIG_DVB_USB_NOVA_T_USB2=m
+CONFIG_DVB_USB_TTUSB2=m
+CONFIG_DVB_USB_DTT200U=m
+CONFIG_DVB_USB_OPERA1=m
+CONFIG_DVB_USB_AF9005=m
+CONFIG_DVB_USB_AF9005_REMOTE=m
+CONFIG_DVB_USB_PCTV452E=m
+CONFIG_DVB_USB_DW2102=m
+CONFIG_DVB_USB_CINERGY_T2=m
+CONFIG_DVB_USB_ANYSEE=m
+CONFIG_DVB_USB_DTV5100=m
+CONFIG_DVB_USB_AF9015=m
+CONFIG_DVB_USB_CE6230=m
+CONFIG_DVB_USB_FRIIO=m
+CONFIG_DVB_USB_EC168=m
+CONFIG_DVB_USB_AZ6007=m
+CONFIG_DVB_USB_AZ6027=m
+CONFIG_DVB_USB_LME2510=m
+CONFIG_DVB_USB_TECHNISAT_USB2=m
+CONFIG_DVB_USB_IT913X=m
+CONFIG_DVB_USB_MXL111SF=m
+CONFIG_DVB_USB_RTL28XXU=m
+CONFIG_DVB_USB_AF9035=m
+CONFIG_SMS_SIANO_MDTV=m
+
+#
+# Siano module components
+#
+CONFIG_SMS_USB_DRV=m
+# CONFIG_SMS_SDIO_DRV is not set
+
+#
+# Supported FlexCopII (B2C2) Adapters
+#
+CONFIG_DVB_B2C2_FLEXCOP=m
+CONFIG_DVB_B2C2_FLEXCOP_USB=m
+# CONFIG_DVB_B2C2_FLEXCOP_DEBUG is not set
+
+#
+# Supported DVB Frontends
+#
+CONFIG_DVB_FE_CUSTOMISE=y
+
+#
+# Customise DVB Frontends
+#
+
+#
+# Multistandard (satellite) frontends
+#
+CONFIG_DVB_STB0899=m
+CONFIG_DVB_STB6100=m
+CONFIG_DVB_STV090x=m
+CONFIG_DVB_STV6110x=m
+
+#
+# Multistandard (cable + terrestrial) frontends
+#
+CONFIG_DVB_DRXK=m
+CONFIG_DVB_TDA18271C2DD=m
+
+#
+# DVB-S (satellite) frontends
+#
+CONFIG_DVB_CX24110=m
+CONFIG_DVB_CX24123=m
+CONFIG_DVB_MT312=m
+CONFIG_DVB_ZL10036=m
+CONFIG_DVB_ZL10039=m
+CONFIG_DVB_S5H1420=m
+CONFIG_DVB_STV0288=m
+CONFIG_DVB_STB6000=m
+CONFIG_DVB_STV0299=m
+CONFIG_DVB_STV6110=m
+CONFIG_DVB_STV0900=m
+CONFIG_DVB_TDA8083=m
+CONFIG_DVB_TDA10086=m
+CONFIG_DVB_TDA8261=m
+CONFIG_DVB_VES1X93=m
+CONFIG_DVB_TUNER_ITD1000=m
+CONFIG_DVB_TUNER_CX24113=m
+CONFIG_DVB_TDA826X=m
+CONFIG_DVB_TUA6100=m
+CONFIG_DVB_CX24116=m
+CONFIG_DVB_SI21XX=m
+CONFIG_DVB_DS3000=m
+CONFIG_DVB_MB86A16=m
+CONFIG_DVB_TDA10071=m
+
+#
+# DVB-T (terrestrial) frontends
+#
+CONFIG_DVB_SP8870=m
+CONFIG_DVB_SP887X=m
+CONFIG_DVB_CX22700=m
+CONFIG_DVB_CX22702=m
+CONFIG_DVB_S5H1432=m
+CONFIG_DVB_DRXD=m
+CONFIG_DVB_L64781=m
+CONFIG_DVB_TDA1004X=m
+CONFIG_DVB_NXT6000=m
+CONFIG_DVB_MT352=m
+CONFIG_DVB_ZL10353=m
+CONFIG_DVB_DIB3000MB=m
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_DIB7000P=m
+CONFIG_DVB_DIB9000=m
+CONFIG_DVB_TDA10048=m
+CONFIG_DVB_AF9013=m
+CONFIG_DVB_EC100=m
+CONFIG_DVB_HD29L2=m
+CONFIG_DVB_STV0367=m
+CONFIG_DVB_CXD2820R=m
+CONFIG_DVB_RTL2830=m
+CONFIG_DVB_RTL2832=m
+
+#
+# DVB-C (cable) frontends
+#
+CONFIG_DVB_VES1820=m
+CONFIG_DVB_TDA10021=m
+CONFIG_DVB_TDA10023=m
+CONFIG_DVB_STV0297=m
+
+#
+# ATSC (North American/Korean Terrestrial/Cable DTV) frontends
+#
+CONFIG_DVB_NXT200X=m
+CONFIG_DVB_OR51211=m
+CONFIG_DVB_OR51132=m
+CONFIG_DVB_BCM3510=m
+CONFIG_DVB_LGDT330X=m
+CONFIG_DVB_LGDT3305=m
+CONFIG_DVB_LG2160=m
+CONFIG_DVB_S5H1409=m
+CONFIG_DVB_AU8522=m
+CONFIG_DVB_AU8522_DTV=m
+CONFIG_DVB_AU8522_V4L=m
+CONFIG_DVB_S5H1411=m
+
+#
+# ISDB-T (terrestrial) frontends
+#
+CONFIG_DVB_S921=m
+CONFIG_DVB_DIB8000=m
+CONFIG_DVB_MB86A20S=m
+
+#
+# Digital terrestrial only tuners/PLL
+#
+CONFIG_DVB_PLL=m
+CONFIG_DVB_TUNER_DIB0070=m
+CONFIG_DVB_TUNER_DIB0090=m
+
+#
+# SEC control devices for DVB-S
+#
+CONFIG_DVB_LNBP21=m
+CONFIG_DVB_LNBP22=m
+CONFIG_DVB_ISL6405=m
+CONFIG_DVB_ISL6421=m
+CONFIG_DVB_ISL6423=m
+CONFIG_DVB_A8293=m
+CONFIG_DVB_LGS8GL5=m
+CONFIG_DVB_LGS8GXX=m
+CONFIG_DVB_ATBM8830=m
+CONFIG_DVB_TDA665x=m
+CONFIG_DVB_IX2505V=m
+CONFIG_DVB_IT913X_FE=m
+CONFIG_DVB_M88RS2000=m
+CONFIG_DVB_AF9033=m
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+CONFIG_FB_TFT=m
+# CONFIG_FB_TFT_HX8340BN is not set
+# CONFIG_FB_TFT_HX8347D is not set
+# CONFIG_FB_TFT_ILI9320 is not set
+# CONFIG_FB_TFT_ILI9325 is not set
+CONFIG_FB_TFT_ILI9340=m
+# CONFIG_FB_TFT_ILI9341 is not set
+# CONFIG_FB_TFT_PCD8544 is not set
+# CONFIG_FB_TFT_S6D1121 is not set
+# CONFIG_FB_TFT_SSD1289 is not set
+# CONFIG_FB_TFT_SSD1306 is not set
+# CONFIG_FB_TFT_SSD1331 is not set
+# CONFIG_FB_TFT_SSD1351 is not set
+# CONFIG_FB_TFT_ST7735R is not set
+# CONFIG_FB_TFT_TINYLCD is not set
+# CONFIG_FB_TFT_WATTEROTT is not set
+CONFIG_FB_FLEX=m
+CONFIG_FB_TFT_FBTFT_DEVICE=m
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=m
+CONFIG_FB_SYS_COPYAREA=m
+CONFIG_FB_SYS_IMAGEBLIT=m
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=m
+# CONFIG_FB_WMT_GE_ROPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_BCM2708=y
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_SEQUENCER=m
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=m
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_RAWMIDI_SEQ=m
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_MPU401_UART=m
+CONFIG_SND_DRIVERS=y
+CONFIG_SND_DUMMY=m
+CONFIG_SND_ALOOP=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_MTPAV=m
+CONFIG_SND_SERIAL_U16550=m
+CONFIG_SND_MPU401=m
+CONFIG_SND_TEA575X=m
+CONFIG_SND_ARM=y
+# CONFIG_SND_ARMAACI is not set
+CONFIG_SND_BCM2835=m
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_UA101=m
+CONFIG_SND_USB_CAIAQ=m
+CONFIG_SND_USB_CAIAQ_INPUT=y
+CONFIG_SND_USB_6FIRE=m
+# CONFIG_SND_SOC is not set
+CONFIG_SOUND_PRIME=m
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=m
+CONFIG_HID_ACRUX=m
+# CONFIG_HID_ACRUX_FF is not set
+CONFIG_HID_APPLE=m
+# CONFIG_HID_AUREAL is not set
+CONFIG_HID_BELKIN=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=m
+CONFIG_HID_DRAGONRISE=m
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EMS_FF=m
+CONFIG_HID_ELECOM=m
+CONFIG_HID_EZKEY=m
+CONFIG_HID_HOLTEK=m
+# CONFIG_HOLTEK_FF is not set
+CONFIG_HID_KEYTOUCH=m
+CONFIG_HID_KYE=m
+CONFIG_HID_UCLOGIC=m
+CONFIG_HID_WALTOP=m
+CONFIG_HID_GYRATION=m
+CONFIG_HID_TWINHAN=m
+CONFIG_HID_KENSINGTON=m
+CONFIG_HID_LCPOWER=m
+# CONFIG_HID_LENOVO_TPKBD is not set
+CONFIG_HID_LOGITECH=m
+CONFIG_HID_LOGITECH_DJ=m
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+CONFIG_HID_MAGICMOUSE=m
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+CONFIG_HID_MULTITOUCH=m
+CONFIG_HID_NTRIG=m
+CONFIG_HID_ORTEK=m
+CONFIG_HID_PANTHERLORD=m
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_PICOLCD=m
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LCD is not set
+# CONFIG_HID_PICOLCD_LEDS is not set
+# CONFIG_HID_PRIMAX is not set
+CONFIG_HID_ROCCAT=m
+# CONFIG_HID_SAITEK is not set
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+CONFIG_HID_SPEEDLINK=m
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_GREENASIA=m
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=m
+# CONFIG_SMARTJOYPLUS_FF is not set
+# CONFIG_HID_TIVO is not set
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THRUSTMASTER=m
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_WACOM=m
+CONFIG_HID_WIIMOTE=m
+CONFIG_HID_WIIMOTE_EXT=y
+CONFIG_HID_ZEROPLUS=m
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_HID_ZYDACRON=m
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=m
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_U132_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+CONFIG_USB_DWCOTG=y
+# CONFIG_USB_CHIPIDEA is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_REALTEK=m
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_USB_STORAGE_ALAUDA=m
+CONFIG_USB_STORAGE_ONETOUCH=m
+CONFIG_USB_STORAGE_KARMA=m
+CONFIG_USB_STORAGE_CYPRESS_ATACB=m
+CONFIG_USB_STORAGE_ENE_UB6250=m
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_EZUSB=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_F81232=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+# CONFIG_USB_SERIAL_KEYSPAN_MPR is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XA is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XB is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA18X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19W is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19QW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19QI is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA49W is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA49WLC is not set
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_METRO=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MOTOROLA=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+CONFIG_USB_SERIAL_QCAUX=m
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_SAFE=m
+# CONFIG_USB_SERIAL_SAFE_PADDED is not set
+CONFIG_USB_SERIAL_SIEMENS_MPI=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_WWAN=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_USB_SERIAL_OPTICON=m
+CONFIG_USB_SERIAL_VIVOPAY_SERIAL=m
+CONFIG_USB_SERIAL_ZIO=m
+CONFIG_USB_SERIAL_SSU100=m
+CONFIG_USB_SERIAL_QT2=m
+CONFIG_USB_SERIAL_DEBUG=m
+
+#
+# USB Miscellaneous drivers
+#
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_SEVSEG=m
+CONFIG_USB_RIO500=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+CONFIG_USB_LED=m
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_LD=m
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_USB_IOWARRIOR=m
+CONFIG_USB_TEST=m
+CONFIG_USB_ISIGHTFW=m
+CONFIG_USB_YUREX=m
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+CONFIG_MMC_SDHCI_BCM2708=y
+CONFIG_MMC_SDHCI_BCM2708_DMA=y
+CONFIG_MMC_SPI=m
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=m
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=m
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_LM3556 is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_BLINKM is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=m
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=m
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=m
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_DRV_DS1307=m
+CONFIG_RTC_DRV_DS1374=m
+CONFIG_RTC_DRV_DS1672=m
+CONFIG_RTC_DRV_DS3232=m
+CONFIG_RTC_DRV_MAX6900=m
+CONFIG_RTC_DRV_RS5C372=m
+CONFIG_RTC_DRV_ISL1208=m
+CONFIG_RTC_DRV_ISL12022=m
+CONFIG_RTC_DRV_X1205=m
+CONFIG_RTC_DRV_PCF8563=m
+CONFIG_RTC_DRV_PCF8583=m
+CONFIG_RTC_DRV_M41T80=m
+# CONFIG_RTC_DRV_M41T80_WDT is not set
+CONFIG_RTC_DRV_BQ32K=m
+CONFIG_RTC_DRV_S35390A=m
+CONFIG_RTC_DRV_FM3130=m
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_RTC_DRV_RX8025=m
+CONFIG_RTC_DRV_EM3027=m
+CONFIG_RTC_DRV_RV3029C2=m
+
+#
+# SPI RTC drivers
+#
+CONFIG_RTC_DRV_M41T93=m
+CONFIG_RTC_DRV_M41T94=m
+CONFIG_RTC_DRV_DS1305=m
+CONFIG_RTC_DRV_DS1390=m
+CONFIG_RTC_DRV_MAX6902=m
+CONFIG_RTC_DRV_R9701=m
+CONFIG_RTC_DRV_RS5C348=m
+CONFIG_RTC_DRV_DS3234=m
+CONFIG_RTC_DRV_PCF2123=m
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=m
+CONFIG_UIO_PDRV=m
+CONFIG_UIO_PDRV_GENIRQ=m
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_USBIP_CORE is not set
+CONFIG_W35UND=m
+CONFIG_PRISM2_USB=m
+# CONFIG_ECHO is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_RTLLIB is not set
+CONFIG_R8712U=m
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+CONFIG_VT6656=m
+CONFIG_ZRAM=m
+# CONFIG_ZRAM_DEBUG is not set
+CONFIG_ZSMALLOC=m
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+CONFIG_SPEAKUP=m
+# CONFIG_SPEAKUP_SYNTH_ACNTSA is not set
+# CONFIG_SPEAKUP_SYNTH_ACNTPC is not set
+# CONFIG_SPEAKUP_SYNTH_APOLLO is not set
+# CONFIG_SPEAKUP_SYNTH_AUDPTR is not set
+# CONFIG_SPEAKUP_SYNTH_BNS is not set
+# CONFIG_SPEAKUP_SYNTH_DECTLK is not set
+# CONFIG_SPEAKUP_SYNTH_DECEXT is not set
+# CONFIG_SPEAKUP_SYNTH_DECPC is not set
+# CONFIG_SPEAKUP_SYNTH_DTLK is not set
+# CONFIG_SPEAKUP_SYNTH_KEYPC is not set
+# CONFIG_SPEAKUP_SYNTH_LTLK is not set
+CONFIG_SPEAKUP_SYNTH_SOFT=m
+# CONFIG_SPEAKUP_SYNTH_SPKOUT is not set
+# CONFIG_SPEAKUP_SYNTH_TXPRT is not set
+# CONFIG_SPEAKUP_SYNTH_DUMMY is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+CONFIG_STAGING_MEDIA=y
+CONFIG_DVB_AS102=m
+CONFIG_EASYCAP=m
+# CONFIG_EASYCAP_DEBUG is not set
+CONFIG_LIRC_STAGING=y
+CONFIG_LIRC_IGORPLUGUSB=m
+CONFIG_LIRC_IMON=m
+CONFIG_LIRC_RPI=m
+CONFIG_LIRC_SASEM=m
+CONFIG_LIRC_SERIAL=m
+CONFIG_LIRC_SERIAL_TRANSMITTER=y
+# CONFIG_LIRC_SIR is not set
+CONFIG_LIRC_TTUSBIR=m
+# CONFIG_LIRC_ZILOG is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_PHONE is not set
+# CONFIG_RAMSTER is not set
+# CONFIG_USB_WPAN_HCD is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_WIMAX_GDM72XX is not set
+# CONFIG_CSR_WIFI is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# Hardware Spinlock drivers
+#
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+# CONFIG_JFS_DEBUG is not set
+CONFIG_JFS_STATISTICS=y
+CONFIG_XFS_FS=m
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_RT=y
+# CONFIG_XFS_DEBUG is not set
+CONFIG_GFS2_FS=m
+CONFIG_OCFS2_FS=m
+CONFIG_OCFS2_FS_O2CB=m
+CONFIG_OCFS2_FS_STATS=y
+CONFIG_OCFS2_DEBUG_MASKLOG=y
+# CONFIG_OCFS2_DEBUG_FS is not set
+CONFIG_BTRFS_FS=m
+CONFIG_BTRFS_FS_POSIX_ACL=y
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+CONFIG_NILFS2_FS=m
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=m
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_FSCACHE_HISTOGRAM=y
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+CONFIG_CACHEFILES=y
+# CONFIG_CACHEFILES_DEBUG is not set
+# CONFIG_CACHEFILES_HISTOGRAM is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_ECRYPT_FS=m
+CONFIG_HFS_FS=m
+CONFIG_HFSPLUS_FS=m
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=m
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_ZLIB=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+CONFIG_NFS_FSCACHE=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V2_ACL=y
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+# CONFIG_NFSD_FAULT_INJECTION is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+CONFIG_CIFS_WEAK_PW_HASH=y
+# CONFIG_CIFS_UPCALL is not set
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_CIFS_FSCACHE is not set
+# CONFIG_CIFS_ACL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_9P_FS=m
+# CONFIG_9P_FSCACHE is not set
+CONFIG_9P_FS_POSIX_ACL=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_BOOT_PRINTK_DELAY=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_LATENCYTOP=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_KPROBE_EVENT is not set
+# CONFIG_PROBE_EVENTS is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_KGDB=y
+CONFIG_KGDB_SERIAL_CONSOLE=y
+CONFIG_KGDB_TESTS=y
+# CONFIG_KGDB_TESTS_ON_BOOT is not set
+CONFIG_KGDB_KDB=y
+CONFIG_KDB_KEYBOARD=y
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_STRICT_DEVMEM=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_OC_ETM is not set
+# CONFIG_ARM_KPROBES_TEST is not set
+# CONFIG_PID_IN_CONTEXTIDR is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=m
+CONFIG_ASYNC_CORE=m
+CONFIG_ASYNC_MEMCPY=m
+CONFIG_ASYNC_XOR=m
+CONFIG_ASYNC_PQ=m
+CONFIG_ASYNC_RAID6_RECOV=m
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_USER=m
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=m
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=m
+CONFIG_CRYPTO_AUTHENC=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=m
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=m
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+CONFIG_CRYPTO_CAST5=m
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=m
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_XZ_DEC=m
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_LRU_CACHE=m
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
diff --git a/board/raspberrypi/adafruit_ts/linux-3.6.11-0001-Added-Adafruit-TS-support.patch b/board/raspberrypi/adafruit_ts/linux-3.6.11-0001-Added-Adafruit-TS-support.patch
new file mode 100644
index 0000000..f1a1143
--- /dev/null
+++ b/board/raspberrypi/adafruit_ts/linux-3.6.11-0001-Added-Adafruit-TS-support.patch
@@ -0,0 +1,9407 @@
+From 11592b9d65e39d960871eb549737228823a75f54 Mon Sep 17 00:00:00 2001
+From: Pierre FICHEUX <pierre.ficheux@openwide.fr>
+Date: Mon, 25 Aug 2014 14:12:11 +0200
+Subject: [PATCH] Added Adafruit TS support
+
+---
+ arch/arm/mach-bcm2708/bcm2708.c           |    7 +
+ arch/arm/mach-bcm2708/include/mach/irqs.h |    3 +-
+ drivers/input/touchscreen/stmpe-ts.c      |   18 +-
+ drivers/misc/Kconfig                      |   10 +
+ drivers/misc/Makefile                     |    1 +
+ drivers/misc/rpi-pwm.c                    |  684 +++++++++++++++
+ drivers/power/Kconfig                     |    5 +
+ drivers/power/Makefile                    |    1 +
+ drivers/power/rpi_power_switch.c          |  415 +++++++++
+ drivers/video/Kconfig                     |    2 +
+ drivers/video/Makefile                    |    1 +
+ drivers/video/fbtft/.gitignore            |   87 ++
+ drivers/video/fbtft/Kconfig               |  109 +++
+ drivers/video/fbtft/Makefile              |   24 +
+ drivers/video/fbtft/README                |   24 +
+ drivers/video/fbtft/fb_hx8340bn.c         |  227 +++++
+ drivers/video/fbtft/fb_hx8347d.c          |  179 ++++
+ drivers/video/fbtft/fb_ili9320.c          |  232 +++++
+ drivers/video/fbtft/fb_ili9325.c          |  289 +++++++
+ drivers/video/fbtft/fb_ili9340.c          |  161 ++++
+ drivers/video/fbtft/fb_ili9341.c          |  177 ++++
+ drivers/video/fbtft/fb_pcd8544.c          |  176 ++++
+ drivers/video/fbtft/fb_s6d1121.c          |  206 +++++
+ drivers/video/fbtft/fb_ssd1289.c          |  204 +++++
+ drivers/video/fbtft/fb_ssd1306.c          |  227 +++++
+ drivers/video/fbtft/fb_ssd1331.c          |  203 +++++
+ drivers/video/fbtft/fb_ssd1351.c          |  223 +++++
+ drivers/video/fbtft/fb_st7735r.c          |  193 +++++
+ drivers/video/fbtft/fb_tinylcd.c          |  123 +++
+ drivers/video/fbtft/fb_watterott.c        |  323 +++++++
+ drivers/video/fbtft/fbtft-bus.c           |  256 ++++++
+ drivers/video/fbtft/fbtft-core.c          | 1336 +++++++++++++++++++++++++++++
+ drivers/video/fbtft/fbtft-io.c            |  409 +++++++++
+ drivers/video/fbtft/fbtft-sysfs.c         |  222 +++++
+ drivers/video/fbtft/fbtft.h               |  435 ++++++++++
+ drivers/video/fbtft/fbtft_device.c        | 1255 +++++++++++++++++++++++++++
+ drivers/video/fbtft/flexfb.c              |  595 +++++++++++++
+ 37 files changed, 9037 insertions(+), 5 deletions(-)
+ create mode 100644 drivers/misc/rpi-pwm.c
+ create mode 100644 drivers/power/rpi_power_switch.c
+ create mode 100644 drivers/video/fbtft/.gitignore
+ create mode 100644 drivers/video/fbtft/Kconfig
+ create mode 100644 drivers/video/fbtft/Makefile
+ create mode 100644 drivers/video/fbtft/README
+ create mode 100644 drivers/video/fbtft/fb_hx8340bn.c
+ create mode 100644 drivers/video/fbtft/fb_hx8347d.c
+ create mode 100644 drivers/video/fbtft/fb_ili9320.c
+ create mode 100644 drivers/video/fbtft/fb_ili9325.c
+ create mode 100644 drivers/video/fbtft/fb_ili9340.c
+ create mode 100644 drivers/video/fbtft/fb_ili9341.c
+ create mode 100644 drivers/video/fbtft/fb_pcd8544.c
+ create mode 100644 drivers/video/fbtft/fb_s6d1121.c
+ create mode 100644 drivers/video/fbtft/fb_ssd1289.c
+ create mode 100644 drivers/video/fbtft/fb_ssd1306.c
+ create mode 100644 drivers/video/fbtft/fb_ssd1331.c
+ create mode 100644 drivers/video/fbtft/fb_ssd1351.c
+ create mode 100644 drivers/video/fbtft/fb_st7735r.c
+ create mode 100644 drivers/video/fbtft/fb_tinylcd.c
+ create mode 100644 drivers/video/fbtft/fb_watterott.c
+ create mode 100644 drivers/video/fbtft/fbtft-bus.c
+ create mode 100644 drivers/video/fbtft/fbtft-core.c
+ create mode 100644 drivers/video/fbtft/fbtft-io.c
+ create mode 100644 drivers/video/fbtft/fbtft-sysfs.c
+ create mode 100644 drivers/video/fbtft/fbtft.h
+ create mode 100644 drivers/video/fbtft/fbtft_device.c
+ create mode 100644 drivers/video/fbtft/flexfb.c
+
+diff --git a/arch/arm/mach-bcm2708/bcm2708.c b/arch/arm/mach-bcm2708/bcm2708.c
+index 9a5632f..d230a2c 100644
+--- a/arch/arm/mach-bcm2708/bcm2708.c
++++ b/arch/arm/mach-bcm2708/bcm2708.c
+@@ -651,6 +651,11 @@ static struct platform_device bcm2835_thermal_device = {
+ 	.name = "bcm2835_thermal",
+ };
+ 
++static struct platform_device bcm2708_pwm_device = {
++	.name = "bcm2708_pwm",
++	.id = 0,
++};
++
+ int __init bcm_register_device(struct platform_device *pdev)
+ {
+ 	int ret;
+@@ -777,6 +782,8 @@ void __init bcm2708_init(void)
+ 	bcm_register_device(&bcm2708_bsc0_device);
+ 	bcm_register_device(&bcm2708_bsc1_device);
+ 
++	bcm_register_device(&bcm2708_pwm_device);
++
+ 	bcm_register_device(&bcm2835_hwmon_device);
+ 	bcm_register_device(&bcm2835_thermal_device);
+ 
+diff --git a/arch/arm/mach-bcm2708/include/mach/irqs.h b/arch/arm/mach-bcm2708/include/mach/irqs.h
+index 9aaedf1..1947d91 100644
+--- a/arch/arm/mach-bcm2708/include/mach/irqs.h
++++ b/arch/arm/mach-bcm2708/include/mach/irqs.h
+@@ -192,8 +192,9 @@
+ #define HARD_IRQS	      (64 + 21)
+ #define FIQ_IRQS              (64 + 21)
+ #define GPIO_IRQS	      (32*5)
++#define SPARE_IRQS		(64)
+ 
+-#define NR_IRQS		      HARD_IRQS+FIQ_IRQS+GPIO_IRQS
++#define NR_IRQS		      HARD_IRQS+FIQ_IRQS+GPIO_IRQS+SPARE_IRQS
+ 
+ 
+ #endif /* _BCM2708_IRQS_H_ */
+diff --git a/drivers/input/touchscreen/stmpe-ts.c b/drivers/input/touchscreen/stmpe-ts.c
+index 692b685..7099ce4 100644
+--- a/drivers/input/touchscreen/stmpe-ts.c
++++ b/drivers/input/touchscreen/stmpe-ts.c
+@@ -76,6 +76,7 @@ struct stmpe_touch {
+ 	u8 settling;
+ 	u8 fraction_z;
+ 	u8 i_drive;
++	u8 touch_active;
+ };
+ 
+ static int __stmpe_reset_fifo(struct stmpe *stmpe)
+@@ -117,6 +118,8 @@ static void stmpe_work(struct work_struct *work)
+ 	/* reset the FIFO before we report release event */
+ 	__stmpe_reset_fifo(ts->stmpe);
+ 
++	ts->touch_active = 0;
++	input_report_key(ts->idev, BTN_TOUCH, 0);
+ 	input_report_abs(ts->idev, ABS_PRESSURE, 0);
+ 	input_sync(ts->idev);
+ }
+@@ -148,10 +151,17 @@ static irqreturn_t stmpe_ts_handler(int irq, void *data)
+ 	y = ((data_set[1] & 0xf) << 8) | data_set[2];
+ 	z = data_set[3];
+ 
+-	input_report_abs(ts->idev, ABS_X, x);
+-	input_report_abs(ts->idev, ABS_Y, y);
+-	input_report_abs(ts->idev, ABS_PRESSURE, z);
+-	input_sync(ts->idev);
++	/* Sometimes, the chip reports values of all zeroes.  Ignore these. */
++	if (x && y && z) {
++		input_report_abs(ts->idev, ABS_X, x);
++		input_report_abs(ts->idev, ABS_Y, y);
++		input_report_abs(ts->idev, ABS_PRESSURE, z);
++		if (!ts->touch_active) {
++			ts->touch_active = 1;
++			input_report_key(ts->idev, BTN_TOUCH, 1);
++		}
++		input_sync(ts->idev);
++	}
+ 
+        /* flush the FIFO after we have read out our values. */
+ 	__stmpe_reset_fifo(ts->stmpe);
+diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
+index f738bf3..99bcf28 100644
+--- a/drivers/misc/Kconfig
++++ b/drivers/misc/Kconfig
+@@ -509,6 +509,16 @@ config USB_SWITCH_FSA9480
+ 	  stereo and mono audio, video, microphone and UART data to use
+ 	  a common connector port.
+ 
++config RPI_PWM
++	tristate "Raspberry Pi PWM driver"
++	depends on EXPERIMENTAL && MACH_BCM2708
++	default m
++	help
++	 The Raspberry Pi has a single PWM pin broken out on pin 12 of its
++	 expansion port.  This driver will turn that pin from a GPIO into a
++	 PWM, and will export a sysfs directory, /sys/devices/platform/pwm,
++	 to allow for control over the PWM output.
++
+ source "drivers/misc/c2port/Kconfig"
+ source "drivers/misc/eeprom/Kconfig"
+ source "drivers/misc/cb710/Kconfig"
+diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
+index dc9072b..f00826b 100644
+--- a/drivers/misc/Makefile
++++ b/drivers/misc/Makefile
+@@ -35,6 +35,7 @@ obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
+ obj-$(CONFIG_EP93XX_PWM)	+= ep93xx_pwm.o
+ obj-$(CONFIG_DS1682)		+= ds1682.o
+ obj-$(CONFIG_TI_DAC7512)	+= ti_dac7512.o
++obj-$(CONFIG_RPI_PWM)		+= rpi-pwm.o
+ obj-$(CONFIG_C2PORT)		+= c2port/
+ obj-$(CONFIG_HMC6352)		+= hmc6352.o
+ obj-y				+= eeprom/
+diff --git a/drivers/misc/rpi-pwm.c b/drivers/misc/rpi-pwm.c
+new file mode 100644
+index 0000000..3ecfe43
+--- /dev/null
++++ b/drivers/misc/rpi-pwm.c
+@@ -0,0 +1,684 @@
++/*
++ * Adafruit PWM driver for Raspberry Pi
++ *
++ * Provides a sysfs interface to the PWM port present on pin 18 of the
++ * Raspberry Pi expansion header.  Allows for driving a servo, or variable
++ * frequency waveforms.
++ *
++ * It tends to have problems locking on to frequencies above 100 kHz, and
++ * with indivisible duty cycles.
++ *
++ * - Written by Sean Cross for Adafruit Industries (www.adafruit.com)
++ */
++
++#define RPI_PWM_VERSION "1.0"
++#define PWM_CLASS_NAME "rpi-pwm"
++
++#include <linux/module.h>
++
++#include <asm/io.h>
++#include <linux/delay.h>
++#include <linux/types.h>
++#include <linux/errno.h>
++#include <linux/fs.h>
++#include <linux/device.h>
++#include <linux/platform_device.h>
++#include <linux/init.h>
++#include <linux/mutex.h>
++#include <asm/uaccess.h>
++#include <linux/sysfs.h>
++
++#define BCM2708_PERI_BASE	0x20000000
++#define GPIO_BASE		(BCM2708_PERI_BASE + 0x200000)
++#define PWM_BASE		(BCM2708_PERI_BASE + 0x20C000)
++#define CLOCK_BASE		(BCM2708_PERI_BASE + 0x101000)
++
++#define GPIO_REG(g) (gpio_reg+((g/10)*4))
++#define SET_GPIO_ALT(g,a) \
++	__raw_writel( 							\
++		(((a)<=3?(a)+4:(a)==4?3:2)<<(((g)%10)*3))		\
++		| (__raw_readl(GPIO_REG(g)) & (~(7<<(((g)%10)*3)))),	\
++		GPIO_REG(g))
++
++#define	PWM_CTL  (pwm_reg+(0*4))
++#define	PWM_RNG1 (pwm_reg+(4*4))
++#define	PWM_DAT1 (pwm_reg+(5*4))
++
++#define	PWMCLK_CNTL (clk_reg+(40*4))
++#define	PWMCLK_DIV  (clk_reg+(41*4))
++
++
++static DEFINE_MUTEX(sysfs_lock);
++static void __iomem *pwm_reg;
++static void __iomem *gpio_reg;
++static void __iomem *clk_reg;
++
++enum device_mode {
++	MODE_PWM,
++	MODE_SERVO,
++	MODE_AUDIO,
++};
++
++static char *device_mode_str[] = {
++	"pwm",
++	"servo",
++	"audio",
++};
++
++struct rpi_pwm {
++	u32 duty;
++	u32 frequency;
++	u32 servo_val;
++	u32 servo_max;
++	int active:1;
++	int immediate:1;
++	int loaded:1;
++	int id;
++	enum device_mode mode;	/* Servo, PWM, or Audio */
++	struct device *dev;
++
++	u32 divisor;
++	u32 mcf; /* Maximum common frequency (desired) */
++	u32 real_mcf;
++};
++
++
++static struct rpi_pwm pwms[] = {
++	{
++		.immediate	= 1,
++		.duty		= 50,
++		.servo_max	= 32,
++		.mcf		= 16000,  /* 16 kHz is a good common number */
++	},
++};
++
++
++/* Sets the system timer to have the new divisor */
++static int rpi_pwm_set_clk(struct rpi_pwm *dev, u32 mcf) {
++	/* Stop clock and waiting for busy flag doesn't work, so kill clock */
++	__raw_writel(0x5A000000 | (1 << 5), PWMCLK_CNTL);
++	udelay(10);  
++
++	if (!dev->mcf) {
++		dev_err(dev->dev, "no MCF specified\n");
++		return -EINVAL;
++	}
++
++	/* Set frequency
++	 * DIVI is the integer part of the divisor
++	 * the fractional part (DIVF) drops clock cycles to get the
++	 * output frequency, bad for servo motors
++	 * 320 bits for one cycle of 20 milliseconds = 62.5 us per bit = 16 kHz
++	 */
++	dev->divisor = 19200000 / mcf;
++	if (dev->divisor < 1 || dev->divisor > 0x1000) {
++		dev_err(dev->dev, "divisor out of range: %x\n", dev->divisor);
++		return -ERANGE;
++	}
++	__raw_writel(0x5A000000 | (dev->divisor<<12), PWMCLK_DIV);
++	
++	/* Enable the PWM clock */
++	__raw_writel(0x5A000011, PWMCLK_CNTL);
++
++	/* Calculate the real maximum common frequency */
++	dev->real_mcf = 19200000 / dev->divisor;
++
++	return 0;
++}
++
++
++static int rpi_pwm_set_servo(struct rpi_pwm *dev) {
++	unsigned long RNG, DAT;
++	unsigned long mcf = 16000, frequency=50;
++	int ret;
++
++	/* Disable PWM */
++	__raw_writel(0, PWM_CTL);
++
++	/* Wait for the PWM to be disabled, otherwise PWM block hangs */
++	udelay(10);
++
++	ret = rpi_pwm_set_clk(dev, mcf);
++	if (ret)
++		return ret;
++
++	RNG = mcf/frequency;
++	DAT = (mcf*2*dev->servo_val/dev->servo_max/frequency/20)
++	    + (mcf/frequency/40);
++
++	if (RNG < 1) {
++		dev_err(dev->dev, "RNG is out of range: %ld<1\n", RNG);
++		return -ERANGE;
++	}
++
++	if (DAT < 1) {
++		dev_err(dev->dev, "DAT is out of range: %ld<1\n", DAT);
++		return -ERANGE;
++	}
++
++	__raw_writel(RNG, PWM_RNG1);
++	__raw_writel(DAT, PWM_DAT1);
++
++	/* Enable MSEN mode, and start PWM */
++	__raw_writel(0x81, PWM_CTL);
++
++	return 0;
++}
++
++
++static int rpi_pwm_set_frequency(struct rpi_pwm *dev) {
++	unsigned long RNG, DAT;
++	int ret;
++	/* Disable PWM */
++	__raw_writel(0, PWM_CTL);
++
++	/* Wait for the PWM to be disabled, otherwise PWM block hangs */
++	udelay(10);
++
++	ret = rpi_pwm_set_clk(dev, dev->mcf);
++	if (ret)
++		return ret;
++
++	RNG = dev->mcf/dev->frequency;
++	DAT = RNG*dev->duty/100;
++
++	if (RNG < 1) {
++		dev_err(dev->dev, "RNG is out of range: %ld<1\n", RNG);
++		return -ERANGE;
++	}
++
++	if (DAT < 1) {
++		dev_err(dev->dev, "DAT is out of range: %ld<1\n", DAT);
++		return -ERANGE;
++	}
++
++	__raw_writel(RNG, PWM_RNG1);
++	__raw_writel(DAT, PWM_DAT1);
++
++	/* Enable MSEN mode, and start PWM */
++	__raw_writel(0x81, PWM_CTL);
++
++	return 0;
++}
++
++
++static int rpi_pwm_activate(struct rpi_pwm *dev) {
++	int ret = 0;
++
++	/* Set PWM alternate function for GPIO18 */
++	SET_GPIO_ALT(18, 5);
++
++	if (dev->mode == MODE_SERVO)
++		ret = rpi_pwm_set_servo(dev);
++
++	else if (dev->mode == MODE_PWM)
++		ret = rpi_pwm_set_frequency(dev);
++
++	else if (dev->mode == MODE_AUDIO) {
++		/* Nothing to do */
++		;
++	}
++
++	dev->active = 1;
++	return ret;
++}
++
++
++static int rpi_pwm_deactivate(struct rpi_pwm *dev) {
++	if (dev->mode != MODE_AUDIO)
++		__raw_writel(0, PWM_CTL);
++	udelay(10);
++	SET_GPIO_ALT(18, 0);
++	udelay(10);
++	dev->active = 0;
++	return 0;
++}
++
++
++
++static ssize_t active_show(struct device *d,
++		struct device_attribute *attr, char *buf)
++{
++	ssize_t ret;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++	mutex_lock(&sysfs_lock);
++	ret = sprintf(buf, "%d\n", !!dev->active);
++	mutex_unlock(&sysfs_lock);
++	return ret;
++}
++
++static ssize_t active_store(struct device *d,
++		struct device_attribute *attr, const char *buf, size_t count)
++{
++	ssize_t ret = 0;
++	long new_active;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++
++	mutex_lock(&sysfs_lock);
++	ret = strict_strtol(buf, 0, &new_active);
++	if (ret == 0) {
++		if (new_active)
++			ret = rpi_pwm_activate(dev);
++		else
++			ret = rpi_pwm_deactivate(dev);
++	}
++	else
++		ret = -EINVAL;
++	mutex_unlock(&sysfs_lock);
++	return ret?ret:count;
++}
++static DEVICE_ATTR(active, 0666, active_show, active_store);
++
++
++static ssize_t mode_show(struct device *d,
++		struct device_attribute *attr, char *buf)
++{
++	ssize_t ret;
++	char tmp_bfr[512];
++	char *tmp_bfr_ptr = tmp_bfr;
++	int offset;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++	mutex_lock(&sysfs_lock);
++	for (offset=0; offset < ARRAY_SIZE(device_mode_str); offset++) {
++		if (dev->mode == offset)
++			*tmp_bfr_ptr++ = '[';
++		strcpy(tmp_bfr_ptr, device_mode_str[offset]);
++		tmp_bfr_ptr += strlen(device_mode_str[offset]);
++		if (dev->mode == offset)
++			*tmp_bfr_ptr++ = ']';
++		*tmp_bfr_ptr++ = ' ';
++	}
++	*tmp_bfr_ptr++ = 0;
++	ret = sprintf(buf, "%s\n", tmp_bfr);
++	mutex_unlock(&sysfs_lock);
++	return ret;
++}
++
++
++static ssize_t mode_store(struct device *d,
++		struct device_attribute *attr, const char *buf, size_t count)
++{
++	ssize_t ret = 0;
++	int offset;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++
++	mutex_lock(&sysfs_lock);
++	ret = -ENOENT;
++	for (offset=0; offset < ARRAY_SIZE(device_mode_str); offset++) {
++		if (!strncmp(buf,
++				 device_mode_str[offset],
++				 strlen(device_mode_str[offset]))) {
++			dev->mode = offset;
++
++			if (dev->immediate)
++				rpi_pwm_activate(dev);
++
++			/* If switching to audio mode, switch out of
++			 * immediate mode.  This protects us from locking
++			 * up the audio system by altering PWM values while
++			 * audio playback is occurring.
++			 */
++			if (offset == MODE_AUDIO)
++				dev->immediate = 0;
++
++			ret = 0;
++			break;
++		}
++	}
++	mutex_unlock(&sysfs_lock);
++	return ret?ret:count;
++}
++static DEVICE_ATTR(mode, 0666, mode_show, mode_store);
++
++
++
++static ssize_t duty_show(struct device *d,
++		struct device_attribute *attr, char *buf)
++{
++	ssize_t ret;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++	mutex_lock(&sysfs_lock);
++	ret = sprintf(buf, "%d%%\n", dev->duty);
++	mutex_unlock(&sysfs_lock);
++	return ret;
++}
++
++static ssize_t duty_store(struct device *d,
++		struct device_attribute *attr, const char *buf, size_t count)
++{
++	ssize_t ret = 0;
++	long new_duty;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++
++	mutex_lock(&sysfs_lock);
++	ret = strict_strtol(buf, 0, &new_duty);
++	if (ret == 0) {
++		if (new_duty > 0 && new_duty < 100) {
++			dev->duty = new_duty;
++			dev->mode = MODE_PWM;
++			if (dev->immediate)
++				rpi_pwm_activate(dev);
++		}
++		else
++			ret = -ERANGE;
++	}
++	mutex_unlock(&sysfs_lock);
++	return ret?ret:count;
++}
++static DEVICE_ATTR(duty, 0666, duty_show, duty_store);
++
++
++
++
++static ssize_t mcf_show(struct device *d,
++		struct device_attribute *attr, char *buf)
++{
++	ssize_t ret;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++	mutex_lock(&sysfs_lock);
++	ret = sprintf(buf, "%d\n", dev->mcf);
++	mutex_unlock(&sysfs_lock);
++	return ret;
++}
++
++static ssize_t mcf_store(struct device *d,
++		struct device_attribute *attr, const char *buf, size_t count)
++{
++	ssize_t ret = 0;
++	long new_mcf;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++
++	mutex_lock(&sysfs_lock);
++	ret = strict_strtol(buf, 0, &new_mcf);
++	if (ret == 0) {
++		if (new_mcf > 1 && new_mcf < 100000000) {
++			dev->mcf = new_mcf;
++			dev->mode = MODE_PWM;
++			if (dev->immediate)
++				rpi_pwm_activate(dev);
++		}
++		else
++			ret = -ERANGE;
++	}
++	mutex_unlock(&sysfs_lock);
++	return ret?ret:count;
++}
++static DEVICE_ATTR(mcf, 0666, mcf_show, mcf_store);
++
++
++
++static ssize_t real_freq_show(struct device *d,
++		struct device_attribute *attr, char *buf)
++{
++	ssize_t ret;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++	unsigned long RNG;
++	mutex_lock(&sysfs_lock);
++	if (dev->frequency) {
++		RNG = dev->mcf/dev->frequency;
++		if (RNG < 1)
++			ret = -EINVAL;
++		else
++			ret = sprintf(buf, "%ld\n", dev->real_mcf/RNG);
++	}
++	else
++		ret = -EINVAL;
++	mutex_unlock(&sysfs_lock);
++	return ret;
++}
++static DEVICE_ATTR(real_frequency, 0666, real_freq_show, NULL);
++
++
++
++static ssize_t servo_val_show(struct device *d,
++		struct device_attribute *attr, char *buf)
++{
++	ssize_t ret;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++	mutex_lock(&sysfs_lock);
++	ret = sprintf(buf, "%d\n", dev->servo_val);
++	mutex_unlock(&sysfs_lock);
++	return ret;
++}
++
++static ssize_t servo_val_store(struct device *d,
++		struct device_attribute *attr, const char *buf, size_t count)
++{
++	ssize_t ret = 0;
++	long new_servo_val;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++
++	mutex_lock(&sysfs_lock);
++	ret = strict_strtol(buf, 0, &new_servo_val);
++	if (ret == 0) {
++		if (new_servo_val >= 0 && new_servo_val <= dev->servo_max) {
++			dev->servo_val = new_servo_val;
++			dev->mode = MODE_SERVO;
++			if (dev->immediate)
++				rpi_pwm_activate(dev);
++		}
++		else
++			ret = -ERANGE;
++	}
++	mutex_unlock(&sysfs_lock);
++	return ret?ret:count;
++}
++static DEVICE_ATTR(servo, 0666, servo_val_show, servo_val_store);
++
++
++
++static ssize_t servo_max_show(struct device *d,
++		struct device_attribute *attr, char *buf)
++{
++	ssize_t ret;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++	mutex_lock(&sysfs_lock);
++	ret = sprintf(buf, "%d\n", dev->servo_max);
++	mutex_unlock(&sysfs_lock);
++	return ret;
++}
++
++static ssize_t servo_max_store(struct device *d,
++		struct device_attribute *attr, const char *buf, size_t count)
++{
++	ssize_t ret = 0;
++	long new_servo_max;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++
++	mutex_lock(&sysfs_lock);
++	ret = strict_strtol(buf, 0, &new_servo_max);
++	if (ret == 0) {
++		if (new_servo_max > 0) {
++			/* Scale the rotation to match new max */
++			dev->servo_val = dev->servo_val
++				       *new_servo_max / dev->servo_max;
++
++			dev->servo_max = new_servo_max;
++			dev->mode = MODE_SERVO;
++			if (dev->immediate)
++				rpi_pwm_activate(dev);
++		}
++		else
++			ret = -ERANGE;
++	}
++	mutex_unlock(&sysfs_lock);
++	return ret?ret:count;
++}
++static DEVICE_ATTR(servo_max, 0666, servo_max_show, servo_max_store);
++
++
++
++static ssize_t freq_show(struct device *d,
++		struct device_attribute *attr, char *buf)
++{
++	ssize_t ret;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++	mutex_lock(&sysfs_lock);
++	ret = sprintf(buf, "%d\n", dev->frequency);
++	mutex_unlock(&sysfs_lock);
++	return ret;
++}
++
++static ssize_t freq_store(struct device *d,
++		struct device_attribute *attr, const char *buf, size_t count)
++{
++	ssize_t ret = 0;
++	long new_freq;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++
++	mutex_lock(&sysfs_lock);
++	ret = strict_strtol(buf, 0, &new_freq);
++	if (ret == 0) {
++		dev->frequency = new_freq;
++		dev->mode = MODE_PWM;
++		if (dev->immediate)
++			rpi_pwm_activate(dev);
++	}
++	mutex_unlock(&sysfs_lock);
++	return ret?ret:count;
++}
++static DEVICE_ATTR(frequency, 0666, freq_show, freq_store);
++
++
++
++
++static ssize_t delayed_show(struct device *d,
++		struct device_attribute *attr, char *buf)
++{
++	ssize_t ret;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++	mutex_lock(&sysfs_lock);
++	ret = sprintf(buf, dev->immediate?"immediate\n":"delayed\n");
++	mutex_unlock(&sysfs_lock);
++	return ret;
++}
++
++static ssize_t delayed_store(struct device *d,
++		struct device_attribute *attr, const char *buf, size_t count)
++{
++	ssize_t ret = 0;
++	struct rpi_pwm *dev = dev_get_drvdata(d);
++
++	mutex_lock(&sysfs_lock);
++	if (!strcasecmp(buf, "immediate") || buf[0] == '0')
++		dev->immediate = 1;
++	else if (!strcasecmp(buf, "delayed") || buf[0] == '1')
++		dev->immediate = 0;
++	else
++		ret = -EINVAL;
++	mutex_unlock(&sysfs_lock);
++	return ret?ret:count;
++}
++static DEVICE_ATTR(delayed, 0666, delayed_show, delayed_store);
++
++
++
++
++static struct attribute *rpi_pwm_sysfs_entries[] = {
++	&dev_attr_active.attr,
++	&dev_attr_delayed.attr,
++	&dev_attr_servo.attr,
++	&dev_attr_servo_max.attr,
++	&dev_attr_duty.attr,
++	&dev_attr_mode.attr,
++	&dev_attr_mcf.attr,
++	&dev_attr_real_frequency.attr,
++	&dev_attr_frequency.attr,
++	NULL
++};
++
++static struct attribute_group rpi_pwm_attribute_group = {
++	.name = NULL,
++	.attrs = rpi_pwm_sysfs_entries,
++};
++
++static struct class pwm_class = {
++	.name =		PWM_CLASS_NAME,
++	.owner =	THIS_MODULE,
++};
++
++
++int __init rpi_pwm_init(void)
++{
++	int ret = 0;
++	int pwm = 0;
++
++	pr_info("Adafruit Industries' Raspberry Pi PWM driver v%s\n", RPI_PWM_VERSION);
++
++	ret = class_register(&pwm_class);
++	if (ret < 0) {
++		pr_err("%s: Unable to register class\n", pwm_class.name);
++		goto out0;
++	}
++
++
++	/* Create devices for each PWM present */
++	for (pwm=0; pwm<ARRAY_SIZE(pwms); pwm++) {
++		pwms[pwm].id = pwm;
++		pwms[pwm].dev = device_create(&pwm_class, &platform_bus,
++				MKDEV(0, 0), &pwms[pwm], "pwm%u", pwm);
++		if (IS_ERR(pwms[pwm].dev)) {
++			pr_err("%s: device_create failed\n", pwm_class.name);
++			ret = PTR_ERR(pwms[pwm].dev);
++			goto out1;
++		}
++	}
++
++	/* Create sysfs entries for each PWM */
++	for (pwm=0; pwm<ARRAY_SIZE(pwms); pwm++) {
++		ret = sysfs_create_group(&pwms[pwm].dev->kobj,
++						&rpi_pwm_attribute_group);
++		if (ret < 0) {
++			dev_err(pwms[pwm].dev, 
++				"failed to create sysfs device attributes\n");
++			goto out2;
++		}
++		pwms[pwm].loaded = 1;
++	}
++
++
++	clk_reg = ioremap(CLOCK_BASE, 1024);
++	pwm_reg = ioremap(PWM_BASE, 1024);
++	gpio_reg = ioremap(GPIO_BASE, 1024);
++	return 0;
++
++out2:
++	for (pwm=0; pwm<ARRAY_SIZE(pwms); pwm++)
++		if (pwms[pwm].loaded)
++			sysfs_remove_group(&pwms[pwm].dev->kobj,
++					 &rpi_pwm_attribute_group);
++
++out1:
++	for (pwm=0; pwm<ARRAY_SIZE(pwms); pwm++)
++		if (pwms[pwm].dev)
++			device_unregister(pwms[pwm].dev);
++	class_unregister(&pwm_class);
++out0:
++	return ret;
++}
++
++void __exit rpi_pwm_cleanup(void)
++{
++	int pwm;
++	for (pwm=0; pwm<ARRAY_SIZE(pwms); pwm++) {
++		if (pwms[pwm].loaded) {
++			rpi_pwm_deactivate(&pwms[pwm]);
++			sysfs_remove_group(&pwms[pwm].dev->kobj,
++						 &rpi_pwm_attribute_group);
++		}
++		if (pwms[pwm].dev)
++			device_unregister(pwms[pwm].dev);
++	}
++
++	iounmap(gpio_reg);
++	iounmap(pwm_reg);
++	iounmap(clk_reg);
++
++	class_unregister(&pwm_class);
++}
++
++module_init(rpi_pwm_init);
++module_exit(rpi_pwm_cleanup);
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Sean Cross <xobs@xoblo.gs> for Adafruit Industries <www.adafruit.com>");
++MODULE_ALIAS("platform:bcm2708_pwm");
+diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
+index c1892f3..793af9f 100644
+--- a/drivers/power/Kconfig
++++ b/drivers/power/Kconfig
+@@ -62,6 +62,11 @@ config TEST_POWER
+ 	help
+ 	  This driver is used for testing. It's safe to say M here.
+ 
++config RPI_POWER_SWITCH
++	tristate "Raspberry Pi GPIO power switch"
++	help
++	  Use a GPIO as a pseudo power switch.
++
+ config BATTERY_DS2760
+ 	tristate "DS2760 battery driver (HP iPAQ & others)"
+ 	depends on W1 && W1_SLAVE_DS2760
+diff --git a/drivers/power/Makefile b/drivers/power/Makefile
+index ee58afb..db5fba9 100644
+--- a/drivers/power/Makefile
++++ b/drivers/power/Makefile
+@@ -13,6 +13,7 @@ obj-$(CONFIG_WM831X_BACKUP)	+= wm831x_backup.o
+ obj-$(CONFIG_WM831X_POWER)	+= wm831x_power.o
+ obj-$(CONFIG_WM8350_POWER)	+= wm8350_power.o
+ obj-$(CONFIG_TEST_POWER)	+= test_power.o
++obj-$(CONFIG_RPI_POWER_SWITCH)	+= rpi_power_switch.o
+ 
+ obj-$(CONFIG_BATTERY_DS2760)	+= ds2760_battery.o
+ obj-$(CONFIG_BATTERY_DS2780)	+= ds2780_battery.o
+diff --git a/drivers/power/rpi_power_switch.c b/drivers/power/rpi_power_switch.c
+new file mode 100644
+index 0000000..230a3ec
+--- /dev/null
++++ b/drivers/power/rpi_power_switch.c
+@@ -0,0 +1,415 @@
++/*
++ * Adafruit power switch driver for Raspberry Pi
++ *
++ * Simulated power switch / button, using the GPIO banks.
++ *
++ * - Written by Sean Cross for Adafruit Industries (www.adafruit.com)
++ */
++
++#define RPI_POWER_SWITCH_VERSION "1.7"
++#define POWER_SWITCH_CLASS_NAME "rpi-power-switch"
++
++#include <linux/module.h>
++
++#include <asm/io.h>
++#include <asm/gpio.h>
++#include <linux/delay.h>
++#include <linux/reboot.h>
++#include <linux/irq.h>
++#include <linux/err.h>
++#include <linux/kdev_t.h>
++#include <linux/interrupt.h>
++#include <linux/platform_device.h>
++#include <linux/init.h>
++#include <linux/workqueue.h>
++
++
++#define BCM2708_PERI_BASE	0x20000000
++#define GPIO_BASE		(BCM2708_PERI_BASE + 0x200000)
++
++#define GPPUD (gpio_reg+0x94)
++#define GPPUDCLK0 (gpio_reg+0x98)
++#define GPPUDCLK1 (gpio_reg+0x9C)
++#define GPSET0    (gpio_reg+0x1c)
++#define GPSET1    (gpio_reg+0x20)
++#define GPCLR0    (gpio_reg+0x28)
++#define GPCLR1    (gpio_reg+0x2c)
++
++#define GPIO_REG(g) (gpio_reg+((g/10)*4))
++#define SET_GPIO_OUTPUT(g) \
++	__raw_writel( 							\
++		(1<<(((g)%10)*3))					\
++		| (__raw_readl(GPIO_REG(g)) & (~(7<<(((g)%10)*3)))),	\
++		GPIO_REG(g))
++#define SET_GPIO_INPUT(g) \
++	__raw_writel( 							\
++		0							\
++		| (__raw_readl(GPIO_REG(g)) & (~(7<<(((g)%10)*3)))),	\
++		GPIO_REG(g))
++#define SET_GPIO_ALT(g,a) \
++	__raw_writel( 							\
++		(((a)<=3?(a)+4:(a)==4?3:2)<<(((g)%10)*3))		\
++		| (__raw_readl(GPIO_REG(g)) & (~(7<<(((g)%10)*3)))),	\
++		GPIO_REG(g))
++
++enum button_mode {
++	MODE_BUTTON = 0,
++	MODE_SWITCH = 1,
++};
++
++
++enum gpio_pull_direction {
++	GPIO_PULL_NONE = 0,
++	GPIO_PULL_DOWN = 1,
++	GPIO_PULL_UP = 2,
++};
++
++
++/* Module Parameters */
++static int gpio_pin = 22;
++static int mode = MODE_SWITCH;
++static int led_pin = 16;
++
++/* This is the base state.  When this changes, do a shutdown. */
++static int gpio_pol;
++
++static void __iomem *gpio_reg;
++static void (*old_pm_power_off)(void);
++static struct device *switch_dev;
++static int raw_gpio = 0;
++
++
++/* Attach either a pull up or pull down to the specified GPIO pin.  Or
++ * clear any pull on the pin, if requested.
++ */
++static int set_gpio_pull(int gpio, enum gpio_pull_direction direction) {
++	long *bank;
++	int pin;
++
++	bank = ((gpio&(~31))?GPPUDCLK1:GPPUDCLK0);
++	pin = gpio & 31;
++
++	/* Set the direction (involves two writes and a clock wait) */
++	__raw_writel(direction, GPPUD);
++	udelay(20);
++	__raw_writel(1<<pin, bank);
++	udelay(20);
++
++	/* Cleanup */
++	__raw_writel(0, GPPUD);
++	__raw_writel(0, bank);
++	return 0;
++}
++
++
++/* If the GPIO we want to use is already being used (e.g. if a driver
++ * forgot to call gpio_free() during its module_exit() call), then we
++ * will have to directly access the GPIO registers in order to set or
++ * clear values.
++ */
++static int raw_gpio_set(int gpio, int val) {
++	if (gpio < 0 || gpio > 63)
++		return -1;
++	else if (gpio < 32) 
++		__raw_writel(1<<gpio, val?GPSET0:GPCLR0);
++	else if (gpio < 64)
++		__raw_writel(1<<gpio, val?GPSET1:GPCLR1);
++	return 0;
++}
++
++/* Bottom half of the power switch ISR.
++ * We need to break this out here, as you can't run call_usermodehelper
++ * from an interrupt context.
++ * This function will actually Call /sbin/shutdown when the switch gets hit.
++ */
++static void initiate_shutdown(struct work_struct *work) {
++	char *cmd = "/sbin/shutdown";
++	char *argv[] = {
++		cmd,
++		"-h",
++		"now",
++		NULL,
++	};
++	char *envp[] = {
++		"HOME=/",
++		"PATH=/sbin:/bin:/usr/sbin:/usr/bin",
++		NULL,
++	};
++
++	/* We only want this IRQ to fire once, ever. */
++	free_irq(gpio_to_irq(gpio_pin), NULL);
++
++	/* Make sure the switch hasn't just bounced */
++	if (mode == MODE_SWITCH && gpio_get_value(gpio_pin) != gpio_pol)
++		return;
++
++	call_usermodehelper(cmd, argv, envp, 0);
++}
++
++static struct delayed_work initiate_shutdown_work;
++
++
++/* This ISR gets called when the board is "off" and the switch changes.
++ * It indicates we should start back up again, which means we need to
++ * do a reboot.
++ */
++static irqreturn_t reboot_isr(int irqno, void *param) {
++	emergency_restart();
++	return IRQ_HANDLED;
++}
++
++
++
++/* Pulse the GPIO low for /duty/ cycles and then /high/ for 100-duty cycles.
++ * Returns the number of usecs delayed.
++ */
++#define RATE 1
++static int gpio_pulse(int gpio, int duty) {
++	int low;
++	int high;
++
++	if (duty < 0)
++		duty = 0;
++	if (duty > 100)
++		duty = 100;
++	low = duty;
++	high = 100-duty;
++
++	if (raw_gpio)
++		raw_gpio_set(gpio, 0);
++	else
++		gpio_set_value(gpio, 0);
++	udelay(RATE*low);
++
++	if (raw_gpio)
++		raw_gpio_set(gpio, 1);
++	else
++		gpio_set_value(gpio, 1);
++	udelay(RATE*high);
++
++	return (RATE*low)+(RATE*high);
++}
++
++
++
++/* Give an indication that it's safe to turn off the board.  Pulse the LED
++ * in a kind of "breathing" pattern, so the user knows that it's
++ * "powered down".
++ */
++static int do_breathing_forever(int gpio) {
++	int err;
++	err = gpio_request(gpio, "LED light");
++	if (err < 0) {
++		pr_err("Unable to request GPIO, switching to raw access");
++		raw_gpio = 1;
++	}
++	SET_GPIO_OUTPUT(gpio);
++
++	while (1) {
++		int usecs;
++		/* We want four seconds:
++		 *   - One second of ramp-up
++		 *   - One second of ramp-down
++		 *   - Two seconds of low
++		 */
++		for (usecs=0; usecs < 800000; )
++			usecs += gpio_pulse(gpio, ((usecs*9)/80000)+10);
++
++		for (usecs=0; usecs < 800000; )
++			usecs += gpio_pulse(gpio, 100-((usecs*9)/80000));
++
++		for (usecs=0; usecs < 800000; )
++			usecs += gpio_pulse(gpio, 10);
++
++		for (usecs=0; usecs < 800000; )
++			usecs += gpio_pulse(gpio, 10);
++	}
++	return 0;
++}
++
++
++
++/* Our shutdown function.  Execution will stay here until the switch is
++ * flipped.
++ * NOTE: The default power_off function sends a message to the GPU via
++ * a mailbox message to shut down most parts of the core.  Since we don't
++ * have any documentation on the mailbox message formats, we will leave
++ * the CPU powered up here but not executing any code in order to simulate
++ * an "off" state.
++ */
++static void rpi_power_switch_power_off(void) {
++	int ret;
++	pr_info("Waiting for the switch to be flipped back...\n");
++	if (mode == MODE_SWITCH)
++		gpio_pol = !gpio_pol;
++	ret = request_irq(gpio_to_irq(gpio_pin), reboot_isr,
++			  gpio_pol?IRQF_TRIGGER_RISING:IRQF_TRIGGER_FALLING,
++			  "Reboot ISR", NULL);
++
++	/* If it's taken us so long to reboot that the switch was flipped,
++	 * immediately reboot.
++	 */
++	if (gpio_pol == gpio_get_value(gpio_pin))
++		reboot_isr(0, NULL);
++
++	do_breathing_forever(led_pin);
++	return;
++}
++
++
++static irqreturn_t power_isr(int irqno, void *param) {
++	schedule_delayed_work(&initiate_shutdown_work, msecs_to_jiffies(100));
++	return IRQ_HANDLED;
++}
++
++
++
++/* Sysfs entry */
++
++static ssize_t do_shutdown_show(struct device *d,
++				struct device_attribute *attr, char *buf)
++{
++        ssize_t ret;
++        ret = sprintf(buf, "Write into this file to initiate a shutdown\n");
++        return ret;
++}
++
++static ssize_t do_shutdown_store(struct device *d,
++		struct device_attribute *attr, const char *buf, size_t count)
++{
++	if (mode == MODE_SWITCH)
++		gpio_pol = !gpio_pol;
++	schedule_delayed_work(&initiate_shutdown_work, msecs_to_jiffies(10));
++	return count;
++}
++static DEVICE_ATTR(do_shutdown, 0666, do_shutdown_show, do_shutdown_store);
++
++static struct attribute *rpi_power_switch_sysfs_entries[] = {
++	&dev_attr_do_shutdown.attr,
++	NULL,
++};
++
++static struct attribute_group rpi_power_switch_attribute_group = {
++        .name = NULL,
++        .attrs = rpi_power_switch_sysfs_entries,
++};
++
++static struct class power_switch_class = {
++	.name =		POWER_SWITCH_CLASS_NAME,
++	.owner =	THIS_MODULE,
++};
++
++
++
++
++/* Main module entry point */
++
++int __init rpi_power_switch_init(void)
++{
++	int ret = 0;
++
++	old_pm_power_off = pm_power_off;
++	pm_power_off = rpi_power_switch_power_off;
++
++	pr_info("Adafruit Industries' power switch driver v%s\n",
++		RPI_POWER_SWITCH_VERSION);
++
++	INIT_DELAYED_WORK(&initiate_shutdown_work, initiate_shutdown);
++
++
++	/* Register our own class for the power switch */
++	ret = class_register(&power_switch_class);
++        if (ret < 0) {
++		pr_err("%s: Unable to register class\n", power_switch_class.name);
++		goto out0;     
++	}
++
++
++        /* Create devices for each PWM present */
++	switch_dev = device_create(&power_switch_class, &platform_bus,
++                                MKDEV(0, 0), NULL, "pswitch%u", 0);
++	if (IS_ERR(switch_dev)) {
++		pr_err("%s: device_create failed\n", power_switch_class.name);
++		ret = PTR_ERR(switch_dev);
++		goto out1;
++        }
++
++	ret = sysfs_create_group(&switch_dev->kobj,
++				 &rpi_power_switch_attribute_group);
++	if (ret < 0) {
++		pr_err("%s: create_group failed\n", power_switch_class.name);
++		goto out2;
++	}
++
++	/* GPIO register memory must be mapped before doing any direct
++	 * accesses such as changing GPIO alt functions or changing GPIO
++	 * pull ups or pull downs.
++	 */
++	gpio_reg = ioremap(GPIO_BASE, 1024);
++
++	/* Set the specified pin as a GPIO input */
++	SET_GPIO_INPUT(gpio_pin);
++
++	/* Set the pin as a pulldown.  Most pins should default to having
++	 * pulldowns, and this seems most intuitive.
++	 */
++	set_gpio_pull(gpio_pin, GPIO_PULL_UP);
++
++	gpio_request(gpio_pin, "Power switch");
++	gpio_direction_input(gpio_pin);
++
++	/* The targeted polarity should be the opposite of the current value.
++	 * I.e. we want the pin to transition to this state in order to
++	 * initiate a shutdown.
++	 */
++	gpio_pol = !gpio_get_value(gpio_pin);
++
++	/* Request an interrupt to fire when the pin transitions to our
++	 * desired state.
++	 */
++	ret = request_irq(__gpio_to_irq(gpio_pin), power_isr,
++			  gpio_pol?IRQF_TRIGGER_RISING:IRQF_TRIGGER_FALLING,
++			  "Power button", NULL);
++	if (ret) {
++		pr_err("Unable to request IRQ\n");
++		goto out3;
++	}
++
++	return 0;
++
++
++	/* Error handling */
++out3:
++	sysfs_remove_group(&switch_dev->kobj,&rpi_power_switch_attribute_group);
++out2:
++	device_unregister(switch_dev);
++out1:
++	class_unregister(&power_switch_class);
++out0:
++	iounmap(gpio_reg);
++	pm_power_off = old_pm_power_off;
++	return ret;
++}
++
++
++/* Main module exit point (called at unload) */
++
++void __exit rpi_power_switch_cleanup(void)
++{
++	sysfs_remove_group(&switch_dev->kobj,&rpi_power_switch_attribute_group);
++	device_unregister(switch_dev);
++	free_irq(__gpio_to_irq(gpio_pin), NULL);
++	gpio_free(gpio_pin);
++	pm_power_off = old_pm_power_off;
++	class_unregister(&power_switch_class);
++	iounmap(gpio_reg);
++}
++
++module_init(rpi_power_switch_init);
++module_exit(rpi_power_switch_cleanup);
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Sean Cross <xobs@xoblo.gs> for Adafruit Industries <www.adafruit.com>");
++MODULE_ALIAS("platform:bcm2708_power_switch");
++module_param(gpio_pin, int, 0);
++module_param(led_pin, int, 0);
++module_param(mode, int, 0);
+diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
+index 7b96e5f..ba9c048 100644
+--- a/drivers/video/Kconfig
++++ b/drivers/video/Kconfig
+@@ -23,6 +23,8 @@ source "drivers/gpu/drm/Kconfig"
+ 
+ source "drivers/gpu/stub/Kconfig"
+ 
++source "drivers/video/fbtft/Kconfig"
++
+ config VGASTATE
+        tristate
+        default n
+diff --git a/drivers/video/Makefile b/drivers/video/Makefile
+index 3a7c1f5..6072520 100644
+--- a/drivers/video/Makefile
++++ b/drivers/video/Makefile
+@@ -14,6 +14,7 @@ fb-objs                           := $(fb-y)
+ obj-$(CONFIG_VT)		  += console/
+ obj-$(CONFIG_LOGO)		  += logo/
+ obj-y				  += backlight/
++obj-y				  += fbtft/
+ 
+ obj-$(CONFIG_EXYNOS_VIDEO)     += exynos/
+ 
+diff --git a/drivers/video/fbtft/.gitignore b/drivers/video/fbtft/.gitignore
+new file mode 100644
+index 0000000..451369c
+--- /dev/null
++++ b/drivers/video/fbtft/.gitignore
+@@ -0,0 +1,87 @@
++# This file is copied from the Linux kernel sources
++#
++# NOTE! Don't add files that are generated in specific
++# subdirectories here. Add them in the ".gitignore" file
++# in that subdirectory instead.
++#
++# NOTE! Please use 'git ls-files -i --exclude-standard'
++# command after changing this file, to see if there are
++# any tracked files which get ignored after the change.
++#
++# Normal rules
++#
++.*
++*.o
++*.o.*
++*.a
++*.s
++*.ko
++*.so
++*.so.dbg
++*.mod.c
++*.i
++*.lst
++*.symtypes
++*.order
++modules.builtin
++*.elf
++*.bin
++*.gz
++*.bz2
++*.lzma
++*.xz
++*.lzo
++*.patch
++*.gcno
++
++#
++# Top-level generic files
++#
++/tags
++/TAGS
++/linux
++/vmlinux
++/vmlinuz
++/System.map
++/Module.markers
++/Module.symvers
++
++#
++# Debian directory (make deb-pkg)
++#
++/debian/
++
++#
++# git files that we don't want to ignore even it they are dot-files
++#
++!.gitignore
++!.mailmap
++
++#
++# Generated include files
++#
++include/config
++include/linux/version.h
++include/generated
++arch/*/include/generated
++
++# stgit generated dirs
++patches-*
++
++# quilt's files
++patches
++series
++
++# cscope files
++cscope.*
++ncscope.*
++
++# gnu global files
++GPATH
++GRTAGS
++GSYMS
++GTAGS
++
++*.orig
++*~
++\#*#
+diff --git a/drivers/video/fbtft/Kconfig b/drivers/video/fbtft/Kconfig
+new file mode 100644
+index 0000000..2dec173
+--- /dev/null
++++ b/drivers/video/fbtft/Kconfig
+@@ -0,0 +1,109 @@
++menuconfig FB_TFT
++	tristate "Support for small TFT LCD display modules"
++	depends on FB && SPI && GPIOLIB
++	select FB_SYS_FILLRECT
++	select FB_SYS_COPYAREA
++	select FB_SYS_IMAGEBLIT
++	select FB_SYS_FOPS
++	select FB_DEFERRED_IO
++	select FB_BACKLIGHT
++
++config FB_TFT_HX8340BN
++	tristate "FB driver for the HX8340BN LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for HX8340BN
++
++config FB_TFT_HX8347D
++	tristate "FB driver for the HX8347D LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for HX8347D
++
++config FB_TFT_ILI9320
++	tristate "FB driver for the ILI9320 LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for ILI9320
++
++config FB_TFT_ILI9325
++	tristate "FB driver for the ILI9325 LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for ILI9325
++
++config FB_TFT_ILI9340
++	tristate "FB driver for the ILI9340 LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for ILI9340
++
++config FB_TFT_ILI9341
++	tristate "FB driver for the ILI9341 LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for ILI9341
++
++config FB_TFT_PCD8544
++	tristate "FB driver for the PCD8544 LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for PCD8544
++
++config FB_TFT_S6D1121
++	tristate "FB driver for the S6D1211 LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for S6D1121
++
++config FB_TFT_SSD1289
++	tristate "FB driver for the SSD1289 LCD Controller"
++	depends on FB_TFT
++	help
++	  Framebuffer support for SSD1289
++
++config FB_TFT_SSD1306
++	tristate "FB driver for the SSD1306 OLED Controller"
++	depends on FB_TFT
++	help
++	  Framebuffer support for SSD1306
++
++config FB_TFT_SSD1331
++	tristate "FB driver for the SSD1331 LCD Controller"
++	depends on FB_TFT
++	help
++	  Framebuffer support for SSD1331
++
++config FB_TFT_SSD1351
++	tristate "FB driver for the SSD1351 LCD Controller"
++	depends on FB_TFT
++	help
++	  Framebuffer support for SSD1351
++
++config FB_TFT_ST7735R
++	tristate "FB driver for the ST7735R LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for ST7735R
++
++config FB_TFT_TINYLCD
++	tristate "FB driver for tinylcd.com display"
++	depends on FB_TFT
++	help
++	  Custom Framebuffer support for tinylcd.com display
++
++config FB_TFT_WATTEROTT
++	tristate "FB driver for the WATTEROTT LCD Controller"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for WATTEROTT
++
++config FB_FLEX
++	tristate "Generic FB driver for TFT LCD displays"
++	depends on FB_TFT
++	help
++	  Generic Framebuffer support for TFT LCD displays.
++
++config FB_TFT_FBTFT_DEVICE
++	tristate "Module to for adding FBTFT devices"
++	depends on FB_TFT
+diff --git a/drivers/video/fbtft/Makefile b/drivers/video/fbtft/Makefile
+new file mode 100644
+index 0000000..168db1b
+--- /dev/null
++++ b/drivers/video/fbtft/Makefile
+@@ -0,0 +1,24 @@
++# Core module
++obj-$(CONFIG_FB_TFT)             += fbtft.o
++fbtft-y                          += fbtft-core.o fbtft-sysfs.o fbtft-bus.o fbtft-io.o
++
++# drivers
++obj-$(CONFIG_FB_TFT_HX8340BN)    += fb_hx8340bn.o
++obj-$(CONFIG_FB_TFT_HX8347D)     += fb_hx8347d.o
++obj-$(CONFIG_FB_TFT_ILI9320)     += fb_ili9320.o
++obj-$(CONFIG_FB_TFT_ILI9325)     += fb_ili9325.o
++obj-$(CONFIG_FB_TFT_ILI9340)     += fb_ili9340.o
++obj-$(CONFIG_FB_TFT_ILI9341)     += fb_ili9341.o
++obj-$(CONFIG_FB_TFT_PCD8544)     += fb_pcd8544.o
++obj-$(CONFIG_FB_TFT_S6D1121)     += fb_s6d1121.o
++obj-$(CONFIG_FB_TFT_SSD1289)     += fb_ssd1289.o
++obj-$(CONFIG_FB_TFT_SSD1306)     += fb_ssd1306.o
++obj-$(CONFIG_FB_TFT_SSD1331)     += fb_ssd1331.o
++obj-$(CONFIG_FB_TFT_SSD1351)     += fb_ssd1351.o
++obj-$(CONFIG_FB_TFT_ST7735R)     += fb_st7735r.o
++obj-$(CONFIG_FB_TFT_TINYLCD)     += fb_tinylcd.o
++obj-$(CONFIG_FB_TFT_WATTEROTT)   += fb_watterott.o
++obj-$(CONFIG_FB_FLEX)            += flexfb.o
++
++# Device modules
++obj-$(CONFIG_FB_TFT_FBTFT_DEVICE) += fbtft_device.o
+diff --git a/drivers/video/fbtft/README b/drivers/video/fbtft/README
+new file mode 100644
+index 0000000..1641273
+--- /dev/null
++++ b/drivers/video/fbtft/README
+@@ -0,0 +1,24 @@
++  FBTFT
++=========
++
++Linux Framebuffer drivers for small TFT LCD display modules.
++The module 'fbft' makes writing drivers for some of these displays very easy.
++
++Development is done on a Raspberry Pi running the Raspbian "wheezy" distribution.
++
++INSTALLATION
++  Download kernel sources
++  
++  cd drivers/video
++  git clone https://github.com/notro/fbtft.git
++  
++  Add to drivers/video/Kconfig:   source "drivers/video/fbtft/Kconfig"
++  Add to drivers/video/Makefile:  obj-y += fbtft/
++  
++  Enable driver(s) in menuconfig and build the kernel
++
++
++See wiki for more information: https://github.com/notro/fbtft/wiki
++
++
++Source: https://github.com/notro/fbtft/
+diff --git a/drivers/video/fbtft/fb_hx8340bn.c b/drivers/video/fbtft/fb_hx8340bn.c
+new file mode 100644
+index 0000000..ba5ead8
+--- /dev/null
++++ b/drivers/video/fbtft/fb_hx8340bn.c
+@@ -0,0 +1,227 @@
++/*
++ * FB driver for the HX8340BN LCD Controller
++ *
++ * This display uses 9-bit SPI: Data/Command bit + 8 data bits
++ * For platforms that doesn't support 9-bit, the driver is capable
++ * of emulating this using 8-bit transfer.
++ * This is done by transfering eight 9-bit words in 9 bytes.
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/vmalloc.h>
++#include <linux/spi/spi.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_hx8340bn"
++#define WIDTH		176
++#define HEIGHT		220
++#define TXBUFLEN	(4 * PAGE_SIZE)
++#define DEFAULT_GAMMA	"1 3 0E 5 0 2 09 0 6 1 7 1 0 2 2\n" \
++			"3 3 17 8 4 7 05 7 6 0 3 1 6 0 0 "
++
++
++static bool emulate;
++module_param(emulate, bool, 0);
++MODULE_PARM_DESC(emulate, "Force emulation in 9-bit mode");
++
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	/* BTL221722-276L startup sequence, from datasheet */
++
++	/* SETEXTCOM: Set extended command set (C1h)
++	   This command is used to set extended command set access enable.
++	   Enable: After command (C1h), must write: ffh,83h,40h */
++	write_reg(par, 0xC1, 0xFF, 0x83, 0x40);
++
++	/* Sleep out
++	   This command turns off sleep mode.
++	   In this mode the DC/DC converter is enabled, Internal oscillator
++	   is started, and panel scanning is started. */
++	write_reg(par, 0x11);
++	mdelay(150);
++
++	/* Undoc'd register? */
++	write_reg(par, 0xCA, 0x70, 0x00, 0xD9);
++
++	/* SETOSC: Set Internal Oscillator (B0h)
++	   This command is used to set internal oscillator related settings */
++	/*	OSC_EN: Enable internal oscillator */
++	/*	Internal oscillator frequency: 125% x 2.52MHz */
++	write_reg(par, 0xB0, 0x01, 0x11);
++
++	/* Drive ability setting */
++	write_reg(par, 0xC9, 0x90, 0x49, 0x10, 0x28, 0x28, 0x10, 0x00, 0x06);
++	mdelay(20);
++
++	/* SETPWCTR5: Set Power Control 5(B5h)
++	   This command is used to set VCOM Low and VCOM High Voltage */
++	/* VCOMH 0110101 :  3.925 */
++	/* VCOML 0100000 : -1.700 */
++	/* 45h=69  VCOMH: "VMH" + 5d   VCOML: "VMH" + 5d */
++	write_reg(par, 0xB5, 0x35, 0x20, 0x45);
++
++	/* SETPWCTR4: Set Power Control 4(B4h)
++		VRH[4:0]:	Specify the VREG1 voltage adjusting.
++				VREG1 voltage is for gamma voltage setting.
++		BT[2:0]:	Switch the output factor of step-up circuit 2
++				for VGH and VGL voltage generation. */
++	write_reg(par, 0xB4, 0x33, 0x25, 0x4C);
++	mdelay(10);
++
++	/* Interface Pixel Format (3Ah)
++	   This command is used to define the format of RGB picture data,
++	   which is to be transfer via the system and RGB interface. */
++	/* RGB interface: 16 Bit/Pixel	*/
++	write_reg(par, 0x3A, 0x05);
++
++	/* Display on (29h)
++	   This command is used to recover from DISPLAY OFF mode.
++	   Output from the Frame Memory is enabled. */
++	write_reg(par, 0x29);
++	mdelay(10);
++
++	return 0;
++}
++
++void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	write_reg(par, FBTFT_CASET, 0x00, xs, 0x00, xe);
++	write_reg(par, FBTFT_RASET, 0x00, ys, 0x00, ye);
++	write_reg(par, FBTFT_RAMWR);
++}
++
++static int set_var(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* MADCTL - Memory data access control */
++	/* RGB/BGR can be set with H/W pin SRGB and MADCTL BGR bit */
++#define MY (1 << 7)
++#define MX (1 << 6)
++#define MV (1 << 5)
++	switch (par->info->var.rotate) {
++	case 0:
++		write_reg(par, 0x36, (par->bgr << 3));
++		break;
++	case 270:
++		write_reg(par, 0x36, MX | MV | (par->bgr << 3));
++		break;
++	case 180:
++		write_reg(par, 0x36, MX | MY | (par->bgr << 3));
++		break;
++	case 90:
++		write_reg(par, 0x36, MY | MV | (par->bgr << 3));
++		break;
++	}
++
++	return 0;
++}
++
++/*
++  Gamma Curve selection, GC (only GC0 can be customized):
++    0 = 2.2, 1 = 1.8, 2 = 2.5, 3 = 1.0
++  Gamma string format:
++    OP0 OP1 CP0 CP1 CP2 CP3 CP4 MP0 MP1 MP2 MP3 MP4 MP5 CGM0 CGM1
++    ON0 ON1 CN0 CN1 CN2 CN3 CN4 MN0 MN1 MN2 MN3 MN4 MN5 XXXX  GC
++*/
++#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	unsigned long mask[] = {
++		0b1111, 0b1111, 0b11111, 0b1111, 0b1111, 0b1111, 0b11111,
++		0b111, 0b111, 0b111, 0b111, 0b111, 0b111, 0b11, 0b11,
++		0b1111, 0b1111, 0b11111, 0b1111, 0b1111, 0b1111, 0b11111,
++		0b111, 0b111, 0b111, 0b111, 0b111, 0b111, 0b0, 0b0 };
++	int i, j;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* apply mask */
++	for (i = 0; i < par->gamma.num_curves; i++)
++		for (j = 0; j < par->gamma.num_values; j++)
++			CURVE(i, j) &= mask[i * par->gamma.num_values + j];
++
++	write_reg(par, 0x26, 1 << CURVE(1, 14)); /* Gamma Set (26h) */
++
++	if (CURVE(1, 14))
++		return 0; /* only GC0 can be customized */
++
++	write_reg(par, 0xC2,
++		(CURVE(0, 8) << 4) | CURVE(0, 7),
++		(CURVE(0, 10) << 4) | CURVE(0, 9),
++		(CURVE(0, 12) << 4) | CURVE(0, 11),
++		CURVE(0, 2),
++		(CURVE(0, 4) << 4) | CURVE(0, 3),
++		CURVE(0, 5),
++		CURVE(0, 6),
++		(CURVE(0, 1) << 4) | CURVE(0, 0),
++		(CURVE(0, 14) << 2) | CURVE(0, 13));
++
++	write_reg(par, 0xC3,
++		(CURVE(1, 8) << 4) | CURVE(1, 7),
++		(CURVE(1, 10) << 4) | CURVE(1, 9),
++		(CURVE(1, 12) << 4) | CURVE(1, 11),
++		CURVE(1, 2),
++		(CURVE(1, 4) << 4) | CURVE(1, 3),
++		CURVE(1, 5),
++		CURVE(1, 6),
++		(CURVE(1, 1) << 4) | CURVE(1, 0));
++
++	mdelay(10);
++
++	return 0;
++}
++#undef CURVE
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.txbuflen = TXBUFLEN,
++	.gamma_num = 2,
++	.gamma_len = 15,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++		.set_gamma = set_gamma,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the HX8340BN LCD Controller");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_hx8347d.c b/drivers/video/fbtft/fb_hx8347d.c
+new file mode 100644
+index 0000000..a71c12f
+--- /dev/null
++++ b/drivers/video/fbtft/fb_hx8347d.c
+@@ -0,0 +1,179 @@
++/*
++ * FB driver for the HX8347D LCD Controller
++ *
++ * Copyright (C) 2013 Christian Vogelgsang
++ *
++ * Based on driver code found here: https://github.com/watterott/r61505u-Adapter
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_hx8347d"
++#define WIDTH		320
++#define HEIGHT		240
++#define DEFAULT_GAMMA	"0 0 0 0 0 0 0 0 0 0 0 0 0 0\n" \
++			"0 0 0 0 0 0 0 0 0 0 0 0 0 0"
++
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	/* driving ability */
++	write_reg(par, 0xEA, 0x00);
++	write_reg(par, 0xEB, 0x20);
++	write_reg(par, 0xEC, 0x0C);
++	write_reg(par, 0xED, 0xC4);
++	write_reg(par, 0xE8, 0x40);
++	write_reg(par, 0xE9, 0x38);
++	write_reg(par, 0xF1, 0x01);
++	write_reg(par, 0xF2, 0x10);
++	write_reg(par, 0x27, 0xA3);
++
++	/* power voltage */
++	write_reg(par, 0x1B, 0x1B);
++	write_reg(par, 0x1A, 0x01);
++	write_reg(par, 0x24, 0x2F);
++	write_reg(par, 0x25, 0x57);
++
++	/* VCOM offset */
++	write_reg(par, 0x23, 0x8D); /* for flicker adjust */
++
++	/* power on */
++	write_reg(par, 0x18, 0x36);
++	write_reg(par, 0x19, 0x01); /* start osc */
++	write_reg(par, 0x01, 0x00); /* wakeup */
++	write_reg(par, 0x1F, 0x88);
++	mdelay(5);
++	write_reg(par, 0x1F, 0x80);
++	mdelay(5);
++	write_reg(par, 0x1F, 0x90);
++	mdelay(5);
++	write_reg(par, 0x1F, 0xD0);
++	mdelay(5);
++
++	/* color selection */
++	write_reg(par, 0x17, 0x05); /* 65k */
++
++	/*panel characteristic */
++	write_reg(par, 0x36, 0x00);
++
++	/*display on */
++	write_reg(par, 0x28, 0x38);
++	mdelay(40);
++	write_reg(par, 0x28, 0x3C);
++
++	/* orientation */
++	write_reg(par, 0x16, 0x60 | (par->bgr << 3));
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	write_reg(par, 0x02, (xs >> 8) & 0xFF);
++	write_reg(par, 0x03, xs & 0xFF);
++	write_reg(par, 0x04, (xe >> 8) & 0xFF);
++	write_reg(par, 0x05, xe & 0xFF);
++	write_reg(par, 0x06, (ys >> 8) & 0xFF);
++	write_reg(par, 0x07, ys & 0xFF);
++	write_reg(par, 0x08, (ye >> 8) & 0xFF);
++	write_reg(par, 0x09, ye & 0xFF);
++	write_reg(par, 0x22);
++}
++
++/*
++  Gamma string format:
++    VRP0 VRP1 VRP2 VRP3 VRP4 VRP5 PRP0 PRP1 PKP0 PKP1 PKP2 PKP3 PKP4 CGM
++    VRN0 VRN1 VRN2 VRN3 VRN4 VRN5 PRN0 PRN1 PKN0 PKN1 PKN2 PKN3 PKN4 CGM
++*/
++#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	unsigned long mask[] = {
++		0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,
++		0b1111111, 0b1111111,
++		0b11111, 0b11111, 0b11111, 0b11111, 0b11111,
++		0b1111};
++	int i, j;
++	int acc = 0;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* apply mask */
++	for (i = 0; i < par->gamma.num_curves; i++)
++		for (j = 0; j < par->gamma.num_values; j++) {
++			acc += CURVE(i, j);
++			CURVE(i, j) &= mask[j];
++		}
++
++	if (acc == 0) /* skip if all values are zero */
++		return 0;
++
++	for (i = 0; i < par->gamma.num_curves; i++) {
++		write_reg(par, 0x40 + (i * 0x10), CURVE(i, 0));
++		write_reg(par, 0x41 + (i * 0x10), CURVE(i, 1));
++		write_reg(par, 0x42 + (i * 0x10), CURVE(i, 2));
++		write_reg(par, 0x43 + (i * 0x10), CURVE(i, 3));
++		write_reg(par, 0x44 + (i * 0x10), CURVE(i, 4));
++		write_reg(par, 0x45 + (i * 0x10), CURVE(i, 5));
++		write_reg(par, 0x46 + (i * 0x10), CURVE(i, 6));
++		write_reg(par, 0x47 + (i * 0x10), CURVE(i, 7));
++		write_reg(par, 0x48 + (i * 0x10), CURVE(i, 8));
++		write_reg(par, 0x49 + (i * 0x10), CURVE(i, 9));
++		write_reg(par, 0x4A + (i * 0x10), CURVE(i, 10));
++		write_reg(par, 0x4B + (i * 0x10), CURVE(i, 11));
++		write_reg(par, 0x4C + (i * 0x10), CURVE(i, 12));
++	}
++	write_reg(par, 0x5D, (CURVE(1, 0) << 4) | CURVE(0, 0));
++
++	return 0;
++}
++#undef CURVE
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.gamma_num = 2,
++	.gamma_len = 14,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_gamma = set_gamma,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the HX8347D LCD Controller");
++MODULE_AUTHOR("Christian Vogelgsang");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_ili9320.c b/drivers/video/fbtft/fb_ili9320.c
+new file mode 100644
+index 0000000..48b7a13
+--- /dev/null
++++ b/drivers/video/fbtft/fb_ili9320.c
+@@ -0,0 +1,232 @@
++/*
++ * FB driver for the ILI9320 LCD Controller
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++#include <linux/spi/spi.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_ili9320"
++#define WIDTH		240
++#define HEIGHT		320
++#define DEFAULT_GAMMA	"07 07 6 0 0 0 5 5 4 0\n" \
++			"07 08 4 7 5 1 2 0 7 7"
++
++
++static unsigned read_devicecode(struct fbtft_par *par)
++{
++	int ret;
++	u8 rxbuf[8] = {0, };
++
++	write_reg(par, 0x0000);
++	ret = par->fbtftops.read(par, rxbuf, 4);
++	return (rxbuf[2] << 8) | rxbuf[3];
++}
++
++static int init_display(struct fbtft_par *par)
++{
++	unsigned devcode;
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	devcode = read_devicecode(par);
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "Device code: 0x%04X\n",
++		devcode);
++	if ((devcode != 0x0000) && (devcode != 0x9320))
++		dev_warn(par->info->device,
++			"Unrecognized Device code: 0x%04X (expected 0x9320)\n",
++			devcode);
++
++	/* Initialization sequence from ILI9320 Application Notes */
++
++	/* *********** Start Initial Sequence ********* */
++	write_reg(par, 0x00E5, 0x8000); /* Set the Vcore voltage and this setting is must. */
++	write_reg(par, 0x0000, 0x0001); /* Start internal OSC. */
++	write_reg(par, 0x0001, 0x0100); /* set SS and SM bit */
++	write_reg(par, 0x0002, 0x0700); /* set 1 line inversion */
++	write_reg(par, 0x0004, 0x0000); /* Resize register */
++	write_reg(par, 0x0008, 0x0202); /* set the back and front porch */
++	write_reg(par, 0x0009, 0x0000); /* set non-display area refresh cycle */
++	write_reg(par, 0x000A, 0x0000); /* FMARK function */
++	write_reg(par, 0x000C, 0x0000); /* RGB interface setting */
++	write_reg(par, 0x000D, 0x0000); /* Frame marker Position */
++	write_reg(par, 0x000F, 0x0000); /* RGB interface polarity */
++
++	/* ***********Power On sequence *************** */
++	write_reg(par, 0x0010, 0x0000); /* SAP, BT[3:0], AP, DSTB, SLP, STB */
++	write_reg(par, 0x0011, 0x0007); /* DC1[2:0], DC0[2:0], VC[2:0] */
++	write_reg(par, 0x0012, 0x0000); /* VREG1OUT voltage */
++	write_reg(par, 0x0013, 0x0000); /* VDV[4:0] for VCOM amplitude */
++	mdelay(200); /* Dis-charge capacitor power voltage */
++	write_reg(par, 0x0010, 0x17B0); /* SAP, BT[3:0], AP, DSTB, SLP, STB */
++	write_reg(par, 0x0011, 0x0031); /* R11h=0x0031 at VCI=3.3V DC1[2:0], DC0[2:0], VC[2:0] */
++	mdelay(50);
++	write_reg(par, 0x0012, 0x0138); /* R12h=0x0138 at VCI=3.3V VREG1OUT voltage */
++	mdelay(50);
++	write_reg(par, 0x0013, 0x1800); /* R13h=0x1800 at VCI=3.3V VDV[4:0] for VCOM amplitude */
++	write_reg(par, 0x0029, 0x0008); /* R29h=0x0008 at VCI=3.3V VCM[4:0] for VCOMH */
++	mdelay(50);
++	write_reg(par, 0x0020, 0x0000); /* GRAM horizontal Address */
++	write_reg(par, 0x0021, 0x0000); /* GRAM Vertical Address */
++
++	/* ------------------ Set GRAM area --------------- */
++	write_reg(par, 0x0050, 0x0000); /* Horizontal GRAM Start Address */
++	write_reg(par, 0x0051, 0x00EF); /* Horizontal GRAM End Address */
++	write_reg(par, 0x0052, 0x0000); /* Vertical GRAM Start Address */
++	write_reg(par, 0x0053, 0x013F); /* Vertical GRAM Start Address */
++	write_reg(par, 0x0060, 0x2700); /* Gate Scan Line */
++	write_reg(par, 0x0061, 0x0001); /* NDL,VLE, REV */
++	write_reg(par, 0x006A, 0x0000); /* set scrolling line */
++
++	/* -------------- Partial Display Control --------- */
++	write_reg(par, 0x0080, 0x0000);
++	write_reg(par, 0x0081, 0x0000);
++	write_reg(par, 0x0082, 0x0000);
++	write_reg(par, 0x0083, 0x0000);
++	write_reg(par, 0x0084, 0x0000);
++	write_reg(par, 0x0085, 0x0000);
++
++	/* -------------- Panel Control ------------------- */
++	write_reg(par, 0x0090, 0x0010);
++	write_reg(par, 0x0092, 0x0000);
++	write_reg(par, 0x0093, 0x0003);
++	write_reg(par, 0x0095, 0x0110);
++	write_reg(par, 0x0097, 0x0000);
++	write_reg(par, 0x0098, 0x0000);
++	write_reg(par, 0x0007, 0x0173); /* 262K color and display ON */
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	switch (par->info->var.rotate) {
++	/* R20h = Horizontal GRAM Start Address */
++	/* R21h = Vertical GRAM Start Address */
++	case 0:
++		write_reg(par, 0x0020, xs);
++		write_reg(par, 0x0021, ys);
++		break;
++	case 180:
++		write_reg(par, 0x0020, WIDTH - 1 - xs);
++		write_reg(par, 0x0021, HEIGHT - 1 - ys);
++		break;
++	case 270:
++		write_reg(par, 0x0020, WIDTH - 1 - ys);
++		write_reg(par, 0x0021, xs);
++		break;
++	case 90:
++		write_reg(par, 0x0020, ys);
++		write_reg(par, 0x0021, HEIGHT - 1 - xs);
++		break;
++	}
++	write_reg(par, 0x0022); /* Write Data to GRAM */
++}
++
++static int set_var(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	switch (par->info->var.rotate) {
++	case 0:
++		write_reg(par, 0x3, (par->bgr << 12) | 0x30);
++		break;
++	case 270:
++		write_reg(par, 0x3, (par->bgr << 12) | 0x28);
++		break;
++	case 180:
++		write_reg(par, 0x3, (par->bgr << 12) | 0x00);
++		break;
++	case 90:
++		write_reg(par, 0x3, (par->bgr << 12) | 0x18);
++		break;
++	}
++	return 0;
++}
++
++/*
++  Gamma string format:
++    VRP0 VRP1 RP0 RP1 KP0 KP1 KP2 KP3 KP4 KP5
++    VRN0 VRN1 RN0 RN1 KN0 KN1 KN2 KN3 KN4 KN5
++*/
++#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	unsigned long mask[] = {
++		0b11111, 0b11111, 0b111, 0b111, 0b111,
++		0b111, 0b111, 0b111, 0b111, 0b111,
++		0b11111, 0b11111, 0b111, 0b111, 0b111,
++		0b111, 0b111, 0b111, 0b111, 0b111 };
++	int i, j;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* apply mask */
++	for (i = 0; i < 2; i++)
++		for (j = 0; j < 10; j++)
++			CURVE(i, j) &= mask[i*par->gamma.num_values + j];
++
++	write_reg(par, 0x0030, CURVE(0, 5) << 8 | CURVE(0, 4));
++	write_reg(par, 0x0031, CURVE(0, 7) << 8 | CURVE(0, 6));
++	write_reg(par, 0x0032, CURVE(0, 9) << 8 | CURVE(0, 8));
++	write_reg(par, 0x0035, CURVE(0, 3) << 8 | CURVE(0, 2));
++	write_reg(par, 0x0036, CURVE(0, 1) << 8 | CURVE(0, 0));
++
++	write_reg(par, 0x0037, CURVE(1, 5) << 8 | CURVE(1, 4));
++	write_reg(par, 0x0038, CURVE(1, 7) << 8 | CURVE(1, 6));
++	write_reg(par, 0x0039, CURVE(1, 9) << 8 | CURVE(1, 8));
++	write_reg(par, 0x003C, CURVE(1, 3) << 8 | CURVE(1, 2));
++	write_reg(par, 0x003D, CURVE(1, 1) << 8 | CURVE(1, 0));
++
++	return 0;
++}
++#undef CURVE
++
++
++static struct fbtft_display display = {
++	.regwidth = 16,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.gamma_num = 2,
++	.gamma_len = 10,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++		.set_gamma = set_gamma,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the ILI9320 LCD Controller");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_ili9325.c b/drivers/video/fbtft/fb_ili9325.c
+new file mode 100644
+index 0000000..9ef0677
+--- /dev/null
++++ b/drivers/video/fbtft/fb_ili9325.c
+@@ -0,0 +1,289 @@
++/*
++ * FB driver for the ILI9325 LCD Controller
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * Based on ili9325.c by Jeroen Domburg
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_ili9325"
++#define WIDTH		240
++#define HEIGHT		320
++#define BPP		16
++#define FPS		20
++#define DEFAULT_GAMMA	"0F 00 7 2 0 0 6 5 4 1\n" \
++			"04 16 2 7 6 3 2 1 7 7"
++
++
++static unsigned bt = 6; /* VGL=Vci*4 , VGH=Vci*4 */
++module_param(bt, uint, 0);
++MODULE_PARM_DESC(bt, "Sets the factor used in the step-up circuits");
++
++static unsigned vc = 0b011; /* Vci1=Vci*0.80 */
++module_param(vc, uint, 0);
++MODULE_PARM_DESC(vc,
++"Sets the ratio factor of Vci to generate the reference voltages Vci1");
++
++static unsigned vrh = 0b1101; /* VREG1OUT=Vci*1.85 */
++module_param(vrh, uint, 0);
++MODULE_PARM_DESC(vrh,
++"Set the amplifying rate (1.6 ~ 1.9) of Vci applied to output the VREG1OUT");
++
++static unsigned vdv = 0b10010; /* VCOMH amplitude=VREG1OUT*0.98 */
++module_param(vdv, uint, 0);
++MODULE_PARM_DESC(vdv,
++"Select the factor of VREG1OUT to set the amplitude of Vcom");
++
++static unsigned vcm = 0b001010; /* VCOMH=VREG1OUT*0.735 */
++module_param(vcm, uint, 0);
++MODULE_PARM_DESC(vcm, "Set the internal VcomH voltage");
++
++
++/*
++Verify that this configuration is within the Voltage limits
++
++Display module configuration: Vcc = IOVcc = Vci = 3.3V
++
++ Voltages
++----------
++Vci                                =   3.3
++Vci1           =  Vci * 0.80       =   2.64
++DDVDH          =  Vci1 * 2         =   5.28
++VCL            = -Vci1             =  -2.64
++VREG1OUT       =  Vci * 1.85       =   4.88
++VCOMH          =  VREG1OUT * 0.735 =   3.59
++VCOM amplitude =  VREG1OUT * 0.98  =   4.79
++VGH            =  Vci * 4          =  13.2
++VGL            = -Vci * 4          = -13.2
++
++ Limits
++--------
++Power supplies
++1.65 < IOVcc < 3.30   =>  1.65 < 3.3 < 3.30
++2.40 < Vcc   < 3.30   =>  2.40 < 3.3 < 3.30
++2.50 < Vci   < 3.30   =>  2.50 < 3.3 < 3.30
++
++Source/VCOM power supply voltage
++ 4.50 < DDVDH < 6.0   =>  4.50 <  5.28 <  6.0
++-3.0  < VCL   < -2.0  =>  -3.0 < -2.64 < -2.0
++VCI - VCL < 6.0       =>  5.94 < 6.0
++
++Gate driver output voltage
++ 10  < VGH   < 20     =>   10 <  13.2  < 20
++-15  < VGL   < -5     =>  -15 < -13.2  < -5
++VGH - VGL < 32        =>   26.4 < 32
++
++VCOM driver output voltage
++VCOMH - VCOML < 6.0   =>  4.79 < 6.0
++*/
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	if (par->gpio.cs != -1)
++		gpio_set_value(par->gpio.cs, 0);  /* Activate chip */
++
++	bt &= 0b111;
++	vc &= 0b111;
++	vrh &= 0b1111;
++	vdv &= 0b11111;
++	vcm &= 0b111111;
++
++	/* Initialization sequence from ILI9325 Application Notes */
++
++	/* ----------- Start Initial Sequence ----------- */
++	write_reg(par, 0x00E3, 0x3008); /* Set internal timing */
++	write_reg(par, 0x00E7, 0x0012); /* Set internal timing */
++	write_reg(par, 0x00EF, 0x1231); /* Set internal timing */
++	write_reg(par, 0x0001, 0x0100); /* set SS and SM bit */
++	write_reg(par, 0x0002, 0x0700); /* set 1 line inversion */
++	write_reg(par, 0x0004, 0x0000); /* Resize register */
++	write_reg(par, 0x0008, 0x0207); /* set the back porch and front porch */
++	write_reg(par, 0x0009, 0x0000); /* set non-display area refresh cycle */
++	write_reg(par, 0x000A, 0x0000); /* FMARK function */
++	write_reg(par, 0x000C, 0x0000); /* RGB interface setting */
++	write_reg(par, 0x000D, 0x0000); /* Frame marker Position */
++	write_reg(par, 0x000F, 0x0000); /* RGB interface polarity */
++
++	/* ----------- Power On sequence ----------- */
++	write_reg(par, 0x0010, 0x0000); /* SAP, BT[3:0], AP, DSTB, SLP, STB */
++	write_reg(par, 0x0011, 0x0007); /* DC1[2:0], DC0[2:0], VC[2:0] */
++	write_reg(par, 0x0012, 0x0000); /* VREG1OUT voltage */
++	write_reg(par, 0x0013, 0x0000); /* VDV[4:0] for VCOM amplitude */
++	mdelay(200); /* Dis-charge capacitor power voltage */
++	write_reg(par, 0x0010, /* SAP, BT[3:0], AP, DSTB, SLP, STB */
++		(1 << 12) | (bt << 8) | (1 << 7) | (0b001 << 4));
++	write_reg(par, 0x0011, 0x220 | vc); /* DC1[2:0], DC0[2:0], VC[2:0] */
++	mdelay(50); /* Delay 50ms */
++	write_reg(par, 0x0012, vrh); /* Internal reference voltage= Vci; */
++	mdelay(50); /* Delay 50ms */
++	write_reg(par, 0x0013, vdv << 8); /* Set VDV[4:0] for VCOM amplitude */
++	write_reg(par, 0x0029, vcm); /* Set VCM[5:0] for VCOMH */
++	write_reg(par, 0x002B, 0x000C); /* Set Frame Rate */
++	mdelay(50); /* Delay 50ms */
++	write_reg(par, 0x0020, 0x0000); /* GRAM horizontal Address */
++	write_reg(par, 0x0021, 0x0000); /* GRAM Vertical Address */
++
++	/*------------------ Set GRAM area --------------- */
++	write_reg(par, 0x0050, 0x0000); /* Horizontal GRAM Start Address */
++	write_reg(par, 0x0051, 0x00EF); /* Horizontal GRAM End Address */
++	write_reg(par, 0x0052, 0x0000); /* Vertical GRAM Start Address */
++	write_reg(par, 0x0053, 0x013F); /* Vertical GRAM Start Address */
++	write_reg(par, 0x0060, 0xA700); /* Gate Scan Line */
++	write_reg(par, 0x0061, 0x0001); /* NDL,VLE, REV */
++	write_reg(par, 0x006A, 0x0000); /* set scrolling line */
++
++	/*-------------- Partial Display Control --------- */
++	write_reg(par, 0x0080, 0x0000);
++	write_reg(par, 0x0081, 0x0000);
++	write_reg(par, 0x0082, 0x0000);
++	write_reg(par, 0x0083, 0x0000);
++	write_reg(par, 0x0084, 0x0000);
++	write_reg(par, 0x0085, 0x0000);
++
++	/*-------------- Panel Control ------------------- */
++	write_reg(par, 0x0090, 0x0010);
++	write_reg(par, 0x0092, 0x0600);
++	write_reg(par, 0x0007, 0x0133); /* 262K color and display ON */
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++	switch (par->info->var.rotate) {
++	/* R20h = Horizontal GRAM Start Address */
++	/* R21h = Vertical GRAM Start Address */
++	case 0:
++		write_reg(par, 0x0020, xs);
++		write_reg(par, 0x0021, ys);
++		break;
++	case 180:
++		write_reg(par, 0x0020, WIDTH - 1 - xs);
++		write_reg(par, 0x0021, HEIGHT - 1 - ys);
++		break;
++	case 270:
++		write_reg(par, 0x0020, WIDTH - 1 - ys);
++		write_reg(par, 0x0021, xs);
++		break;
++	case 90:
++		write_reg(par, 0x0020, ys);
++		write_reg(par, 0x0021, HEIGHT - 1 - xs);
++		break;
++	}
++	write_reg(par, 0x0022); /* Write Data to GRAM */
++}
++
++static int set_var(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	switch (par->info->var.rotate) {
++	/* AM: GRAM update direction */
++	case 0:
++		write_reg(par, 0x03, 0x0030 | (par->bgr << 12));
++		break;
++	case 180:
++		write_reg(par, 0x03, 0x0000 | (par->bgr << 12));
++		break;
++	case 270:
++		write_reg(par, 0x03, 0x0028 | (par->bgr << 12));
++		break;
++	case 90:
++		write_reg(par, 0x03, 0x0018 | (par->bgr << 12));
++		break;
++	}
++
++	return 0;
++}
++
++/*
++  Gamma string format:
++    VRP0 VRP1 RP0 RP1 KP0 KP1 KP2 KP3 KP4 KP5
++    VRN0 VRN1 RN0 RN1 KN0 KN1 KN2 KN3 KN4 KN5
++*/
++#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	unsigned long mask[] = {
++		0b11111, 0b11111, 0b111, 0b111, 0b111,
++		0b111, 0b111, 0b111, 0b111, 0b111,
++		0b11111, 0b11111, 0b111, 0b111, 0b111,
++		0b111, 0b111, 0b111, 0b111, 0b111 };
++	int i, j;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* apply mask */
++	for (i = 0; i < 2; i++)
++		for (j = 0; j < 10; j++)
++			CURVE(i, j) &= mask[i*par->gamma.num_values + j];
++
++	write_reg(par, 0x0030, CURVE(0, 5) << 8 | CURVE(0, 4));
++	write_reg(par, 0x0031, CURVE(0, 7) << 8 | CURVE(0, 6));
++	write_reg(par, 0x0032, CURVE(0, 9) << 8 | CURVE(0, 8));
++	write_reg(par, 0x0035, CURVE(0, 3) << 8 | CURVE(0, 2));
++	write_reg(par, 0x0036, CURVE(0, 1) << 8 | CURVE(0, 0));
++
++	write_reg(par, 0x0037, CURVE(1, 5) << 8 | CURVE(1, 4));
++	write_reg(par, 0x0038, CURVE(1, 7) << 8 | CURVE(1, 6));
++	write_reg(par, 0x0039, CURVE(1, 9) << 8 | CURVE(1, 8));
++	write_reg(par, 0x003C, CURVE(1, 3) << 8 | CURVE(1, 2));
++	write_reg(par, 0x003D, CURVE(1, 1) << 8 | CURVE(1, 0));
++
++	return 0;
++}
++#undef CURVE
++
++
++static struct fbtft_display display = {
++	.regwidth = 16,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.bpp = BPP,
++	.fps = FPS,
++	.gamma_num = 2,
++	.gamma_len = 10,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++		.set_gamma = set_gamma,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the ILI9325 LCD Controller");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_ili9340.c b/drivers/video/fbtft/fb_ili9340.c
+new file mode 100644
+index 0000000..46d6d54
+--- /dev/null
++++ b/drivers/video/fbtft/fb_ili9340.c
+@@ -0,0 +1,161 @@
++/*
++ * FB driver for the ILI9340 LCD Controller
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_ili9340"
++#define WIDTH		240
++#define HEIGHT		320
++
++
++/* Init sequence taken from: Arduino Library for the Adafruit 2.2" display */
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	write_reg(par, 0xEF, 0x03, 0x80, 0x02);
++	write_reg(par, 0xCF, 0x00 , 0XC1 , 0X30);
++	write_reg(par, 0xED, 0x64 , 0x03 , 0X12 , 0X81);
++	write_reg(par, 0xE8, 0x85 , 0x00 , 0x78);
++	write_reg(par, 0xCB, 0x39 , 0x2C , 0x00 , 0x34 , 0x02);
++	write_reg(par, 0xF7, 0x20);
++	write_reg(par, 0xEA, 0x00 , 0x00);
++
++	/* Power Control 1 */
++	write_reg(par, 0xC0, 0x23);
++
++	/* Power Control 2 */
++	write_reg(par, 0xC1, 0x10);
++
++	/* VCOM Control 1 */
++	write_reg(par, 0xC5, 0x3e, 0x28);
++
++	/* VCOM Control 2 */
++	write_reg(par, 0xC7, 0x86);
++
++	/* COLMOD: Pixel Format Set */
++	/* 16 bits/pixel */
++	write_reg(par, 0x3A, 0x55);
++
++	/* Frame Rate Control */
++	/* Division ratio = fosc, Frame Rate = 79Hz */
++	write_reg(par, 0xB1, 0x00, 0x18);
++
++	/* Display Function Control */
++	write_reg(par, 0xB6, 0x08, 0x82, 0x27);
++
++	/* Gamma Function Disable */
++	write_reg(par, 0xF2, 0x00);
++
++	/* Gamma curve selected  */
++	write_reg(par, 0x26, 0x01);
++
++	/* Positive Gamma Correction */
++	write_reg(par, 0xE0,
++		0x0F, 0x31, 0x2B, 0x0C, 0x0E, 0x08, 0x4E, 0xF1,
++		0x37, 0x07, 0x10, 0x03, 0x0E, 0x09, 0x00);
++
++	/* Negative Gamma Correction */
++	write_reg(par, 0xE1,
++		0x00, 0x0E, 0x14, 0x03, 0x11, 0x07, 0x31, 0xC1,
++		0x48, 0x08, 0x0F, 0x0C, 0x31, 0x36, 0x0F);
++
++	/* Sleep OUT */
++	write_reg(par, 0x11);
++
++	mdelay(120);
++
++	/* Display ON */
++	write_reg(par, 0x29);
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	/* Column address */
++	write_reg(par, 0x2A, xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);
++
++	/* Row adress */
++	write_reg(par, 0x2B, ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);
++
++	/* Memory write */
++	write_reg(par, 0x2C);
++}
++
++#define ILI9340_MADCTL_MV  0x20
++#define ILI9340_MADCTL_MX  0x40
++#define ILI9340_MADCTL_MY  0x80
++static int set_var(struct fbtft_par *par)
++{
++	u8 val;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	switch (par->info->var.rotate) {
++	case 270:
++		val = ILI9340_MADCTL_MV;
++		break;
++	case 180:
++		val = ILI9340_MADCTL_MY;
++		break;
++	case 90:
++		val = ILI9340_MADCTL_MV | ILI9340_MADCTL_MY | ILI9340_MADCTL_MX;
++		break;
++	default:
++		val = ILI9340_MADCTL_MX;
++		break;
++	}
++	/* Memory Access Control  */
++	write_reg(par, 0x36, val | (par->bgr << 3));
++
++	return 0;
++}
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the ILI9340 LCD Controller");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_ili9341.c b/drivers/video/fbtft/fb_ili9341.c
+new file mode 100644
+index 0000000..13ece9a
+--- /dev/null
++++ b/drivers/video/fbtft/fb_ili9341.c
+@@ -0,0 +1,177 @@
++/*
++ * FB driver for the ILI9341 LCD display controller
++ *
++ * This display uses 9-bit SPI: Data/Command bit + 8 data bits
++ * For platforms that doesn't support 9-bit, the driver is capable
++ * of emulating this using 8-bit transfer.
++ * This is done by transfering eight 9-bit words in 9 bytes.
++ *
++ * Copyright (C) 2013 Christian Vogelgsang
++ * Based on adafruit22fb.c by Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_ili9341"
++#define WIDTH		240
++#define HEIGHT		320
++#define TXBUFLEN	(4 * PAGE_SIZE)
++#define DEFAULT_GAMMA	"1F 1A 18 0A 0F 06 45 87 32 0A 07 02 07 05 00\n" \
++			"00 25 27 05 10 09 3A 78 4D 05 18 0D 38 3A 1F"
++
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	/* startup sequence for MI0283QT-9A */
++	write_reg(par, 0x01); /* software reset */
++	mdelay(5);
++	write_reg(par, 0x28); /* display off */
++	/* --------------------------------------------------------- */
++	write_reg(par, 0xCF, 0x00, 0x83, 0x30);
++	write_reg(par, 0xED, 0x64, 0x03, 0x12, 0x81);
++	write_reg(par, 0xE8, 0x85, 0x01, 0x79);
++	write_reg(par, 0xCB, 0x39, 0X2C, 0x00, 0x34, 0x02);
++	write_reg(par, 0xF7, 0x20);
++	write_reg(par, 0xEA, 0x00, 0x00);
++	/* ------------power control-------------------------------- */
++	write_reg(par, 0xC0, 0x26);
++	write_reg(par, 0xC1, 0x11);
++	/* ------------VCOM --------- */
++	write_reg(par, 0xC5, 0x35, 0x3E);
++	write_reg(par, 0xC7, 0xBE);
++	/* ------------memory access control------------------------ */
++	write_reg(par, 0x3A, 0x55); /* 16bit pixel */
++	/* ------------frame rate----------------------------------- */
++	write_reg(par, 0xB1, 0x00, 0x1B);
++	/* ------------Gamma---------------------------------------- */
++	/* write_reg(par, 0xF2, 0x08); */ /* Gamma Function Disable */
++	write_reg(par, 0x26, 0x01);
++	/* ------------display-------------------------------------- */
++	write_reg(par, 0xB7, 0x07); /* entry mode set */
++	write_reg(par, 0xB6, 0x0A, 0x82, 0x27, 0x00);
++	write_reg(par, 0x11); /* sleep out */
++	mdelay(100);
++	write_reg(par, 0x29); /* display on */
++	mdelay(20);
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	/* Column address set */
++	write_reg(par, 0x2A,
++		(xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);
++
++	/* Row adress set */
++	write_reg(par, 0x2B,
++		(ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);
++
++	/* Memory write */
++	write_reg(par, 0x2C);
++}
++
++#define MEM_Y   (7) /* MY row address order */
++#define MEM_X   (6) /* MX column address order */
++#define MEM_V   (5) /* MV row / column exchange */
++#define MEM_L   (4) /* ML vertical refresh order */
++#define MEM_H   (2) /* MH horizontal refresh order */
++#define MEM_BGR (3) /* RGB-BGR Order */
++static int set_var(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	switch (par->info->var.rotate) {
++	case 0:
++		write_reg(par, 0x36, (1 << MEM_X) | (par->bgr << MEM_BGR));
++		break;
++	case 270:
++		write_reg(par, 0x36,
++			(1<<MEM_V) | (1 << MEM_L) | (par->bgr << MEM_BGR));
++		break;
++	case 180:
++		write_reg(par, 0x36, (1 << MEM_Y) | (par->bgr << MEM_BGR));
++		break;
++	case 90:
++		write_reg(par, 0x36, (1 << MEM_Y) | (1 << MEM_X) |
++				     (1 << MEM_V) | (par->bgr << MEM_BGR));
++		break;
++	}
++
++	return 0;
++}
++
++/*
++  Gamma string format:
++    Positive: Par1 Par2 [...] Par15
++    Negative: Par1 Par2 [...] Par15
++*/
++#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	int i;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	for (i = 0; i < par->gamma.num_curves; i++)
++		write_reg(par, 0xE0 + i,
++			CURVE(i, 0), CURVE(i, 1), CURVE(i, 2),
++			CURVE(i, 3), CURVE(i, 4), CURVE(i, 5),
++			CURVE(i, 6), CURVE(i, 7), CURVE(i, 8),
++			CURVE(i, 9), CURVE(i, 10), CURVE(i, 11),
++			CURVE(i, 12), CURVE(i, 13), CURVE(i, 14));
++
++	return 0;
++}
++#undef CURVE
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.txbuflen = TXBUFLEN,
++	.gamma_num = 2,
++	.gamma_len = 15,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++		.set_gamma = set_gamma,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the ILI9341 LCD display controller");
++MODULE_AUTHOR("Christian Vogelgsang");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_pcd8544.c b/drivers/video/fbtft/fb_pcd8544.c
+new file mode 100644
+index 0000000..de02148
+--- /dev/null
++++ b/drivers/video/fbtft/fb_pcd8544.c
+@@ -0,0 +1,176 @@
++/*
++ * FB driver for the PCD8544 LCD Controller
++ *
++ * The display is monochrome and the video memory is RGB565.
++ * Any pixel value except 0 turns the pixel on.
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++#include <linux/spi/spi.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME	       "fb_pcd8544"
++#define WIDTH          84
++#define HEIGHT         48
++#define TXBUFLEN       84*6
++#define DEFAULT_GAMMA  "40" /* gamma is used to control contrast in this driver */
++
++static unsigned tc = 0;
++module_param(tc, uint, 0);
++MODULE_PARM_DESC(tc, "TC[1:0] Temperature coefficient: 0-3 (default: 0)");
++
++static unsigned bs = 4;
++module_param(bs, uint, 0);
++MODULE_PARM_DESC(bs, "BS[2:0] Bias voltage level: 0-7 (default: 4)");
++
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	/* Function set */
++	write_reg(par, 0x21); /* 5:1  1
++	                         2:0  PD - Powerdown control: chip is active
++							 1:0  V  - Entry mode: horizontal addressing
++							 0:1  H  - Extended instruction set control: extended
++						  */
++
++	/* H=1 Temperature control */
++	write_reg(par, 0x04 | (tc & 0x3)); /* 
++	                         2:1  1
++	                         1:x  TC1 - Temperature Coefficient: 0x10
++							 0:x  TC0
++						  */
++
++	/* H=1 Bias system */
++	write_reg(par, 0x10 | (bs & 0x7)); /* 
++	                         4:1  1
++	                         3:0  0
++							 2:x  BS2 - Bias System
++							 1:x  BS1
++							 0:x  BS0
++	                      */
++
++	/* Function set */
++	write_reg(par, 0x22); /* 5:1  1
++	                         2:0  PD - Powerdown control: chip is active
++							 1:1  V  - Entry mode: vertical addressing
++							 0:0  H  - Extended instruction set control: basic
++						  */
++
++	/* H=0 Display control */
++	write_reg(par, 0x08 | 4); /* 
++	                         3:1  1
++	                         2:1  D  - DE: 10=normal mode
++							 1:0  0
++							 0:0  E
++						  */
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, "%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	/* H=0 Set X address of RAM */
++	write_reg(par, 0x80); /* 7:1  1
++	                         6-0: X[6:0] - 0x00
++	                      */
++
++	/* H=0 Set Y address of RAM */
++	write_reg(par, 0x40); /* 7:0  0
++	                         6:1  1
++	                         2-0: Y[2:0] - 0x0
++	                      */
++}
++
++static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
++{
++	u16 *vmem16 = (u16 *)par->info->screen_base;
++	u8 *buf = par->txbuf.buf;
++	int x, y, i;
++	int ret = 0;
++
++	fbtft_par_dbg(DEBUG_WRITE_VMEM, par, "%s()\n", __func__);
++
++	for (x=0;x<84;x++) {
++		for (y=0;y<6;y++) {
++			*buf = 0x00;
++			for (i=0;i<8;i++) {
++				*buf |= (vmem16[(y*8+i)*84+x] ? 1 : 0) << i;
++			}
++			buf++;
++		}
++	}
++
++	/* Write data */
++	gpio_set_value(par->gpio.dc, 1);
++	ret = par->fbtftops.write(par, par->txbuf.buf, 6*84);
++	if (ret < 0)
++		dev_err(par->info->device, "%s: write failed and returned: %d\n", __func__, ret);
++
++	return ret;
++}
++
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* apply mask */
++	curves[0] &= 0x7F;
++
++	write_reg(par, 0x23); /* turn on extended instruction set */
++	write_reg(par, 0x80 | curves[0]);
++	write_reg(par, 0x22); /* turn off extended instruction set */
++
++	return 0;
++}
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.txbuflen = TXBUFLEN,
++	.gamma_num = 1,
++	.gamma_len = 1,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.write_vmem = write_vmem,
++		.set_gamma = set_gamma,
++	},
++	.backlight = 1,
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the PCD8544 LCD Controller");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_s6d1121.c b/drivers/video/fbtft/fb_s6d1121.c
+new file mode 100644
+index 0000000..58d2c18
+--- /dev/null
++++ b/drivers/video/fbtft/fb_s6d1121.c
+@@ -0,0 +1,206 @@
++/*
++ * FB driver for the S6D1121 LCD Controller
++ *
++ * Copyright (C) 2013 Roman Rolinsky
++ *
++ * Based on fb_ili9325.c by Noralf Tronnes
++ * Based on ili9325.c by Jeroen Domburg
++ * Init code from UTFT library by Henning Karlsen
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_s6d1121"
++#define WIDTH		240
++#define HEIGHT		320
++#define BPP		16
++#define FPS		20
++#define DEFAULT_GAMMA	"26 09 24 2C 1F 23 24 25 22 26 25 23 0D 00\n" \
++			"1C 1A 13 1D 0B 11 12 10 13 15 36 19 00 0D"
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	if (par->gpio.cs != -1)
++		gpio_set_value(par->gpio.cs, 0);  /* Activate chip */
++
++	/* Initialization sequence from Lib_UTFT */
++
++	write_reg(par, 0x0011, 0x2004);
++	write_reg(par, 0x0013, 0xCC00);
++	write_reg(par, 0x0015, 0x2600);
++	write_reg(par, 0x0014, 0x252A);
++	write_reg(par, 0x0012, 0x0033);
++	write_reg(par, 0x0013, 0xCC04);
++	write_reg(par, 0x0013, 0xCC06);
++	write_reg(par, 0x0013, 0xCC4F);
++	write_reg(par, 0x0013, 0x674F);
++	write_reg(par, 0x0011, 0x2003);
++	write_reg(par, 0x0016, 0x0007);
++	write_reg(par, 0x0002, 0x0013);
++	write_reg(par, 0x0003, 0x0003);
++	write_reg(par, 0x0001, 0x0127);
++	write_reg(par, 0x0008, 0x0303);
++	write_reg(par, 0x000A, 0x000B);
++	write_reg(par, 0x000B, 0x0003);
++	write_reg(par, 0x000C, 0x0000);
++	write_reg(par, 0x0041, 0x0000);
++	write_reg(par, 0x0050, 0x0000);
++	write_reg(par, 0x0060, 0x0005);
++	write_reg(par, 0x0070, 0x000B);
++	write_reg(par, 0x0071, 0x0000);
++	write_reg(par, 0x0078, 0x0000);
++	write_reg(par, 0x007A, 0x0000);
++	write_reg(par, 0x0079, 0x0007);
++	write_reg(par, 0x0007, 0x0051);
++	write_reg(par, 0x0007, 0x0053);
++	write_reg(par, 0x0079, 0x0000);
++
++	write_reg(par, 0x0022); /* Write Data to GRAM */
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++	switch (par->info->var.rotate) {
++	/* R20h = Horizontal GRAM Start Address */
++	/* R21h = Vertical GRAM Start Address */
++	case 0:
++		write_reg(par, 0x0020, xs);
++		write_reg(par, 0x0021, ys);
++		break;
++	case 180:
++		write_reg(par, 0x0020, WIDTH - 1 - xs);
++		write_reg(par, 0x0021, HEIGHT - 1 - ys);
++		break;
++	case 270:
++		write_reg(par, 0x0020, WIDTH - 1 - ys);
++		write_reg(par, 0x0021, xs);
++		break;
++	case 90:
++		write_reg(par, 0x0020, ys);
++		write_reg(par, 0x0021, HEIGHT - 1 - xs);
++		break;
++	}
++	write_reg(par, 0x0022); /* Write Data to GRAM */
++}
++
++static int set_var(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	switch (par->info->var.rotate) {
++	/* AM: GRAM update direction */
++	case 0:
++		write_reg(par, 0x03, 0x0003 | (par->bgr << 12));
++		break;
++	case 180:
++		write_reg(par, 0x03, 0x0000 | (par->bgr << 12));
++		break;
++	case 270:
++		write_reg(par, 0x03, 0x000A | (par->bgr << 12));
++		break;
++	case 90:
++		write_reg(par, 0x03, 0x0009 | (par->bgr << 12));
++		break;
++	}
++
++	return 0;
++}
++
++/*
++  Gamma string format:
++    PKP0 PKP1 PKP2 PKP3 PKP4 PKP5 PKP6 PKP7 PKP8 PKP9 PKP10 PKP11 VRP0 VRP1
++    PKN0 PKN1 PKN2 PKN3 PKN4 PKN5 PKN6 PKN7 PRN8 PRN9 PRN10 PRN11 VRN0 VRN1
++*/
++#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	unsigned long mask[] = {
++		0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 
++		0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,
++		0b11111, 0b11111,
++		0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,
++		0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,
++		0b11111, 0b11111 };
++	int i, j;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* apply mask */
++	for (i = 0; i < 2; i++)
++		for (j = 0; j < 14; j++)
++			CURVE(i, j) &= mask[i*par->gamma.num_values + j];
++
++	write_reg(par, 0x0030, CURVE(0, 1) << 8 | CURVE(0, 0));
++	write_reg(par, 0x0031, CURVE(0, 3) << 8 | CURVE(0, 2));
++	write_reg(par, 0x0032, CURVE(0, 5) << 8 | CURVE(0, 3));
++	write_reg(par, 0x0033, CURVE(0, 7) << 8 | CURVE(0, 6));
++	write_reg(par, 0x0034, CURVE(0, 9) << 8 | CURVE(0, 8));
++	write_reg(par, 0x0035, CURVE(0, 11) << 8 | CURVE(0, 10));
++
++	write_reg(par, 0x0036, CURVE(1, 1) << 8 | CURVE(1, 0));
++	write_reg(par, 0x0037, CURVE(1, 3) << 8 | CURVE(1, 2));
++	write_reg(par, 0x0038, CURVE(1, 5) << 8 | CURVE(1, 4));
++	write_reg(par, 0x0039, CURVE(1, 7) << 8 | CURVE(1, 6));
++	write_reg(par, 0x003A, CURVE(1, 9) << 8 | CURVE(1, 8));
++	write_reg(par, 0x003B, CURVE(1, 11) << 8 | CURVE(1, 10));
++
++	write_reg(par, 0x003C, CURVE(0, 13) << 8 | CURVE(0, 12));
++	write_reg(par, 0x003D, CURVE(1, 13) << 8 | CURVE(1, 12));
++
++	return 0;
++}
++#undef CURVE
++
++
++static struct fbtft_display display = {
++	.regwidth = 16,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.bpp = BPP,
++	.fps = FPS,
++	.gamma_num = 2,
++	.gamma_len = 14,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++		.set_gamma = set_gamma,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the S6D1121 LCD Controller");
++MODULE_AUTHOR("Roman Rolinsky");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_ssd1289.c b/drivers/video/fbtft/fb_ssd1289.c
+new file mode 100644
+index 0000000..4180a66
+--- /dev/null
++++ b/drivers/video/fbtft/fb_ssd1289.c
+@@ -0,0 +1,204 @@
++/*
++ * FB driver for the SSD1289 LCD Controller
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * Init sequence taken from ITDB02_Graph16.cpp - (C)2010-2011 Henning Karlsen
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_ssd1289"
++#define WIDTH		240
++#define HEIGHT		320
++#define DEFAULT_GAMMA	"02 03 2 5 7 7 4 2 4 2\n" \
++			"02 03 2 5 7 5 4 2 4 2"
++
++static unsigned reg11 = 0x6040;
++module_param(reg11, uint, 0);
++MODULE_PARM_DESC(reg11, "Register 11h value");
++
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	if (par->gpio.cs != -1)
++		gpio_set_value(par->gpio.cs, 0);  /* Activate chip */
++
++	write_reg(par, 0x00, 0x0001);
++	write_reg(par, 0x03, 0xA8A4);
++	write_reg(par, 0x0C, 0x0000);
++	write_reg(par, 0x0D, 0x080C);
++	write_reg(par, 0x0E, 0x2B00);
++	write_reg(par, 0x1E, 0x00B7);
++	write_reg(par, 0x01,
++		(1 << 13) | (par->bgr << 11) | (1 << 9) | (HEIGHT - 1));
++	write_reg(par, 0x02, 0x0600);
++	write_reg(par, 0x10, 0x0000);
++	write_reg(par, 0x05, 0x0000);
++	write_reg(par, 0x06, 0x0000);
++	write_reg(par, 0x16, 0xEF1C);
++	write_reg(par, 0x17, 0x0003);
++	write_reg(par, 0x07, 0x0233);
++	write_reg(par, 0x0B, 0x0000);
++	write_reg(par, 0x0F, 0x0000);
++	write_reg(par, 0x41, 0x0000);
++	write_reg(par, 0x42, 0x0000);
++	write_reg(par, 0x48, 0x0000);
++	write_reg(par, 0x49, 0x013F);
++	write_reg(par, 0x4A, 0x0000);
++	write_reg(par, 0x4B, 0x0000);
++	write_reg(par, 0x44, 0xEF00);
++	write_reg(par, 0x45, 0x0000);
++	write_reg(par, 0x46, 0x013F);
++	write_reg(par, 0x23, 0x0000);
++	write_reg(par, 0x24, 0x0000);
++	write_reg(par, 0x25, 0x8000);
++	write_reg(par, 0x4f, 0x0000);
++	write_reg(par, 0x4e, 0x0000);
++	write_reg(par, 0x22);
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	switch (par->info->var.rotate) {
++	/* R4Eh - Set GDDRAM X address counter */
++	/* R4Fh - Set GDDRAM Y address counter */
++	case 0:
++		write_reg(par, 0x4e, xs);
++		write_reg(par, 0x4f, ys);
++		break;
++	case 180:
++		write_reg(par, 0x4e, par->info->var.xres - 1 - xs);
++		write_reg(par, 0x4f, par->info->var.yres - 1 - ys);
++		break;
++	case 270:
++		write_reg(par, 0x4e, par->info->var.yres - 1 - ys);
++		write_reg(par, 0x4f, xs);
++		break;
++	case 90:
++		write_reg(par, 0x4e, ys);
++		write_reg(par, 0x4f, par->info->var.xres - 1 - xs);
++		break;
++	}
++
++	/* R22h - RAM data write */
++	write_reg(par, 0x22);
++}
++
++static int set_var(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	if (par->fbtftops.init_display != init_display) {
++		/* don't risk messing up register 11h */
++		fbtft_par_dbg(DEBUG_INIT_DISPLAY, par,
++			"%s: skipping since custom init_display() is used\n",
++			__func__);
++		return 0;
++	}
++
++	switch (par->info->var.rotate) {
++	case 0:
++		write_reg(par, 0x11, reg11 | 0b110000);
++		break;
++	case 270:
++		write_reg(par, 0x11, reg11 | 0b101000);
++		break;
++	case 180:
++		write_reg(par, 0x11, reg11 | 0b000000);
++		break;
++	case 90:
++		write_reg(par, 0x11, reg11 | 0b011000);
++		break;
++	}
++
++	return 0;
++}
++
++/*
++  Gamma string format:
++    VRP0 VRP1 PRP0 PRP1 PKP0 PKP1 PKP2 PKP3 PKP4 PKP5
++    VRN0 VRN1 PRN0 PRN1 PKN0 PKN1 PKN2 PKN3 PKN4 PKN5
++*/
++#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	unsigned long mask[] = {
++		0b11111, 0b11111, 0b111, 0b111, 0b111,
++		0b111, 0b111, 0b111, 0b111, 0b111,
++		0b11111, 0b11111, 0b111, 0b111, 0b111,
++		0b111, 0b111, 0b111, 0b111, 0b111 };
++	int i, j;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* apply mask */
++	for (i = 0; i < 2; i++)
++		for (j = 0; j < 10; j++)
++			CURVE(i, j) &= mask[i*par->gamma.num_values + j];
++
++	write_reg(par, 0x0030, CURVE(0, 5) << 8 | CURVE(0, 4));
++	write_reg(par, 0x0031, CURVE(0, 7) << 8 | CURVE(0, 6));
++	write_reg(par, 0x0032, CURVE(0, 9) << 8 | CURVE(0, 8));
++	write_reg(par, 0x0033, CURVE(0, 3) << 8 | CURVE(0, 2));
++	write_reg(par, 0x0034, CURVE(1, 5) << 8 | CURVE(1, 4));
++	write_reg(par, 0x0035, CURVE(1, 7) << 8 | CURVE(1, 6));
++	write_reg(par, 0x0036, CURVE(1, 9) << 8 | CURVE(1, 8));
++	write_reg(par, 0x0037, CURVE(1, 3) << 8 | CURVE(1, 2));
++	write_reg(par, 0x003A, CURVE(0, 1) << 8 | CURVE(0, 0));
++	write_reg(par, 0x003B, CURVE(1, 1) << 8 | CURVE(1, 0));
++
++	return 0;
++}
++#undef CURVE
++
++
++static struct fbtft_display display = {
++	.regwidth = 16,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.gamma_num = 2,
++	.gamma_len = 10,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++		.set_gamma = set_gamma,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the SSD1289 LCD Controller");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_ssd1306.c b/drivers/video/fbtft/fb_ssd1306.c
+new file mode 100644
+index 0000000..2661f3e
+--- /dev/null
++++ b/drivers/video/fbtft/fb_ssd1306.c
+@@ -0,0 +1,227 @@
++/*
++ * FB driver for the SSD1306 OLED Controller
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_ssd1306"
++#define WIDTH		128
++#define HEIGHT		64
++
++
++/*
++  write_reg() caveat:
++
++     This doesn't work because D/C has to be LOW for both values:
++       write_reg(par, val1, val2);
++
++     Do it like this:
++       write_reg(par, val1);
++       write_reg(par, val2);
++*/
++
++/* Init sequence taken from the Adafruit SSD1306 Arduino library */
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	if (par->gamma.curves[0] == 0) {
++		mutex_lock(&par->gamma.lock);
++		if (par->info->var.yres == 64)
++			par->gamma.curves[0] = 0xCF;
++		else
++			par->gamma.curves[0] = 0x8F;
++		mutex_unlock(&par->gamma.lock);
++	}
++
++	/* Set Display OFF */
++	write_reg(par, 0xAE);
++
++	/* Set Display Clock Divide Ratio/ Oscillator Frequency */
++	write_reg(par, 0xD5);
++	write_reg(par, 0x80);
++
++	/* Set Multiplex Ratio */
++	write_reg(par, 0xA8);
++	if (par->info->var.yres == 64)
++		write_reg(par, 0x3F);
++	else
++		write_reg(par, 0x1F);
++
++	/* Set Display Offset */
++	write_reg(par, 0xD3);
++	write_reg(par, 0x0);
++
++	/* Set Display Start Line */
++	write_reg(par, 0x40 | 0x0);
++
++	/* Charge Pump Setting */
++	write_reg(par, 0x8D);
++	/* A[2] = 1b, Enable charge pump during display on */
++	write_reg(par, 0x14);
++
++	/* Set Memory Addressing Mode */
++	write_reg(par, 0x20);
++	/* Vertical addressing mode  */
++	write_reg(par, 0x01);
++
++	/*Set Segment Re-map */
++	/* column address 127 is mapped to SEG0 */
++	write_reg(par, 0xA0 | 0x1);
++
++	/* Set COM Output Scan Direction */
++	/* remapped mode. Scan from COM[N-1] to COM0 */
++	write_reg(par, 0xC8);
++
++	/* Set COM Pins Hardware Configuration */
++	write_reg(par, 0xDA);
++	if (par->info->var.yres == 64)
++		/* A[4]=1b, Alternative COM pin configuration */
++		write_reg(par, 0x12);
++	else
++		/* A[4]=0b, Sequential COM pin configuration */
++		write_reg(par, 0x02);
++
++	/* Set Pre-charge Period */
++	write_reg(par, 0xD9);
++	write_reg(par, 0xF1);
++
++	/* Set VCOMH Deselect Level */
++	write_reg(par, 0xDB);
++	/* according to the datasheet, this value is out of bounds */
++	write_reg(par, 0x40);
++
++	/* Entire Display ON */
++	/* Resume to RAM content display. Output follows RAM content */
++	write_reg(par, 0xA4);
++
++	/* Set Normal Display
++	   0 in RAM: OFF in display panel
++	   1 in RAM: ON in display panel */
++	write_reg(par, 0xA6);
++
++	/* Set Display ON */
++	write_reg(par, 0xAF);
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	/* Set Lower Column Start Address for Page Addressing Mode */
++	write_reg(par, 0x00 | 0x0);
++	/* Set Higher Column Start Address for Page Addressing Mode */
++	write_reg(par, 0x10 | 0x0);
++	/* Set Display Start Line */
++	write_reg(par, 0x40 | 0x0);
++}
++
++static int blank(struct fbtft_par *par, bool on)
++{
++	fbtft_par_dbg(DEBUG_BLANK, par, "%s(blank=%s)\n",
++		__func__, on ? "true" : "false");
++
++	if (on)
++		write_reg(par, 0xAE);
++	else
++		write_reg(par, 0xAF);
++	return 0;
++}
++
++/* Gamma is used to control Contrast */
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* apply mask */
++	curves[0] &= 0xFF;
++
++	/* Set Contrast Control for BANK0 */
++	write_reg(par, 0x81);
++	write_reg(par, curves[0]);
++
++	return 0;
++}
++
++static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
++{
++	u16 *vmem16 = (u16 *)par->info->screen_base;
++	u8 *buf = par->txbuf.buf;
++	int x, y, i;
++	int ret = 0;
++
++	fbtft_par_dbg(DEBUG_WRITE_VMEM, par, "%s()\n", __func__);
++
++	for (x = 0; x < par->info->var.xres; x++) {
++		for (y = 0; y < par->info->var.yres/8; y++) {
++			*buf = 0x00;
++			for (i = 0; i < 8; i++)
++				*buf |= (vmem16[(y*8+i)*par->info->var.xres+x] ? 1 : 0) << i;
++			buf++;
++		}
++	}
++
++	/* Write data */
++	gpio_set_value(par->gpio.dc, 1);
++	ret = par->fbtftops.write(par, par->txbuf.buf,
++				par->info->var.xres*par->info->var.yres/8);
++	if (ret < 0)
++		dev_err(par->info->device,
++			"%s: write failed and returned: %d\n", __func__, ret);
++
++	return ret;
++}
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.gamma_num = 1,
++	.gamma_len = 1,
++	.gamma = "00",
++	.fbtftops = {
++		.write_vmem = write_vmem,
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.blank = blank,
++		.set_gamma = set_gamma,
++	},
++};
++
++
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("SSD1306 OLED Driver");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_ssd1331.c b/drivers/video/fbtft/fb_ssd1331.c
+new file mode 100644
+index 0000000..ea09d87
+--- /dev/null
++++ b/drivers/video/fbtft/fb_ssd1331.c
+@@ -0,0 +1,203 @@
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++#include <linux/spi/spi.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_ssd1331"
++#define WIDTH		96
++#define HEIGHT		64
++#define GAMMA_NUM	1
++#define GAMMA_LEN	63
++#define DEFAULT_GAMMA	"0 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2" \
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	write_reg(par, 0xae); /* Display Off */
++	write_reg(par, 0xa0, 0x70 | (par->bgr << 2)); /* Set Colour Depth */
++	write_reg(par, 0x72); // RGB colour
++	write_reg(par, 0xa1, 0x00); /* Set Display Start Line */
++	write_reg(par, 0xa2, 0x00); /* Set Display Offset */
++	write_reg(par, 0xa4); /* NORMALDISPLAY */
++	write_reg(par, 0xa8, 0x3f); // Set multiplex
++	write_reg(par, 0xad, 0x8e); // Set master
++	// write_reg(par, 0xb0, 0x0b); // Set power mode
++	write_reg(par, 0xb1, 0x31); // Precharge
++	write_reg(par, 0xb3, 0xf0); // Clock div
++	write_reg(par, 0x8a, 0x64); // Precharge A
++	write_reg(par, 0x8b, 0x78); // Precharge B
++	write_reg(par, 0x8c, 0x64); // Precharge C
++	write_reg(par, 0xbb, 0x3a); // Precharge level
++	write_reg(par, 0xbe, 0x3e); // vcomh
++	write_reg(par, 0x87, 0x06); // Master current
++	write_reg(par, 0x81, 0x91); // Contrast A
++	write_reg(par, 0x82, 0x50); // Contrast B
++	write_reg(par, 0x83, 0x7d); // Contrast C
++	write_reg(par, 0xaf); /* Set Sleep Mode Display On */
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	write_reg(par, 0x15, xs, xe);
++	write_reg(par, 0x75, ys, ye);
++}
++
++static void write_reg8_bus8(struct fbtft_par *par, int len, ...)
++{
++	va_list args;
++	int i, ret;
++	u8 *buf = (u8 *)par->buf;
++
++	if (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {
++		va_start(args, len);
++		for (i = 0; i < len; i++) {
++			buf[i] = (u8)va_arg(args, unsigned int);
++		}
++		va_end(args);
++		fbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par, par->info->device, u8, buf, len, "%s: ", __func__);
++	}
++
++	va_start(args, len);
++
++	*buf = (u8)va_arg(args, unsigned int);
++	if (par->gpio.dc != -1)
++		gpio_set_value(par->gpio.dc, 0);
++	ret = par->fbtftops.write(par, par->buf, sizeof(u8));
++	if (ret < 0) {
++		va_end(args);
++		dev_err(par->info->device, "%s: write() failed and returned %d\n", __func__, ret);
++		return;
++	}
++	len--;
++
++	if (len) {
++		i = len;
++		while (i--) {
++			*buf++ = (u8)va_arg(args, unsigned int);
++		}
++		ret = par->fbtftops.write(par, par->buf, len * (sizeof(u8)));
++		if (ret < 0) {
++			va_end(args);
++			dev_err(par->info->device, "%s: write() failed and returned %d\n", __func__, ret);
++			return;
++		}
++	}
++	if (par->gpio.dc != -1)
++		gpio_set_value(par->gpio.dc, 1);
++	va_end(args);
++}
++
++/*
++	Grayscale Lookup Table
++	GS1 - GS63
++	The driver Gamma curve contains the relative values between the entries
++	in the Lookup table.
++
++	From datasheet:
++	8.8 Gray Scale Decoder
++
++		there are total 180 Gamma Settings (Setting 0 to Setting 180)
++		available for the Gray Scale table.
++
++		The gray scale is defined in incremental way, with reference
++		to the length of previous table entry:
++			Setting of GS1 has to be >= 0
++			Setting of GS2 has to be > Setting of GS1 +1
++			Setting of GS3 has to be > Setting of GS2 +1
++			:
++			Setting of GS63 has to be > Setting of GS62 +1
++
++
++*/
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	unsigned long tmp[GAMMA_NUM * GAMMA_LEN];
++	int i, acc = 0;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	for (i = 0; i < 63; i++) {
++		if (i > 0 && curves[i] < 2) {
++			dev_err(par->info->device,
++				"Illegal value in Grayscale Lookup Table at index %d. " \
++				"Must be greater than 1\n", i);
++			return -EINVAL;
++		}
++		acc += curves[i];
++		tmp[i] = acc;
++		if (acc > 180) {
++			dev_err(par->info->device,
++				"Illegal value(s) in Grayscale Lookup Table. " \
++				"At index=%d, the accumulated value has exceeded 180\n", i);
++			return -EINVAL;
++		}
++	}
++
++	write_reg(par, 0xB8,
++	tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7],
++	tmp[8], tmp[9], tmp[10], tmp[11], tmp[12], tmp[13], tmp[14], tmp[15],
++	tmp[16], tmp[17], tmp[18], tmp[19], tmp[20], tmp[21], tmp[22], tmp[23],
++	tmp[24], tmp[25], tmp[26], tmp[27], tmp[28], tmp[29], tmp[30], tmp[31],
++	tmp[32], tmp[33], tmp[34], tmp[35], tmp[36], tmp[37], tmp[38], tmp[39],
++	tmp[40], tmp[41], tmp[42], tmp[43], tmp[44], tmp[45], tmp[46], tmp[47],
++	tmp[48], tmp[49], tmp[50], tmp[51], tmp[52], tmp[53], tmp[54], tmp[55],
++	tmp[56], tmp[57], tmp[58], tmp[59], tmp[60], tmp[61], tmp[62]);
++
++	return 0;
++}
++
++static int blank(struct fbtft_par *par, bool on)
++{
++	fbtft_par_dbg(DEBUG_BLANK, par, "%s(blank=%s)\n",
++		__func__, on ? "true" : "false");
++	if (on)
++		write_reg(par, 0xAE);
++	else
++		write_reg(par, 0xAF);
++	return 0;
++}
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.gamma_num = GAMMA_NUM,
++	.gamma_len = GAMMA_LEN,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.write_register = write_reg8_bus8,
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_gamma = set_gamma,
++		.blank = blank,
++	},
++};
++
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("SSD1331 OLED Driver");
++MODULE_AUTHOR("Alec Smecher (adapted from SSD1351 by James Davies)");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_ssd1351.c b/drivers/video/fbtft/fb_ssd1351.c
+new file mode 100644
+index 0000000..e26cb69
+--- /dev/null
++++ b/drivers/video/fbtft/fb_ssd1351.c
+@@ -0,0 +1,223 @@
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++#include <linux/spi/spi.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_ssd1351"
++#define WIDTH		128
++#define HEIGHT		128
++#define GAMMA_NUM	1
++#define GAMMA_LEN	63
++#define DEFAULT_GAMMA	"0 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2 2 " \
++			"2 2 2 2 2 2 2" \
++
++static void register_onboard_backlight(struct fbtft_par *par);
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	if (par->pdata
++		&& par->pdata->display.backlight == FBTFT_ONBOARD_BACKLIGHT) {
++		/* module uses onboard GPIO for panel power */
++		par->fbtftops.register_backlight = register_onboard_backlight;
++	}
++
++	par->fbtftops.reset(par);
++
++	write_reg(par, 0xfd, 0x12); /* Command Lock */
++	write_reg(par, 0xfd, 0xb1); /* Command Lock */
++	write_reg(par, 0xae); /* Display Off */
++	write_reg(par, 0xb3, 0xf1); /* Front Clock Div */
++	write_reg(par, 0xca, 0x7f); /* Set Mux Ratio */
++	write_reg(par, 0xa0, 0x70 | (par->bgr << 2)); /* Set Colour Depth */
++	write_reg(par, 0x15, 0x00, 0x7f); /* Set Column Address */
++	write_reg(par, 0x75, 0x00, 0x7f); /* Set Row Address */
++	write_reg(par, 0xa1, 0x00); /* Set Display Start Line */
++	write_reg(par, 0xa2, 0x00); /* Set Display Offset */
++	write_reg(par, 0xb5, 0x00); /* Set GPIO */
++	write_reg(par, 0xab, 0x01); /* Set Function Selection */
++	write_reg(par, 0xb1, 0x32); /* Set Phase Length */
++	write_reg(par, 0xb4, 0xa0, 0xb5, 0x55); /* Set Segment Low Voltage */
++	write_reg(par, 0xbb, 0x17); /* Set Precharge Voltage */
++	write_reg(par, 0xbe, 0x05); /* Set VComH Voltage */
++	write_reg(par, 0xc1, 0xc8, 0x80, 0xc8); /* Set Contrast */
++	write_reg(par, 0xc7, 0x0f); /* Set Master Contrast */
++	write_reg(par, 0xb6, 0x01); /* Set Second Precharge Period */
++	write_reg(par, 0xa6); /* Set Display Mode Reset */
++	write_reg(par, 0xaf); /* Set Sleep Mode Display On */
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	write_reg(par, 0x15, xs, xe);
++	write_reg(par, 0x75, ys, ye);
++	write_reg(par, 0x5c);
++}
++
++/*
++	Grayscale Lookup Table
++	GS1 - GS63
++	The driver Gamma curve contains the relative values between the entries
++	in the Lookup table.
++
++	From datasheet:
++	8.8 Gray Scale Decoder
++
++		there are total 180 Gamma Settings (Setting 0 to Setting 180)
++		available for the Gray Scale table.
++
++		The gray scale is defined in incremental way, with reference
++		to the length of previous table entry:
++			Setting of GS1 has to be >= 0
++			Setting of GS2 has to be > Setting of GS1 +1
++			Setting of GS3 has to be > Setting of GS2 +1
++			:
++			Setting of GS63 has to be > Setting of GS62 +1
++
++
++*/
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	unsigned long tmp[GAMMA_NUM * GAMMA_LEN];
++	int i, acc = 0;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	for (i = 0; i < 63; i++) {
++		if (i > 0 && curves[i] < 2) {
++			dev_err(par->info->device,
++				"Illegal value in Grayscale Lookup Table at index %d. " \
++				"Must be greater than 1\n", i);
++			return -EINVAL;
++		}
++		acc += curves[i];
++		tmp[i] = acc;
++		if (acc > 180) {
++			dev_err(par->info->device,
++				"Illegal value(s) in Grayscale Lookup Table. " \
++				"At index=%d, the accumulated value has exceeded 180\n", i);
++			return -EINVAL;
++		}
++	}
++
++	write_reg(par, 0xB8,
++	tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7],
++	tmp[8], tmp[9], tmp[10], tmp[11], tmp[12], tmp[13], tmp[14], tmp[15],
++	tmp[16], tmp[17], tmp[18], tmp[19], tmp[20], tmp[21], tmp[22], tmp[23],
++	tmp[24], tmp[25], tmp[26], tmp[27], tmp[28], tmp[29], tmp[30], tmp[31],
++	tmp[32], tmp[33], tmp[34], tmp[35], tmp[36], tmp[37], tmp[38], tmp[39],
++	tmp[40], tmp[41], tmp[42], tmp[43], tmp[44], tmp[45], tmp[46], tmp[47],
++	tmp[48], tmp[49], tmp[50], tmp[51], tmp[52], tmp[53], tmp[54], tmp[55],
++	tmp[56], tmp[57], tmp[58], tmp[59], tmp[60], tmp[61], tmp[62]);
++
++	return 0;
++}
++
++static int blank(struct fbtft_par *par, bool on)
++{
++	fbtft_par_dbg(DEBUG_BLANK, par, "%s(blank=%s)\n",
++		__func__, on ? "true" : "false");
++	if (on)
++		write_reg(par, 0xAE);
++	else
++		write_reg(par, 0xAF);
++	return 0;
++}
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.gamma_num = GAMMA_NUM,
++	.gamma_len = GAMMA_LEN,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_gamma = set_gamma,
++		.blank = blank,
++	},
++};
++
++static int update_onboard_backlight(struct backlight_device *bd)
++{
++	struct fbtft_par *par = bl_get_data(bd);
++	bool on;
++
++	fbtft_par_dbg(DEBUG_BACKLIGHT, par,
++		"%s: power=%d, fb_blank=%d\n",
++		__func__, bd->props.power, bd->props.fb_blank);
++
++	on = (bd->props.power == FB_BLANK_UNBLANK)
++		&& (bd->props.fb_blank == FB_BLANK_UNBLANK);
++	/* Onboard backlight connected to GPIO0 on SSD1351, GPIO1 unused */
++	write_reg(par, 0xB5, on ? 0x03 : 0x02);
++
++	return 0;
++}
++
++static void register_onboard_backlight(struct fbtft_par *par)
++{
++	struct backlight_device *bd;
++	struct backlight_properties bl_props = { 0, };
++	struct backlight_ops *bl_ops;
++
++	fbtft_par_dbg(DEBUG_BACKLIGHT, par, "%s()\n", __func__);
++
++	bl_ops = kzalloc(sizeof(struct backlight_ops), GFP_KERNEL);
++	if (!bl_ops) {
++		dev_err(par->info->device,
++			"%s: could not allocate memory for backlight operations.\n",
++			__func__);
++		return;
++	}
++
++	bl_ops->update_status = update_onboard_backlight;
++	bl_props.type = BACKLIGHT_RAW;
++	bl_props.power = FB_BLANK_POWERDOWN;
++
++	bd = backlight_device_register(dev_driver_string(par->info->device),
++				par->info->device, par, bl_ops, &bl_props);
++	if (IS_ERR(bd)) {
++		dev_err(par->info->device,
++			"cannot register backlight device (%ld)\n",
++			PTR_ERR(bd));
++		goto failed;
++	}
++	par->info->bl_dev = bd;
++
++	if (!par->fbtftops.unregister_backlight)
++		par->fbtftops.unregister_backlight = fbtft_unregister_backlight;
++
++	return;
++failed:
++	kfree(bl_ops);
++}
++
++
++
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("SSD1351 OLED Driver");
++MODULE_AUTHOR("James Davies");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_st7735r.c b/drivers/video/fbtft/fb_st7735r.c
+new file mode 100644
+index 0000000..55972d2
+--- /dev/null
++++ b/drivers/video/fbtft/fb_st7735r.c
+@@ -0,0 +1,193 @@
++/*
++ * FB driver for the ST7735R LCD Controller
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++
++#include "fbtft.h"
++
++#define DRVNAME "fb_st7735r"
++#define DEFAULT_GAMMA "0F 1A 0F 18 2F 28 20 22 1F 1B 23 37 00 07 02 10\n" \
++                      "0F 1B 0F 17 33 2C 29 2E 30 30 39 3F 00 07 03 10"
++
++
++static int default_init_sequence[] = {
++	/* SWRESET - Software reset */
++	-1, 0x01,                                
++	-2, 150,                               /* delay */
++
++	/* SLPOUT - Sleep out & booster on */
++	-1, 0x11,                          
++	-2, 500,                               /* delay */
++
++	/* FRMCTR1 - frame rate control: normal mode
++	     frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D) */
++	-1, 0xB1, 0x01, 0x2C, 0x2D, 
++
++	/* FRMCTR2 - frame rate control: idle mode
++	     frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D) */
++	-1, 0xB2, 0x01, 0x2C, 0x2D, 
++
++	/* FRMCTR3 - frame rate control - partial mode
++	     dot inversion mode, line inversion mode */
++	-1, 0xB3, 0x01, 0x2C, 0x2D, 0x01, 0x2C, 0x2D,
++
++	/* INVCTR - display inversion control
++	     no inversion */
++	-1, 0xB4, 0x07,
++
++	/* PWCTR1 - Power Control
++	     -4.6V, AUTO mode */
++	-1, 0xC0, 0xA2, 0x02, 0x84,
++
++	/* PWCTR2 - Power Control
++	     VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD */
++	-1, 0xC1, 0xC5,
++
++	/* PWCTR3 - Power Control
++	     Opamp current small, Boost frequency */
++	-1, 0xC2, 0x0A, 0x00,
++
++	/* PWCTR4 - Power Control
++	     BCLK/2, Opamp current small & Medium low */
++	-1, 0xC3,0x8A,0x2A,
++
++	/* PWCTR5 - Power Control */
++	-1, 0xC4, 0x8A, 0xEE,
++
++	/* VMCTR1 - Power Control */
++	-1, 0xC5, 0x0E,
++
++	/* INVOFF - Display inversion off */
++	-1, 0x20,
++
++	/* COLMOD - Interface pixel format */
++	-1, 0x3A, 0x05,
++
++	/* DISPON - Display On */
++	-1, 0x29,
++	-2, 100,                               /* delay */
++
++	/* NORON - Partial off (Normal) */
++	-1, 0x13,
++	-2, 10,                               /* delay */
++
++	/* end marker */
++	-3                                  
++};
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	/* Column address */
++	write_reg(par, 0x2A, xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);
++
++	/* Row adress */
++	write_reg(par, 0x2B, ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);
++
++	/* Memory write */
++	write_reg(par, 0x2C);
++}
++
++#define MY (1 << 7)
++#define MX (1 << 6)
++#define MV (1 << 5)
++static int set_var(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* MADCTL - Memory data access control
++	     RGB/BGR:
++	     1. Mode selection pin SRGB
++	        RGB H/W pin for color filter setting: 0=RGB, 1=BGR
++	     2. MADCTL RGB bit
++	        RGB-BGR ORDER color filter panel: 0=RGB, 1=BGR */
++	switch (par->info->var.rotate) {
++	case 0:
++		write_reg(par, 0x36, MX | MY | (par->bgr << 3));
++		break;
++	case 270:
++		write_reg(par, 0x36, MY | MV | (par->bgr << 3));
++		break;
++	case 180:
++		write_reg(par, 0x36, (par->bgr << 3));
++		break;
++	case 90:
++		write_reg(par, 0x36, MX | MV | (par->bgr << 3));
++		break;
++	}
++
++	return 0;
++}
++
++/*
++  Gamma string format:
++    VRF0P VOS0P PK0P PK1P PK2P PK3P PK4P PK5P PK6P PK7P PK8P PK9P SELV0P SELV1P SELV62P SELV63P
++    VRF0N VOS0N PK0N PK1N PK2N PK3N PK4N PK5N PK6N PK7N PK8N PK9N SELV0N SELV1N SELV62N SELV63N
++*/
++#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
++static int set_gamma(struct fbtft_par *par, unsigned long *curves)
++{
++	int i,j;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* apply mask */
++	for (i = 0; i < par->gamma.num_curves; i++)
++		for (j = 0; j < par->gamma.num_values; j++)
++			CURVE(i,j) &= 0b111111;
++
++	for (i = 0; i < par->gamma.num_curves; i++)
++		write_reg(par, 0xE0 + i,
++			CURVE(i, 0), CURVE(i, 1), CURVE(i, 2), CURVE(i, 3),
++			CURVE(i, 4), CURVE(i, 5), CURVE(i, 6), CURVE(i, 7),
++			CURVE(i, 8), CURVE(i, 9), CURVE(i, 10), CURVE(i, 11),
++			CURVE(i, 12), CURVE(i, 13), CURVE(i, 14), CURVE(i,15));
++
++	return 0;
++}
++#undef CURVE
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = 128,
++	.height = 160,
++	.init_sequence = default_init_sequence,
++	.gamma_num = 2,
++	.gamma_len = 16,
++	.gamma = DEFAULT_GAMMA,
++	.fbtftops = {
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++		.set_gamma = set_gamma,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++MODULE_ALIAS("platform:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the ST7735R LCD Controller");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_tinylcd.c b/drivers/video/fbtft/fb_tinylcd.c
+new file mode 100644
+index 0000000..893f378
+--- /dev/null
++++ b/drivers/video/fbtft/fb_tinylcd.c
+@@ -0,0 +1,123 @@
++/*
++ * Custom FB driver for tinylcd.com display
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME		"fb_tinylcd"
++#define WIDTH		320
++#define HEIGHT		480
++
++
++static int init_display(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	par->fbtftops.reset(par);
++
++	write_reg(par, 0xB0, 0x80);
++	write_reg(par, 0xC0, 0x0A, 0x0A);
++	write_reg(par, 0xC1, 0x45, 0x07);
++	write_reg(par, 0xC2, 0x33);
++	write_reg(par, 0xC5, 0x00, 0x42, 0x80);
++	write_reg(par, 0xB1, 0xD0, 0x11);
++	write_reg(par, 0xB4, 0x02);
++	write_reg(par, 0xB6, 0x00, 0x22, 0x3B);
++	write_reg(par, 0xB7, 0x07);
++	write_reg(par, 0x36, 0x58);
++	write_reg(par, 0xF0, 0x36, 0xA5, 0xD3);
++	write_reg(par, 0xE5, 0x80);
++	write_reg(par, 0xE5, 0x01);
++	write_reg(par, 0xB3, 0x00);
++	write_reg(par, 0xE5, 0x00);
++	write_reg(par, 0xF0, 0x36, 0xA5, 0x53);
++	write_reg(par, 0xE0, 0x00, 0x35, 0x33, 0x00, 0x00, 0x00,
++	                     0x00, 0x35, 0x33, 0x00, 0x00, 0x00);
++	write_reg(par, 0x3A, 0x55);
++	write_reg(par, 0x11);
++	udelay(250);
++	write_reg(par, 0x29);
++
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	/* Column address */
++	write_reg(par, 0x2A, xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);
++
++	/* Row adress */
++	write_reg(par, 0x2B, ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);
++
++	/* Memory write */
++	write_reg(par, 0x2C);
++}
++
++static int set_var(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	switch (par->info->var.rotate) {
++	case 270:
++		write_reg(par, 0xB6, 0x00, 0x02, 0x3B);
++		write_reg(par, 0x36, 0x28);
++		break;
++	case 180:
++		write_reg(par, 0xB6, 0x00, 0x22, 0x3B);
++		write_reg(par, 0x36, 0x58);
++		break;
++	case 90:
++		write_reg(par, 0xB6, 0x00, 0x22, 0x3B);
++		write_reg(par, 0x36, 0x38);
++		break;
++	default:
++		write_reg(par, 0xB6, 0x00, 0x22, 0x3B);
++		write_reg(par, 0x36, 0x08);
++		break;
++	}
++
++	return 0;
++}
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.fbtftops = {
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++
++MODULE_DESCRIPTION("Custom FB driver for tinylcd.com display");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fb_watterott.c b/drivers/video/fbtft/fb_watterott.c
+new file mode 100644
+index 0000000..180d192
+--- /dev/null
++++ b/drivers/video/fbtft/fb_watterott.c
+@@ -0,0 +1,323 @@
++/*
++ * FB driver for the Watterott LCD Controller
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/gpio.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME			"fb_watterott"
++#define WIDTH			320
++#define HEIGHT			240
++#define FPS			5
++#define TXBUFLEN		1024
++#define DEFAULT_BRIGHTNESS	50
++
++#define CMD_VERSION		0x01
++#define CMD_LCD_LED		0x10
++#define CMD_LCD_RESET		0x11
++#define CMD_LCD_ORIENTATION	0x20
++#define CMD_LCD_DRAWIMAGE	0x27
++#define COLOR_RGB323		8
++#define COLOR_RGB332		9
++#define COLOR_RGB233		10
++#define COLOR_RGB565		16
++
++
++static short mode = 565;
++module_param(mode, short, 0);
++MODULE_PARM_DESC(mode, "RGB color transfer mode: 332, 565 (default)");
++
++static void write_reg8_bus8(struct fbtft_par *par, int len, ...)
++{
++	va_list args;
++	int i, ret;
++	u8 *buf = par->buf;
++
++	va_start(args, len);
++	for (i = 0; i < len; i++)
++		*buf++ = (u8)va_arg(args, unsigned int);
++	va_end(args);
++
++	fbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par,
++		par->info->device, u8, par->buf, len, "%s: ", __func__);
++
++	ret = par->fbtftops.write(par, par->buf, len);
++	if (ret < 0) {
++		dev_err(par->info->device,
++			"%s: write() failed and returned %d\n", __func__, ret);
++		return;
++	}
++}
++
++static int write_vmem(struct fbtft_par *par, size_t offset, size_t len)
++{
++	unsigned start_line, end_line;
++	u16 *vmem16 = (u16 *)(par->info->screen_base + offset);
++	u16 *pos = par->txbuf.buf + 1;
++	u16 *buf16 = par->txbuf.buf + 10;
++	int i, j;
++	int ret = 0;
++
++	fbtft_par_dbg(DEBUG_WRITE_VMEM, par, "%s()\n", __func__);
++
++	start_line = offset / par->info->fix.line_length;
++	end_line = start_line + (len / par->info->fix.line_length) - 1;
++
++	/* Set command header. pos: x, y, w, h */
++	((u8 *)par->txbuf.buf)[0] = CMD_LCD_DRAWIMAGE;
++	pos[0] = 0;
++	pos[2] = cpu_to_be16(par->info->var.xres);
++	pos[3] = cpu_to_be16(1);
++	((u8 *)par->txbuf.buf)[9] = COLOR_RGB565;
++
++	for (i = start_line; i <= end_line; i++) {
++		pos[1] = cpu_to_be16(i);
++		for (j = 0; j < par->info->var.xres; j++)
++			buf16[j] = cpu_to_be16(*vmem16++);
++		ret = par->fbtftops.write(par,
++			par->txbuf.buf, 10 + par->info->fix.line_length);
++		if (ret < 0)
++			return ret;
++		udelay(300);
++	}
++
++	return 0;
++}
++
++#define RGB565toRGB323(c) (((c&0xE000)>>8) | ((c&0600)>>6) | ((c&0x001C)>>2))
++#define RGB565toRGB332(c) (((c&0xE000)>>8) | ((c&0700)>>6) | ((c&0x0018)>>3))
++#define RGB565toRGB233(c) (((c&0xC000)>>8) | ((c&0700)>>5) | ((c&0x001C)>>2))
++
++static int write_vmem_8bit(struct fbtft_par *par, size_t offset, size_t len)
++{
++	unsigned start_line, end_line;
++	u16 *vmem16 = (u16 *)(par->info->screen_base + offset);
++	u16 *pos = par->txbuf.buf + 1;
++	u8 *buf8 = par->txbuf.buf + 10;
++	int i, j;
++	int ret = 0;
++
++	fbtft_par_dbg(DEBUG_WRITE_VMEM, par, "%s()\n", __func__);
++
++	start_line = offset / par->info->fix.line_length;
++	end_line = start_line + (len / par->info->fix.line_length) - 1;
++
++	/* Set command header. pos: x, y, w, h */
++	((u8 *)par->txbuf.buf)[0] = CMD_LCD_DRAWIMAGE;
++	pos[0] = 0;
++	pos[2] = cpu_to_be16(par->info->var.xres);
++	pos[3] = cpu_to_be16(1);
++	((u8 *)par->txbuf.buf)[9] = COLOR_RGB332;
++
++	for (i = start_line; i <= end_line; i++) {
++		pos[1] = cpu_to_be16(i);
++		for (j = 0; j < par->info->var.xres; j++) {
++			buf8[j] = RGB565toRGB332(*vmem16);
++			vmem16++;
++		}
++		ret = par->fbtftops.write(par,
++			par->txbuf.buf, 10 + par->info->var.xres);
++		if (ret < 0)
++			return ret;
++		udelay(700);
++	}
++
++	return 0;
++}
++
++static unsigned firmware_version(struct fbtft_par *par)
++{
++	u8 rxbuf[4] = {0, };
++
++	write_reg(par, CMD_VERSION);
++	par->fbtftops.read(par, rxbuf, 4);
++	if (rxbuf[1] != '.')
++		return 0;
++
++	return (rxbuf[0] - '0') << 8 | (rxbuf[2] - '0') << 4 | (rxbuf[3] - '0');
++}
++
++static int init_display(struct fbtft_par *par)
++{
++	int ret;
++	unsigned version;
++	u8 save_mode;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* enable SPI interface by having CS and MOSI low during reset */
++	save_mode = par->spi->mode;
++	par->spi->mode |= SPI_CS_HIGH;
++	ret = par->spi->master->setup(par->spi); /* set CS inactive low */
++	if (ret) {
++		dev_err(par->info->device, "Could not set SPI_CS_HIGH\n");
++		return ret;
++	}
++	write_reg(par, 0x00); /* make sure mode is set */
++
++	mdelay(50);
++	par->fbtftops.reset(par);
++	mdelay(1000);
++	par->spi->mode = save_mode;
++	ret = par->spi->master->setup(par->spi);
++	if (ret) {
++		dev_err(par->info->device, "Could not restore SPI mode\n");
++		return ret;
++	}
++	write_reg(par, 0x00);
++
++	version = firmware_version(par);
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "Firmware version: %x.%02x\n",
++						version >> 8, version & 0xFF);
++
++	if (mode == 332)
++		par->fbtftops.write_vmem = write_vmem_8bit;
++	return 0;
++}
++
++static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	/* not used on this controller */
++}
++
++static int set_var(struct fbtft_par *par)
++{
++	u8 rotate;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* this controller rotates clock wise */
++	switch (par->info->var.rotate) {
++	case 90:
++		rotate = 27;
++		break;
++	case 180:
++		rotate = 18;
++		break;
++	case 270:
++		rotate = 9;
++		break;
++	default:
++		rotate = 0;
++	}
++	write_reg(par, CMD_LCD_ORIENTATION, rotate);
++
++	return 0;
++}
++
++static int verify_gpios(struct fbtft_par *par)
++{
++	if (par->gpio.reset < 0) {
++		dev_err(par->info->device, "Missing 'reset' gpio. Aborting.\n");
++		return -EINVAL;
++	}
++	return 0;
++}
++
++static int backlight_chip_update_status(struct backlight_device *bd)
++{
++	struct fbtft_par *par = bl_get_data(bd);
++	int brightness = bd->props.brightness;
++
++	fbtft_par_dbg(DEBUG_BACKLIGHT, par,
++		"%s: brightness=%d, power=%d, fb_blank=%d\n",
++		__func__, bd->props.brightness, bd->props.power,
++		bd->props.fb_blank);
++
++	if (bd->props.power != FB_BLANK_UNBLANK)
++		brightness = 0;
++
++	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
++		brightness = 0;
++
++	write_reg(par, CMD_LCD_LED, brightness);
++
++	return 0;
++}
++
++static void register_chip_backlight(struct fbtft_par *par)
++{
++	struct backlight_device *bd;
++	struct backlight_properties bl_props = { 0, };
++	struct backlight_ops *bl_ops;
++
++	fbtft_par_dbg(DEBUG_BACKLIGHT, par, "%s()\n", __func__);
++
++	bl_ops = kzalloc(sizeof(struct backlight_ops), GFP_KERNEL);
++	if (!bl_ops) {
++		dev_err(par->info->device,
++			"%s: could not allocate memory for backlight operations.\n",
++			__func__);
++		return;
++	}
++
++	bl_ops->update_status = backlight_chip_update_status;
++	bl_props.type = BACKLIGHT_RAW;
++	bl_props.power = FB_BLANK_POWERDOWN;
++	bl_props.max_brightness = 100;
++	bl_props.brightness = DEFAULT_BRIGHTNESS;
++
++	bd = backlight_device_register(dev_driver_string(par->info->device),
++				par->info->device, par, bl_ops, &bl_props);
++	if (IS_ERR(bd)) {
++		dev_err(par->info->device,
++			"cannot register backlight device (%ld)\n",
++			PTR_ERR(bd));
++		goto failed;
++	}
++	par->info->bl_dev = bd;
++
++	if (!par->fbtftops.unregister_backlight)
++		par->fbtftops.unregister_backlight = fbtft_unregister_backlight;
++
++	return;
++failed:
++	kfree(bl_ops);
++}
++
++
++static struct fbtft_display display = {
++	.regwidth = 8,
++	.buswidth = 8,
++	.width = WIDTH,
++	.height = HEIGHT,
++	.fps = FPS,
++	.txbuflen = TXBUFLEN,
++	.fbtftops = {
++		.write_register = write_reg8_bus8,
++		.write_vmem = write_vmem,
++		.init_display = init_display,
++		.set_addr_win = set_addr_win,
++		.set_var = set_var,
++		.verify_gpios = verify_gpios,
++		.register_backlight = register_chip_backlight,
++	},
++};
++FBTFT_REGISTER_DRIVER(DRVNAME, &display);
++
++MODULE_ALIAS("spi:" DRVNAME);
++
++MODULE_DESCRIPTION("FB driver for the Watterott LCD Controller");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fbtft-bus.c b/drivers/video/fbtft/fbtft-bus.c
+new file mode 100644
+index 0000000..b3cddb0
+--- /dev/null
++++ b/drivers/video/fbtft/fbtft-bus.c
+@@ -0,0 +1,256 @@
++#include <linux/export.h>
++#include <linux/errno.h>
++#include <linux/gpio.h>
++#include <linux/spi/spi.h>
++#include "fbtft.h"
++
++
++
++
++/*****************************************************************************
++ *
++ *   void (*write_reg)(struct fbtft_par *par, int len, ...);
++ *
++ *****************************************************************************/
++
++#define define_fbtft_write_reg(func, type, modifier)                          \
++void func(struct fbtft_par *par, int len, ...)                                \
++{                                                                             \
++	va_list args;                                                         \
++	int i, ret;                                                           \
++	int offset = 0;                                                       \
++	type *buf = (type *)par->buf;                                         \
++									      \
++	if (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {                    \
++		va_start(args, len);                                          \
++		for (i = 0; i < len; i++) {                                   \
++			buf[i] = (type)va_arg(args, unsigned int);            \
++		}                                                             \
++		va_end(args);                                                 \
++		fbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par, par->info->device, type, buf, len, "%s: ", __func__);   \
++	}                                                                     \
++									      \
++	va_start(args, len);                                                  \
++									      \
++	if (par->startbyte) {                                                 \
++		*(u8 *)par->buf = par->startbyte;                             \
++		buf = (type *)(par->buf + 1);                                 \
++		offset = 1;                                                   \
++	}                                                                     \
++									      \
++	*buf = modifier((type)va_arg(args, unsigned int));                    \
++	if (par->gpio.dc != -1)                                               \
++		gpio_set_value(par->gpio.dc, 0);                              \
++	ret = par->fbtftops.write(par, par->buf, sizeof(type)+offset);        \
++	if (ret < 0) {                                                        \
++		va_end(args);                                                 \
++		dev_err(par->info->device, "%s: write() failed and returned %d\n", __func__, ret); \
++		return;                                                       \
++	}                                                                     \
++	len--;                                                                \
++									      \
++	if (par->startbyte)                                                   \
++		*(u8 *)par->buf = par->startbyte | 0x2;                       \
++									      \
++	if (len) {                                                            \
++		i = len;                                                      \
++		while (i--) {                                                 \
++			*buf++ = modifier((type)va_arg(args, unsigned int));  \
++		}                                                             \
++		if (par->gpio.dc != -1)                                       \
++			gpio_set_value(par->gpio.dc, 1);                      \
++		ret = par->fbtftops.write(par, par->buf, len * (sizeof(type)+offset)); \
++		if (ret < 0) {                                                \
++			va_end(args);                                         \
++			dev_err(par->info->device, "%s: write() failed and returned %d\n", __func__, ret); \
++			return;                                               \
++		}                                                             \
++	}                                                                     \
++	va_end(args);                                                         \
++}                                                                             \
++EXPORT_SYMBOL(func);
++
++define_fbtft_write_reg(fbtft_write_reg8_bus8, u8, )
++define_fbtft_write_reg(fbtft_write_reg16_bus8, u16, cpu_to_be16)
++define_fbtft_write_reg(fbtft_write_reg16_bus16, u16, )
++
++void fbtft_write_reg8_bus9(struct fbtft_par *par, int len, ...)
++{
++	va_list args;
++	int i, ret;
++	int pad = 0;
++	u16 *buf = (u16 *)par->buf;
++
++	if (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {
++		va_start(args, len);
++		for (i = 0; i < len; i++)
++			*(((u8 *)buf) + i) = (u8)va_arg(args, unsigned int);
++		va_end(args);
++		fbtft_par_dbg_hex(DEBUG_WRITE_REGISTER, par,
++			par->info->device, u8, buf, len, "%s: ", __func__);
++	}
++	if (len <= 0)
++		return;
++
++	if (par->spi && (par->spi->bits_per_word == 8)) {
++		/* we're emulating 9-bit, pad start of buffer with no-ops
++		   (assuming here that zero is a no-op) */
++		pad = (len % 4) ? 4 - (len % 4) : 0;
++		for (i = 0; i < pad; i++)
++			*buf++ = 0x000;
++	}
++
++	va_start(args, len);
++	*buf++ = (u8)va_arg(args, unsigned int);
++	i = len - 1;
++	while (i--) {
++		*buf = (u8)va_arg(args, unsigned int);
++		*buf++ |= 0x100; /* dc=1 */
++	}
++	va_end(args);
++	ret = par->fbtftops.write(par, par->buf, (len + pad) * sizeof(u16));
++	if (ret < 0) {
++		dev_err(par->info->device,
++			"%s: write() failed and returned %d\n", __func__, ret);
++		return;
++	}
++}
++EXPORT_SYMBOL(fbtft_write_reg8_bus9);
++
++
++
++
++/*****************************************************************************
++ *
++ *   int (*write_vmem)(struct fbtft_par *par);
++ *
++ *****************************************************************************/
++
++/* 16 bit pixel over 8-bit databus */
++int fbtft_write_vmem16_bus8(struct fbtft_par *par, size_t offset, size_t len)
++{
++	u16 *vmem16;
++	u16 *txbuf16 = (u16 *)par->txbuf.buf;
++	size_t remain;
++	size_t to_copy;
++	size_t tx_array_size;
++	int i;
++	int ret = 0;
++	size_t startbyte_size = 0;
++
++	fbtft_par_dbg(DEBUG_WRITE_VMEM, par, "%s(offset=%zu, len=%zu)\n",
++		__func__, offset, len);
++
++	remain = len / 2;
++	vmem16 = (u16 *)(par->info->screen_base + offset);
++
++	if (par->gpio.dc != -1)
++		gpio_set_value(par->gpio.dc, 1);
++
++	/* non buffered write */
++	if (!par->txbuf.buf)
++		return par->fbtftops.write(par, vmem16, len);
++
++	/* buffered write */
++	tx_array_size = par->txbuf.len / 2;
++
++	if (par->startbyte) {
++		txbuf16 = (u16 *)(par->txbuf.buf + 1);
++		tx_array_size -= 2;
++		*(u8 *)(par->txbuf.buf) = par->startbyte | 0x2;
++		startbyte_size = 1;
++	}
++
++	while (remain) {
++		to_copy = remain > tx_array_size ? tx_array_size : remain;
++		dev_dbg(par->info->device, "    to_copy=%zu, remain=%zu\n",
++						to_copy, remain - to_copy);
++
++		for (i = 0; i < to_copy; i++)
++			txbuf16[i] = cpu_to_be16(vmem16[i]);
++
++		vmem16 = vmem16 + to_copy;
++		ret = par->fbtftops.write(par, par->txbuf.buf,
++						startbyte_size + to_copy * 2);
++		if (ret < 0)
++			return ret;
++		remain -= to_copy;
++	}
++
++	return ret;
++}
++EXPORT_SYMBOL(fbtft_write_vmem16_bus8);
++
++/* 16 bit pixel over 9-bit SPI bus: dc + high byte, dc + low byte */
++int fbtft_write_vmem16_bus9(struct fbtft_par *par, size_t offset, size_t len)
++{
++	u8 *vmem8;
++	u16 *txbuf16 = par->txbuf.buf;
++	size_t remain;
++	size_t to_copy;
++	size_t tx_array_size;
++	int i;
++	int ret = 0;
++
++	fbtft_par_dbg(DEBUG_WRITE_VMEM, par, "%s(offset=%zu, len=%zu)\n",
++		__func__, offset, len);
++
++	if (!par->txbuf.buf) {
++		dev_err(par->info->device, "%s: txbuf.buf is NULL\n", __func__);
++		return -1;
++	}
++
++	remain = len;
++	vmem8 = par->info->screen_base + offset;
++
++	tx_array_size = par->txbuf.len / 2;
++
++	while (remain) {
++		to_copy = remain > tx_array_size ? tx_array_size : remain;
++		dev_dbg(par->info->device, "    to_copy=%zu, remain=%zu\n",
++						to_copy, remain - to_copy);
++
++#ifdef __LITTLE_ENDIAN
++		for (i = 0; i < to_copy; i += 2) {
++			txbuf16[i]   = 0x0100 | vmem8[i+1];
++			txbuf16[i+1] = 0x0100 | vmem8[i];
++		}
++#else
++		for (i = 0; i < to_copy; i++)
++			txbuf16[i]   = 0x0100 | vmem8[i];
++#endif
++		vmem8 = vmem8 + to_copy;
++		ret = par->fbtftops.write(par, par->txbuf.buf, to_copy*2);
++		if (ret < 0)
++			return ret;
++		remain -= to_copy;
++	}
++
++	return ret;
++}
++EXPORT_SYMBOL(fbtft_write_vmem16_bus9);
++
++int fbtft_write_vmem8_bus8(struct fbtft_par *par, size_t offset, size_t len)
++{
++	dev_err(par->info->device, "%s: function not implemented\n", __func__);
++	return -1;
++}
++EXPORT_SYMBOL(fbtft_write_vmem8_bus8);
++
++/* 16 bit pixel over 16-bit databus */
++int fbtft_write_vmem16_bus16(struct fbtft_par *par, size_t offset, size_t len)
++{
++	u16 *vmem16;
++
++	fbtft_par_dbg(DEBUG_WRITE_VMEM, par, "%s(offset=%zu, len=%zu)\n",
++		__func__, offset, len);
++
++	vmem16 = (u16 *)(par->info->screen_base + offset);
++
++	if (par->gpio.dc != -1)
++		gpio_set_value(par->gpio.dc, 1);
++
++	/* no need for buffered write with 16-bit bus */
++	return par->fbtftops.write(par, vmem16, len);
++}
++EXPORT_SYMBOL(fbtft_write_vmem16_bus16);
+diff --git a/drivers/video/fbtft/fbtft-core.c b/drivers/video/fbtft/fbtft-core.c
+new file mode 100644
+index 0000000..54f2614
+--- /dev/null
++++ b/drivers/video/fbtft/fbtft-core.c
+@@ -0,0 +1,1336 @@
++/*
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This driver is inspired by:
++ *   st7735fb.c, Copyright (C) 2011, Matt Porter
++ *   broadsheetfb.c, Copyright (C) 2008, Jaya Kumar
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/errno.h>
++#include <linux/string.h>
++#include <linux/mm.h>
++#include <linux/vmalloc.h>
++#include <linux/slab.h>
++#include <linux/init.h>
++#include <linux/fb.h>
++#include <linux/gpio.h>
++#include <linux/spi/spi.h>
++#include <linux/delay.h>
++#include <linux/uaccess.h>
++#include <linux/backlight.h>
++#include <linux/platform_device.h>
++#include <linux/spinlock.h>
++#include <linux/dma-mapping.h>
++
++#include "fbtft.h"
++
++extern void fbtft_sysfs_init(struct fbtft_par *par);
++extern void fbtft_sysfs_exit(struct fbtft_par *par);
++extern void fbtft_expand_debug_value(unsigned long *debug);
++extern int fbtft_gamma_parse_str(struct fbtft_par *par, unsigned long *curves,
++						const char *str, int size);
++
++static unsigned long debug;
++module_param(debug, ulong , 0);
++MODULE_PARM_DESC(debug, "override device debug level");
++
++static bool dma = true;
++module_param(dma, bool, 0);
++MODULE_PARM_DESC(dma, "Use DMA buffer");
++
++
++void fbtft_dbg_hex(const struct device *dev, int groupsize,
++			void *buf, size_t len, const char *fmt, ...)
++{
++	va_list args;
++	static char textbuf[512];
++	char *text = textbuf;
++	size_t text_len;
++
++	va_start(args, fmt);
++	text_len = vscnprintf(text, sizeof(textbuf), fmt, args);
++	va_end(args);
++
++	hex_dump_to_buffer(buf, len, 32, groupsize, text + text_len,
++				512 - text_len, false);
++
++	if (len > 32)
++		dev_info(dev, "%s ...\n", text);
++	else
++		dev_info(dev, "%s\n", text);
++}
++EXPORT_SYMBOL(fbtft_dbg_hex);
++
++unsigned long fbtft_request_gpios_match(struct fbtft_par *par,
++					const struct fbtft_gpio *gpio)
++{
++	int ret;
++	long val;
++
++	fbtft_par_dbg(DEBUG_REQUEST_GPIOS_MATCH, par, "%s('%s')\n",
++		__func__, gpio->name);
++
++	if (strcasecmp(gpio->name, "reset") == 0) {
++		par->gpio.reset = gpio->gpio;
++		return GPIOF_OUT_INIT_HIGH;
++	} else if (strcasecmp(gpio->name, "dc") == 0) {
++		par->gpio.dc = gpio->gpio;
++		return GPIOF_OUT_INIT_LOW;
++	} else if (strcasecmp(gpio->name, "cs") == 0) {
++		par->gpio.cs = gpio->gpio;
++		return GPIOF_OUT_INIT_HIGH;
++	} else if (strcasecmp(gpio->name, "wr") == 0) {
++		par->gpio.wr = gpio->gpio;
++		return GPIOF_OUT_INIT_HIGH;
++	} else if (strcasecmp(gpio->name, "rd") == 0) {
++		par->gpio.rd = gpio->gpio;
++		return GPIOF_OUT_INIT_HIGH;
++	} else if (strcasecmp(gpio->name, "latch") == 0) {
++		par->gpio.latch = gpio->gpio;
++		return GPIOF_OUT_INIT_LOW;
++	} else if (gpio->name[0] == 'd' && gpio->name[1] == 'b') {
++		ret = kstrtol(&gpio->name[2], 10, &val);
++		if (ret == 0 && val < 16) {
++			par->gpio.db[val] = gpio->gpio;
++			return GPIOF_OUT_INIT_LOW;
++		}
++	} else if (strcasecmp(gpio->name, "led") == 0) {
++		par->gpio.led[0] = gpio->gpio;
++		return GPIOF_OUT_INIT_LOW;
++	} else if (strcasecmp(gpio->name, "led_") == 0) {
++		par->gpio.led[0] = gpio->gpio;
++		return GPIOF_OUT_INIT_HIGH;
++	}
++
++	return FBTFT_GPIO_NO_MATCH;
++}
++
++int fbtft_request_gpios(struct fbtft_par *par)
++{
++	struct fbtft_platform_data *pdata = par->pdata;
++	const struct fbtft_gpio *gpio;
++	unsigned long flags;
++	int i;
++	int ret;
++
++	/* Initialize gpios to disabled */
++	par->gpio.reset = -1;
++	par->gpio.dc = -1;
++	par->gpio.rd = -1;
++	par->gpio.wr = -1;
++	par->gpio.cs = -1;
++	par->gpio.latch = -1;
++	for (i = 0; i < 16; i++) {
++		par->gpio.db[i] = -1;
++		par->gpio.led[i] = -1;
++		par->gpio.aux[i] = -1;
++	}
++
++	if (pdata && pdata->gpios) {
++		gpio = pdata->gpios;
++		while (gpio->name[0]) {
++			flags = FBTFT_GPIO_NO_MATCH;
++			/* if driver provides match function, try it first,
++			   if no match use our own */
++			if (par->fbtftops.request_gpios_match)
++				flags = par->fbtftops.request_gpios_match(par, gpio);
++			if (flags == FBTFT_GPIO_NO_MATCH)
++				flags = fbtft_request_gpios_match(par, gpio);
++			if (flags != FBTFT_GPIO_NO_MATCH) {
++				ret = gpio_request_one(gpio->gpio, flags,
++					par->info->device->driver->name);
++				if (ret < 0) {
++					dev_err(par->info->device,
++						"%s: gpio_request_one('%s'=%d) failed with %d\n",
++						__func__, gpio->name,
++						gpio->gpio, ret);
++					return ret;
++				}
++				fbtft_par_dbg(DEBUG_REQUEST_GPIOS, par,
++					"%s: '%s' = GPIO%d\n",
++					__func__, gpio->name, gpio->gpio);
++			}
++			gpio++;
++		}
++	}
++
++	return 0;
++}
++
++void fbtft_free_gpios(struct fbtft_par *par)
++{
++	struct fbtft_platform_data *pdata = NULL;
++	const struct fbtft_gpio *gpio;
++
++	fbtft_par_dbg(DEBUG_FREE_GPIOS, par, "%s()\n", __func__);
++
++	if (par->spi)
++		pdata = par->spi->dev.platform_data;
++	if (par->pdev)
++		pdata = par->pdev->dev.platform_data;
++
++	if (pdata && pdata->gpios) {
++		gpio = pdata->gpios;
++		while (gpio->name[0]) {
++			fbtft_par_dbg(DEBUG_FREE_GPIOS, par,
++				"%s(): gpio_free('%s'=%d)\n",
++				__func__, gpio->name, gpio->gpio);
++			/* if the gpio wasn't recognized by request_gpios,
++			   WARN() will protest */
++			gpio_direction_input(gpio->gpio);
++			gpio_free(gpio->gpio);
++			gpio++;
++		}
++	}
++}
++
++int fbtft_backlight_update_status(struct backlight_device *bd)
++{
++	struct fbtft_par *par = bl_get_data(bd);
++	bool polarity = !!(bd->props.state & BL_CORE_DRIVER1);
++
++	fbtft_par_dbg(DEBUG_BACKLIGHT, par,
++		"%s: polarity=%d, power=%d, fb_blank=%d\n",
++		__func__, polarity, bd->props.power, bd->props.fb_blank);
++
++	if ((bd->props.power == FB_BLANK_UNBLANK) && (bd->props.fb_blank == FB_BLANK_UNBLANK))
++		gpio_set_value(par->gpio.led[0], polarity);
++	else
++		gpio_set_value(par->gpio.led[0], !polarity);
++
++	return 0;
++}
++
++int fbtft_backlight_get_brightness(struct backlight_device *bd)
++{
++	return bd->props.brightness;
++}
++
++void fbtft_unregister_backlight(struct fbtft_par *par)
++{
++	const struct backlight_ops *bl_ops;
++
++	fbtft_par_dbg(DEBUG_BACKLIGHT, par, "%s()\n", __func__);
++
++	if (par->info->bl_dev) {
++		par->info->bl_dev->props.power = FB_BLANK_POWERDOWN;
++		backlight_update_status(par->info->bl_dev);
++		bl_ops = par->info->bl_dev->ops;
++		backlight_device_unregister(par->info->bl_dev);
++		par->info->bl_dev = NULL;
++		kfree(bl_ops);
++	}
++}
++EXPORT_SYMBOL(fbtft_unregister_backlight);
++
++void fbtft_register_backlight(struct fbtft_par *par)
++{
++	struct backlight_device *bd;
++	struct backlight_properties bl_props = { 0, };
++	struct backlight_ops *bl_ops;
++
++	fbtft_par_dbg(DEBUG_BACKLIGHT, par, "%s()\n", __func__);
++
++	if (par->gpio.led[0] == -1) {
++		fbtft_par_dbg(DEBUG_BACKLIGHT, par,
++			"%s(): led pin not set, exiting.\n", __func__);
++		return;
++	}
++
++	bl_ops = kzalloc(sizeof(struct backlight_ops), GFP_KERNEL);
++	if (!bl_ops) {
++		dev_err(par->info->device,
++			"%s: could not allocate memeory for backlight operations.\n",
++			__func__);
++		return;
++	}
++
++	bl_ops->get_brightness = fbtft_backlight_get_brightness;
++	bl_ops->update_status = fbtft_backlight_update_status;
++	bl_props.type = BACKLIGHT_RAW;
++	/* Assume backlight is off, get polarity from current state of pin */
++	bl_props.power = FB_BLANK_POWERDOWN;
++	if (!gpio_get_value(par->gpio.led[0]))
++		bl_props.state |= BL_CORE_DRIVER1;
++
++	bd = backlight_device_register(dev_driver_string(par->info->device),
++				par->info->device, par, bl_ops, &bl_props);
++	if (IS_ERR(bd)) {
++		dev_err(par->info->device,
++			"cannot register backlight device (%ld)\n",
++			PTR_ERR(bd));
++		goto failed;
++	}
++	par->info->bl_dev = bd;
++
++	if (!par->fbtftops.unregister_backlight)
++		par->fbtftops.unregister_backlight = fbtft_unregister_backlight;
++
++	return;
++
++failed:
++	kfree(bl_ops);
++}
++EXPORT_SYMBOL(fbtft_register_backlight);
++
++void fbtft_set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	/* Column address set */
++	write_reg(par, 0x2A,
++		(xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);
++
++	/* Row adress set */
++	write_reg(par, 0x2B,
++		(ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);
++
++	/* Memory write */
++	write_reg(par, 0x2C);
++}
++
++
++void fbtft_reset(struct fbtft_par *par)
++{
++	if (par->gpio.reset == -1)
++		return;
++	fbtft_par_dbg(DEBUG_RESET, par, "%s()\n", __func__);
++	gpio_set_value(par->gpio.reset, 0);
++	udelay(20);
++	gpio_set_value(par->gpio.reset, 1);
++	mdelay(120);
++}
++
++
++void fbtft_update_display(struct fbtft_par *par, unsigned start_line, unsigned end_line)
++{
++	size_t offset, len;
++	struct timespec ts_start, ts_end, ts_fps, ts_duration;
++	long fps_ms, fps_us, duration_ms, duration_us;
++	long fps, throughput;
++	bool timeit = false;
++	int ret = 0;
++
++	if (unlikely(par->debug & (DEBUG_TIME_FIRST_UPDATE | DEBUG_TIME_EACH_UPDATE))) {
++		if ((par->debug & DEBUG_TIME_EACH_UPDATE) || \
++				((par->debug & DEBUG_TIME_FIRST_UPDATE) && !par->first_update_done)) {
++			getnstimeofday(&ts_start);
++			timeit = true;
++		}
++	}
++
++	/* Sanity checks */
++	if (start_line > end_line) {
++		dev_warn(par->info->device,
++			"%s: start_line=%u is larger than end_line=%u. Shouldn't happen, will do full display update\n",
++			__func__, start_line, end_line);
++		start_line = 0;
++		end_line = par->info->var.yres - 1;
++	}
++	if (start_line > par->info->var.yres - 1 || end_line > par->info->var.yres - 1) {
++		dev_warn(par->info->device,
++			"%s: start_line=%u or end_line=%u is larger than max=%d. Shouldn't happen, will do full display update\n",
++			__func__, start_line, end_line, par->info->var.yres - 1);
++		start_line = 0;
++		end_line = par->info->var.yres - 1;
++	}
++
++	fbtft_par_dbg(DEBUG_UPDATE_DISPLAY, par, "%s(start_line=%u, end_line=%u)\n",
++		__func__, start_line, end_line);
++
++	if (par->fbtftops.set_addr_win)
++		par->fbtftops.set_addr_win(par, 0, start_line,
++				par->info->var.xres-1, end_line);
++
++	offset = start_line * par->info->fix.line_length;
++	len = (end_line - start_line + 1) * par->info->fix.line_length;
++	ret = par->fbtftops.write_vmem(par, offset, len);
++	if (ret < 0)
++		dev_err(par->info->device,
++			"%s: write_vmem failed to update display buffer\n",
++			__func__);
++
++	if (unlikely(timeit)) {
++		getnstimeofday(&ts_end);
++		if (par->update_time.tv_nsec == 0 && par->update_time.tv_sec == 0) {
++			par->update_time.tv_sec = ts_start.tv_sec;
++			par->update_time.tv_nsec = ts_start.tv_nsec;
++		}
++		ts_fps = timespec_sub(ts_start, par->update_time);
++		par->update_time.tv_sec = ts_start.tv_sec;
++		par->update_time.tv_nsec = ts_start.tv_nsec;
++		fps_ms = (ts_fps.tv_sec * 1000) + ((ts_fps.tv_nsec / 1000000) % 1000);
++		fps_us = (ts_fps.tv_nsec / 1000) % 1000;
++		fps = fps_ms * 1000 + fps_us;
++		fps = fps ? 1000000 / fps : 0;
++
++		ts_duration = timespec_sub(ts_end, ts_start);
++		duration_ms = (ts_duration.tv_sec * 1000) + ((ts_duration.tv_nsec / 1000000) % 1000);
++		duration_us = (ts_duration.tv_nsec / 1000) % 1000;
++		throughput = duration_ms * 1000 + duration_us;
++		throughput = throughput ? (len * 1000) / throughput : 0;
++		throughput = throughput * 1000 / 1024;
++
++		dev_info(par->info->device,
++			"Display update: %ld kB/s (%ld.%.3ld ms), fps=%ld (%ld.%.3ld ms)\n",
++			throughput, duration_ms, duration_us,
++			fps, fps_ms, fps_us);
++		par->first_update_done = true;
++	}
++}
++
++
++void fbtft_mkdirty(struct fb_info *info, int y, int height)
++{
++	struct fbtft_par *par = info->par;
++	struct fb_deferred_io *fbdefio = info->fbdefio;
++
++	/* special case, needed ? */
++	if (y == -1) {
++		y = 0;
++		height = info->var.yres - 1;
++	}
++
++	/* Mark display lines/area as dirty */
++	spin_lock(&par->dirty_lock);
++	if (y < par->dirty_lines_start)
++		par->dirty_lines_start = y;
++	if (y + height - 1 > par->dirty_lines_end)
++		par->dirty_lines_end = y + height - 1;
++	spin_unlock(&par->dirty_lock);
++
++	/* Schedule deferred_io to update display (no-op if already on queue)*/
++	schedule_delayed_work(&info->deferred_work, fbdefio->delay);
++}
++
++void fbtft_deferred_io(struct fb_info *info, struct list_head *pagelist)
++{
++	struct fbtft_par *par = info->par;
++	unsigned dirty_lines_start, dirty_lines_end;
++	struct page *page;
++	unsigned long index;
++	unsigned y_low = 0, y_high = 0;
++	int count = 0;
++
++	spin_lock(&par->dirty_lock);
++	dirty_lines_start = par->dirty_lines_start;
++	dirty_lines_end = par->dirty_lines_end;
++	/* set display line markers as clean */
++	par->dirty_lines_start = par->info->var.yres - 1;
++	par->dirty_lines_end = 0;
++	spin_unlock(&par->dirty_lock);
++
++	/* Mark display lines as dirty */
++	list_for_each_entry(page, pagelist, lru) {
++		count++;
++		index = page->index << PAGE_SHIFT;
++		y_low = index / info->fix.line_length;
++		y_high = (index + PAGE_SIZE - 1) / info->fix.line_length;
++		fbtft_dev_dbg(DEBUG_DEFERRED_IO, par, info->device,
++			"page->index=%lu y_low=%d y_high=%d\n",
++			page->index, y_low, y_high);
++		if (y_high > info->var.yres - 1)
++			y_high = info->var.yres - 1;
++		if (y_low < dirty_lines_start)
++			dirty_lines_start = y_low;
++		if (y_high > dirty_lines_end)
++			dirty_lines_end = y_high;
++	}
++
++	par->fbtftops.update_display(info->par,
++					dirty_lines_start, dirty_lines_end);
++}
++
++
++void fbtft_fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
++{
++	struct fbtft_par *par = info->par;
++
++	fbtft_dev_dbg(DEBUG_FB_FILLRECT, par, info->dev,
++		"%s: dx=%d, dy=%d, width=%d, height=%d\n",
++		__func__, rect->dx, rect->dy, rect->width, rect->height);
++	sys_fillrect(info, rect);
++
++	par->fbtftops.mkdirty(info, rect->dy, rect->height);
++}
++
++void fbtft_fb_copyarea(struct fb_info *info, const struct fb_copyarea *area)
++{
++	struct fbtft_par *par = info->par;
++
++	fbtft_dev_dbg(DEBUG_FB_COPYAREA, par, info->dev,
++		"%s: dx=%d, dy=%d, width=%d, height=%d\n",
++		__func__,  area->dx, area->dy, area->width, area->height);
++	sys_copyarea(info, area);
++
++	par->fbtftops.mkdirty(info, area->dy, area->height);
++}
++
++void fbtft_fb_imageblit(struct fb_info *info, const struct fb_image *image)
++{
++	struct fbtft_par *par = info->par;
++
++	fbtft_dev_dbg(DEBUG_FB_IMAGEBLIT, par, info->dev,
++		"%s: dx=%d, dy=%d, width=%d, height=%d\n",
++		__func__,  image->dx, image->dy, image->width, image->height);
++	sys_imageblit(info, image);
++
++	par->fbtftops.mkdirty(info, image->dy, image->height);
++}
++
++ssize_t fbtft_fb_write(struct fb_info *info,
++			const char __user *buf, size_t count, loff_t *ppos)
++{
++	struct fbtft_par *par = info->par;
++	ssize_t res;
++
++	fbtft_dev_dbg(DEBUG_FB_WRITE, par, info->dev,
++		"%s: count=%zd, ppos=%llu\n", __func__,  count, *ppos);
++	res = fb_sys_write(info, buf, count, ppos);
++
++	/* TODO: only mark changed area
++	   update all for now */
++	par->fbtftops.mkdirty(info, -1, 0);
++
++	return res;
++}
++
++/* from pxafb.c */
++unsigned int chan_to_field(unsigned chan, struct fb_bitfield *bf)
++{
++	chan &= 0xffff;
++	chan >>= 16 - bf->length;
++	return chan << bf->offset;
++}
++
++int fbtft_fb_setcolreg(unsigned regno,
++			       unsigned red, unsigned green, unsigned blue,
++			       unsigned transp, struct fb_info *info)
++{
++	struct fbtft_par *par = info->par;
++	unsigned val;
++	int ret = 1;
++
++	fbtft_dev_dbg(DEBUG_FB_SETCOLREG, par, info->dev,
++		"%s(regno=%u, red=0x%X, green=0x%X, blue=0x%X, trans=0x%X)\n",
++		__func__, regno, red, green, blue, transp);
++
++	switch (info->fix.visual) {
++	case FB_VISUAL_TRUECOLOR:
++		if (regno < 16) {
++			u32 *pal = info->pseudo_palette;
++
++			val  = chan_to_field(red,   &info->var.red);
++			val |= chan_to_field(green, &info->var.green);
++			val |= chan_to_field(blue,  &info->var.blue);
++
++			pal[regno] = val;
++			ret = 0;
++		}
++		break;
++
++	}
++	return ret;
++}
++
++int fbtft_fb_blank(int blank, struct fb_info *info)
++{
++	struct fbtft_par *par = info->par;
++	int ret = -EINVAL;
++
++	fbtft_dev_dbg(DEBUG_FB_BLANK, par, info->dev, "%s(blank=%d)\n",
++		__func__, blank);
++
++	if (!par->fbtftops.blank)
++		return ret;
++
++	switch (blank) {
++	case FB_BLANK_POWERDOWN:
++	case FB_BLANK_VSYNC_SUSPEND:
++	case FB_BLANK_HSYNC_SUSPEND:
++	case FB_BLANK_NORMAL:
++		ret = par->fbtftops.blank(par, true);
++		break;
++	case FB_BLANK_UNBLANK:
++		ret = par->fbtftops.blank(par, false);
++		break;
++	}
++	return ret;
++}
++
++void fbtft_merge_fbtftops(struct fbtft_ops *dst, struct fbtft_ops *src)
++{
++	if (src->write)
++		dst->write = src->write;
++	if (src->read)
++		dst->read = src->read;
++	if (src->write_vmem)
++		dst->write_vmem = src->write_vmem;
++	if (src->write_register)
++		dst->write_register = src->write_register;
++	if (src->set_addr_win)
++		dst->set_addr_win = src->set_addr_win;
++	if (src->reset)
++		dst->reset = src->reset;
++	if (src->mkdirty)
++		dst->mkdirty = src->mkdirty;
++	if (src->update_display)
++		dst->update_display = src->update_display;
++	if (src->init_display)
++		dst->init_display = src->init_display;
++	if (src->blank)
++		dst->blank = src->blank;
++	if (src->request_gpios_match)
++		dst->request_gpios_match = src->request_gpios_match;
++	if (src->request_gpios)
++		dst->request_gpios = src->request_gpios;
++	if (src->free_gpios)
++		dst->free_gpios = src->free_gpios;
++	if (src->verify_gpios)
++		dst->verify_gpios = src->verify_gpios;
++	if (src->register_backlight)
++		dst->register_backlight = src->register_backlight;
++	if (src->unregister_backlight)
++		dst->unregister_backlight = src->unregister_backlight;
++	if (src->set_var)
++		dst->set_var = src->set_var;
++	if (src->set_gamma)
++		dst->set_gamma = src->set_gamma;
++}
++
++/**
++ * fbtft_framebuffer_alloc - creates a new frame buffer info structure
++ *
++ * @display: pointer to structure describing the display
++ * @dev: pointer to the device for this fb, this can be NULL
++ *
++ * Creates a new frame buffer info structure.
++ *
++ * Also creates and populates the following structures:
++ *   info->fbops
++ *   info->fbdefio
++ *   info->pseudo_palette
++ *   par->fbtftops
++ *   par->txbuf
++ *
++ * Returns the new structure, or NULL if an error occurred.
++ *
++ */
++struct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,
++					struct device *dev)
++{
++	struct fb_info *info;
++	struct fbtft_par *par;
++	struct fb_ops *fbops = NULL;
++	struct fb_deferred_io *fbdefio = NULL;
++	struct fbtft_platform_data *pdata = dev->platform_data;
++	u8 *vmem = NULL;
++	void *txbuf = NULL;
++	void *buf = NULL;
++	unsigned width;
++	unsigned height;
++	int txbuflen = display->txbuflen;
++	unsigned bpp = display->bpp;
++	unsigned fps = display->fps;
++	unsigned rotate = 0;
++	bool bgr = false;
++	u8 startbyte = 0;
++	int vmem_size;
++	int *init_sequence = display->init_sequence;
++	char *gamma = display->gamma;
++	unsigned long *gamma_curves = NULL;
++
++	/* sanity check */
++	if (display->gamma_num * display->gamma_len > FBTFT_GAMMA_MAX_VALUES_TOTAL) {
++		dev_err(dev,
++			"%s: FBTFT_GAMMA_MAX_VALUES_TOTAL=%d is exceeded\n",
++			__func__, FBTFT_GAMMA_MAX_VALUES_TOTAL);
++		return NULL;
++	}
++
++	/* defaults */
++	if (!fps)
++		fps = 20;
++	if (!bpp)
++		bpp = 16;
++
++	vmem_size = display->width*display->height*bpp/8;
++
++	/* platform_data override ? */
++	if (pdata) {
++		if (pdata->fps)
++			fps = pdata->fps;
++		if (pdata->txbuflen)
++			txbuflen = pdata->txbuflen;
++		rotate = pdata->rotate;
++		bgr = pdata->bgr;
++		startbyte = pdata->startbyte;
++		if (pdata->display.init_sequence)
++			init_sequence = pdata->display.init_sequence;
++		if (pdata->gamma)
++			gamma = pdata->gamma;
++		if (pdata->display.debug)
++			display->debug = pdata->display.debug;
++		if (pdata->display.backlight)
++			display->backlight = pdata->display.backlight;
++	}
++
++	display->debug |= debug;
++	fbtft_expand_debug_value(&display->debug);
++
++	switch (rotate) {
++	case 90:
++	case 270:
++		width =  display->height;
++		height = display->width;
++		break;
++	default:
++		width =  display->width;
++		height = display->height;
++	}
++
++	vmem = vzalloc(vmem_size);
++	if (!vmem)
++		goto alloc_fail;
++
++	fbops = kzalloc(sizeof(struct fb_ops), GFP_KERNEL);
++	if (!fbops)
++		goto alloc_fail;
++
++	fbdefio = kzalloc(sizeof(struct fb_deferred_io), GFP_KERNEL);
++	if (!fbdefio)
++		goto alloc_fail;
++
++	buf = kmalloc(128, GFP_KERNEL);
++	if (!buf)
++		goto alloc_fail;
++
++	if (display->gamma_num && display->gamma_len) {
++		gamma_curves = kzalloc(display->gamma_num * display->gamma_len * sizeof(gamma_curves[0]), GFP_KERNEL);
++		if (!gamma_curves)
++			goto alloc_fail;
++	}
++
++	info = framebuffer_alloc(sizeof(struct fbtft_par), dev);
++	if (!info)
++		goto alloc_fail;
++
++	info->screen_base = (u8 __force __iomem *)vmem;
++	info->fbops = fbops;
++	info->fbdefio = fbdefio;
++
++	fbops->owner        =      dev->driver->owner;
++	fbops->fb_read      =      fb_sys_read;
++	fbops->fb_write     =      fbtft_fb_write;
++	fbops->fb_fillrect  =      fbtft_fb_fillrect;
++	fbops->fb_copyarea  =      fbtft_fb_copyarea;
++	fbops->fb_imageblit =      fbtft_fb_imageblit;
++	fbops->fb_setcolreg =      fbtft_fb_setcolreg;
++	fbops->fb_blank     =      fbtft_fb_blank;
++
++	fbdefio->delay =           HZ/fps;
++	fbdefio->deferred_io =     fbtft_deferred_io;
++	fb_deferred_io_init(info);
++
++	strncpy(info->fix.id, dev->driver->name, 16);
++	info->fix.type =           FB_TYPE_PACKED_PIXELS;
++	info->fix.visual =         FB_VISUAL_TRUECOLOR;
++	info->fix.xpanstep =	   0;
++	info->fix.ypanstep =	   0;
++	info->fix.ywrapstep =	   0;
++	info->fix.line_length =    width*bpp/8;
++	info->fix.accel =          FB_ACCEL_NONE;
++	info->fix.smem_len =       vmem_size;
++
++	info->var.rotate =         rotate;
++	info->var.xres =           width;
++	info->var.yres =           height;
++	info->var.xres_virtual =   info->var.xres;
++	info->var.yres_virtual =   info->var.yres;
++	info->var.bits_per_pixel = bpp;
++	info->var.nonstd =         1;
++
++	/* RGB565 */
++	info->var.red.offset =     11;
++	info->var.red.length =     5;
++	info->var.green.offset =   5;
++	info->var.green.length =   6;
++	info->var.blue.offset =    0;
++	info->var.blue.length =    5;
++	info->var.transp.offset =  0;
++	info->var.transp.length =  0;
++
++	info->flags =              FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;
++
++	par = info->par;
++	par->info = info;
++	par->pdata = dev->platform_data;
++	par->debug = display->debug;
++	par->buf = buf;
++	spin_lock_init(&par->dirty_lock);
++	par->bgr = bgr;
++	par->startbyte = startbyte;
++	par->init_sequence = init_sequence;
++	par->gamma.curves = gamma_curves;
++	par->gamma.num_curves = display->gamma_num;
++	par->gamma.num_values = display->gamma_len;
++	mutex_init(&par->gamma.lock);
++	info->pseudo_palette = par->pseudo_palette;
++
++	if (par->gamma.curves && gamma)
++		fbtft_gamma_parse_str(par,
++			par->gamma.curves, gamma, strlen(gamma));
++
++	/* Transmit buffer */
++	if (txbuflen == -1)
++		txbuflen = vmem_size + 2; /* add in case startbyte is used */
++
++#ifdef __LITTLE_ENDIAN
++	if ((!txbuflen) && (bpp > 8))
++		txbuflen = PAGE_SIZE; /* need buffer for byteswapping */
++#endif
++
++	if (txbuflen > 0) {
++		if (dma) {
++			dev->coherent_dma_mask = ~0;
++			txbuf = dma_alloc_coherent(dev, txbuflen, &par->txbuf.dma, GFP_DMA);
++		} else {
++			txbuf = kmalloc(txbuflen, GFP_KERNEL);
++		}
++		if (!txbuf)
++			goto alloc_fail;
++		par->txbuf.buf = txbuf;
++		par->txbuf.len = txbuflen;
++	}
++
++	/* default fbtft operations */
++	par->fbtftops.write = fbtft_write_spi;
++	par->fbtftops.read = fbtft_read_spi;
++	par->fbtftops.write_vmem = fbtft_write_vmem16_bus8;
++	par->fbtftops.write_register = fbtft_write_reg8_bus8;
++	par->fbtftops.set_addr_win = fbtft_set_addr_win;
++	par->fbtftops.reset = fbtft_reset;
++	par->fbtftops.mkdirty = fbtft_mkdirty;
++	par->fbtftops.update_display = fbtft_update_display;
++	par->fbtftops.request_gpios = fbtft_request_gpios;
++	par->fbtftops.free_gpios = fbtft_free_gpios;
++	if (display->backlight)
++		par->fbtftops.register_backlight = fbtft_register_backlight;
++
++	/* use driver provided functions */
++	fbtft_merge_fbtftops(&par->fbtftops, &display->fbtftops);
++
++	return info;
++
++alloc_fail:
++	vfree(vmem);
++	kfree(buf);
++	kfree(fbops);
++	kfree(fbdefio);
++	kfree(gamma_curves);
++
++	return NULL;
++}
++EXPORT_SYMBOL(fbtft_framebuffer_alloc);
++
++/**
++ * fbtft_framebuffer_release - frees up all memory used by the framebuffer
++ *
++ * @info: frame buffer info structure
++ *
++ */
++void fbtft_framebuffer_release(struct fb_info *info)
++{
++	struct fbtft_par *par = info->par;
++
++	fb_deferred_io_cleanup(info);
++	vfree(info->screen_base);
++	if (par->txbuf.buf) {
++		if (par->txbuf.dma)
++			dma_free_coherent(info->device, par->txbuf.len, par->txbuf.buf, par->txbuf.dma);
++		else
++			kfree(par->txbuf.buf);
++	}
++	kfree(par->buf);
++	kfree(info->fbops);
++	kfree(info->fbdefio);
++	kfree(par->gamma.curves);
++	framebuffer_release(info);
++}
++EXPORT_SYMBOL(fbtft_framebuffer_release);
++
++/**
++ *	fbtft_register_framebuffer - registers a tft frame buffer device
++ *	@fb_info: frame buffer info structure
++ *
++ *  Sets SPI driverdata if needed
++ *  Requests needed gpios.
++ *  Initializes display
++ *  Updates display.
++ *	Registers a frame buffer device @fb_info.
++ *
++ *	Returns negative errno on error, or zero for success.
++ *
++ */
++int fbtft_register_framebuffer(struct fb_info *fb_info)
++{
++	int ret;
++	char text1[50] = "";
++	char text2[50] = "";
++	struct fbtft_par *par = fb_info->par;
++	struct spi_device *spi = par->spi;
++
++	/* sanity checks */
++	if (!par->fbtftops.init_display) {
++		dev_err(fb_info->device, "missing fbtftops.init_display()\n");
++		return -EINVAL;
++	}
++
++	if (spi)
++		spi_set_drvdata(spi, fb_info);
++	if (par->pdev)
++		platform_set_drvdata(par->pdev, fb_info);
++
++	ret = par->fbtftops.request_gpios(par);
++	if (ret < 0)
++		goto reg_fail;
++
++	if (par->fbtftops.verify_gpios) {
++		ret = par->fbtftops.verify_gpios(par);
++		if (ret < 0)
++			goto reg_fail;
++	}
++
++	ret = par->fbtftops.init_display(par);
++	if (ret < 0)
++		goto reg_fail;
++	if (par->fbtftops.set_var) {
++		ret = par->fbtftops.set_var(par);
++		if (ret < 0)
++			goto reg_fail;
++	}
++
++	/* update the entire display */
++	par->fbtftops.update_display(par, 0, par->info->var.yres - 1);
++
++	if (par->fbtftops.set_gamma && par->gamma.curves) {
++		ret = par->fbtftops.set_gamma(par, par->gamma.curves);
++		if (ret)
++			goto reg_fail;
++	}
++
++	if (par->fbtftops.register_backlight)
++		par->fbtftops.register_backlight(par);
++
++	ret = register_framebuffer(fb_info);
++	if (ret < 0)
++		goto reg_fail;
++
++	fbtft_sysfs_init(par);
++
++	if (par->txbuf.buf)
++		sprintf(text1, ", %d KiB %sbuffer memory",
++			par->txbuf.len >> 10, par->txbuf.dma ? "DMA " : "");
++	if (spi)
++		sprintf(text2, ", spi%d.%d at %d MHz", spi->master->bus_num,
++				spi->chip_select, spi->max_speed_hz/1000000);
++	dev_info(fb_info->dev,
++		"%s frame buffer, %dx%d, %d KiB video memory%s, fps=%lu%s\n",
++		fb_info->fix.id, fb_info->var.xres, fb_info->var.yres,
++		fb_info->fix.smem_len >> 10, text1,
++		HZ/fb_info->fbdefio->delay, text2);
++
++	/* Turn on backlight if available */
++	if (fb_info->bl_dev) {
++		fb_info->bl_dev->props.power = FB_BLANK_UNBLANK;
++		fb_info->bl_dev->ops->update_status(fb_info->bl_dev);
++	}
++
++	return 0;
++
++reg_fail:
++	if (par->fbtftops.unregister_backlight)
++		par->fbtftops.unregister_backlight(par);
++	if (spi)
++		spi_set_drvdata(spi, NULL);
++	if (par->pdev)
++		platform_set_drvdata(par->pdev, NULL);
++	par->fbtftops.free_gpios(par);
++
++	return ret;
++}
++EXPORT_SYMBOL(fbtft_register_framebuffer);
++
++/**
++ *	fbtft_unregister_framebuffer - releases a tft frame buffer device
++ *	@fb_info: frame buffer info structure
++ *
++ *  Frees SPI driverdata if needed
++ *  Frees gpios.
++ *	Unregisters frame buffer device.
++ *
++ */
++int fbtft_unregister_framebuffer(struct fb_info *fb_info)
++{
++	struct fbtft_par *par = fb_info->par;
++	struct spi_device *spi = par->spi;
++	int ret;
++
++	if (spi)
++		spi_set_drvdata(spi, NULL);
++	if (par->pdev)
++		platform_set_drvdata(par->pdev, NULL);
++	if (par->fbtftops.unregister_backlight)
++		par->fbtftops.unregister_backlight(par);
++	fbtft_sysfs_exit(par);
++	par->fbtftops.free_gpios(par);
++	ret = unregister_framebuffer(fb_info);
++	return ret;
++}
++EXPORT_SYMBOL(fbtft_unregister_framebuffer);
++
++/**
++ * fbtft_init_display() - Generic init_display() function
++ * @par: Driver data
++ *
++ * Uses par->init_sequence to do the initialization
++ *
++ * Return: 0 if successful, negative if error
++ */
++int fbtft_init_display(struct fbtft_par *par)
++{
++	int buf[64];
++	char msg[128];
++	char str[16];
++	int i = 0;
++	int j;
++
++	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
++
++	/* sanity check */
++	if (!par->init_sequence) {
++		dev_err(par->info->device,
++			"error: init_sequence is not set\n");
++		return -EINVAL;
++	}
++
++	/* make sure stop marker exists */
++	for (i = 0; i < FBTFT_MAX_INIT_SEQUENCE; i++)
++		if (par->init_sequence[i] == -3)
++			break;
++	if (i == FBTFT_MAX_INIT_SEQUENCE) {
++		dev_err(par->info->device,
++			"missing stop marker at end of init sequence\n");
++		return -EINVAL;
++	}
++
++	par->fbtftops.reset(par);
++	if (par->gpio.cs != -1)
++		gpio_set_value(par->gpio.cs, 0);  /* Activate chip */
++
++	i = 0;
++	while (i < FBTFT_MAX_INIT_SEQUENCE) {
++		if (par->init_sequence[i] == -3) {
++			/* done */
++			return 0;
++		}
++		if (par->init_sequence[i] >= 0) {
++			dev_err(par->info->device,
++				"missing delimiter at position %d\n", i);
++			return -EINVAL;
++		}
++		if (par->init_sequence[i+1] < 0) {
++			dev_err(par->info->device,
++				"missing value after delimiter %d at position %d\n",
++				par->init_sequence[i], i);
++			return -EINVAL;
++		}
++		switch (par->init_sequence[i]) {
++		case -1:
++			i++;
++			/* make debug message */
++			strcpy(msg, "");
++			j = i + 1;
++			while (par->init_sequence[j] >= 0) {
++				sprintf(str, "0x%02X ", par->init_sequence[j]);
++				strcat(msg, str);
++				j++;
++			}
++			fbtft_par_dbg(DEBUG_INIT_DISPLAY, par,
++				"init: write(0x%02X) %s\n",
++				par->init_sequence[i], msg);
++
++			/* Write */
++			j = 0;
++			while (par->init_sequence[i] >= 0) {
++				if (j > 63) {
++					dev_err(par->info->device,
++					"%s: Maximum register values exceeded\n",
++					__func__);
++					return -EINVAL;
++				}
++				buf[j++] = par->init_sequence[i++];
++			}
++			par->fbtftops.write_register(par, j,
++				buf[0], buf[1], buf[2], buf[3],
++				buf[4], buf[5], buf[6], buf[7],
++				buf[8], buf[9], buf[10], buf[11],
++				buf[12], buf[13], buf[14], buf[15],
++				buf[16], buf[17], buf[18], buf[19],
++				buf[20], buf[21], buf[22], buf[23],
++				buf[24], buf[25], buf[26], buf[27],
++				buf[28], buf[29], buf[30], buf[31],
++				buf[32], buf[33], buf[34], buf[35],
++				buf[36], buf[37], buf[38], buf[39],
++				buf[40], buf[41], buf[42], buf[43],
++				buf[44], buf[45], buf[46], buf[47],
++				buf[48], buf[49], buf[50], buf[51],
++				buf[52], buf[53], buf[54], buf[55],
++				buf[56], buf[57], buf[58], buf[59],
++				buf[60], buf[61], buf[62], buf[63]);
++			break;
++		case -2:
++			i++;
++			fbtft_par_dbg(DEBUG_INIT_DISPLAY, par,
++				"init: mdelay(%d)\n", par->init_sequence[i]);
++			mdelay(par->init_sequence[i++]);
++			break;
++		default:
++			dev_err(par->info->device,
++				"unknown delimiter %d at position %d\n",
++				par->init_sequence[i], i);
++			return -EINVAL;
++		}
++	}
++
++	dev_err(par->info->device,
++		"%s: something is wrong. Shouldn't get here.\n", __func__);
++	return -EINVAL;
++}
++EXPORT_SYMBOL(fbtft_init_display);
++
++/**
++ * fbtft_verify_gpios() - Generic verify_gpios() function
++ * @par: Driver data
++ *
++ * Uses @spi, @pdev and @buswidth to determine which GPIOs is needed
++ *
++ * Return: 0 if successful, negative if error
++ */
++int fbtft_verify_gpios(struct fbtft_par *par)
++{
++	struct fbtft_platform_data *pdata;
++	int i;
++
++	fbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, "%s()\n", __func__);
++
++	pdata = par->info->device->platform_data;
++	if (!pdata) {
++		dev_warn(par->info->device,
++			"%s(): buswidth value is not available\n", __func__);
++		return 0;
++	}
++
++	if (pdata->display.buswidth != 9 && par->startbyte == 0 && \
++							par->gpio.dc < 0) {
++		dev_err(par->info->device,
++			"Missing info about 'dc' gpio. Aborting.\n");
++		return -EINVAL;
++	}
++
++	if (!par->pdev)
++		return 0;
++
++	if (par->gpio.wr < 0) {
++		dev_err(par->info->device, "Missing 'wr' gpio. Aborting.\n");
++		return -EINVAL;
++	}
++	for (i = 0; i < pdata->display.buswidth; i++) {
++		if (par->gpio.db[i] < 0) {
++			dev_err(par->info->device,
++				"Missing 'db%02d' gpio. Aborting.\n", i);
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++/**
++ * fbtft_probe_common() - Generic device probe() helper function
++ * @display: Display properties
++ * @sdev: SPI device
++ * @pdev: Platform device
++ *
++ * Allocates, initializes and registers a framebuffer
++ *
++ * Either @sdev or @pdev should be NULL
++ *
++ * Return: 0 if successful, negative if error
++ */
++int fbtft_probe_common(struct fbtft_display *display,
++			struct spi_device *sdev, struct platform_device *pdev)
++{
++	struct device *dev;
++	struct fb_info *info;
++	struct fbtft_par *par;
++	struct fbtft_platform_data *pdata;
++	int ret;
++
++	if (sdev)
++		dev = &sdev->dev;
++	else
++		dev = &pdev->dev;
++
++	if (unlikely(display->debug & DEBUG_DRIVER_INIT_FUNCTIONS))
++		dev_info(dev, "%s()\n", __func__);
++
++	pdata = dev->platform_data;
++	if (pdata) {
++		if (pdata->display.width)
++			display->width = pdata->display.width;
++		if (pdata->display.height)
++			display->height = pdata->display.height;
++		if (pdata->display.buswidth)
++			display->buswidth = pdata->display.buswidth;
++	}
++
++	info = fbtft_framebuffer_alloc(display, dev);
++	if (!info)
++		return -ENOMEM;
++
++	par = info->par;
++	if (sdev)
++		par->spi = sdev;
++	else
++		par->pdev = pdev;
++
++	/* write register functions */
++	if (display->regwidth == 8 && display->buswidth == 8) {
++		par->fbtftops.write_register = fbtft_write_reg8_bus8;
++	} else
++	if (display->regwidth == 8 && display->buswidth == 9 && par->spi) {
++		par->fbtftops.write_register = fbtft_write_reg8_bus9;
++	} else if (display->regwidth == 16 && display->buswidth == 8) {
++		par->fbtftops.write_register = fbtft_write_reg16_bus8;
++	} else if (display->regwidth == 16 && display->buswidth == 16) {
++		par->fbtftops.write_register = fbtft_write_reg16_bus16;
++	} else {
++		dev_warn(dev,
++			"no default functions for regwidth=%d and buswidth=%d\n",
++			display->regwidth, display->buswidth);
++	}
++
++	/* write_vmem() functions */
++	if (display->buswidth == 8)
++		par->fbtftops.write_vmem = fbtft_write_vmem16_bus8;
++	else if (display->buswidth == 9)
++		par->fbtftops.write_vmem = fbtft_write_vmem16_bus9;
++	else if (display->buswidth == 16)
++		par->fbtftops.write_vmem = fbtft_write_vmem16_bus16;
++
++	/* GPIO write() functions */
++	if (par->pdev) {
++		if (display->buswidth == 8)
++			par->fbtftops.write = fbtft_write_gpio8_wr;
++		else if (display->buswidth == 16)
++			par->fbtftops.write = fbtft_write_gpio16_wr;
++	}
++
++	/* 9-bit SPI setup */
++	if (par->spi && display->buswidth == 9) {
++		par->spi->bits_per_word = 9;
++		ret = par->spi->master->setup(par->spi);
++		if (ret) {
++			dev_warn(&par->spi->dev,
++				"9-bit SPI not available, emulating using 8-bit.\n");
++			par->spi->bits_per_word = 8;
++			ret = par->spi->master->setup(par->spi);
++			if (ret)
++				goto out_release;
++			/* allocate buffer with room for dc bits */
++			par->extra = kmalloc(
++				par->txbuf.len + (par->txbuf.len / 8) + 8,
++				GFP_KERNEL);
++			if (!par->extra) {
++				ret = -ENOMEM;
++				goto out_release;
++			}
++			par->fbtftops.write = fbtft_write_spi_emulate_9;
++		}
++	}
++
++	if (!par->fbtftops.verify_gpios)
++		par->fbtftops.verify_gpios = fbtft_verify_gpios;
++
++	/* make sure we still use the driver provided functions */
++	fbtft_merge_fbtftops(&par->fbtftops, &display->fbtftops);
++
++	/* use init_sequence if provided */
++	if (par->init_sequence)
++		par->fbtftops.init_display = fbtft_init_display;
++
++	/* use platform_data provided functions above all */
++	if (pdata)
++		fbtft_merge_fbtftops(&par->fbtftops, &pdata->display.fbtftops);
++
++	ret = fbtft_register_framebuffer(info);
++	if (ret < 0)
++		goto out_release;
++
++	return 0;
++
++out_release:
++	fbtft_framebuffer_release(info);
++
++	return ret;
++}
++EXPORT_SYMBOL(fbtft_probe_common);
++
++/**
++ * fbtft_remove_common() - Generic device remove() helper function
++ * @dev: Device
++ * @info: Framebuffer
++ *
++ * Unregisters and releases the framebuffer
++ *
++ * Return: 0 if successful, negative if error
++ */
++int fbtft_remove_common(struct device *dev, struct fb_info *info)
++{
++	struct fbtft_par *par;
++
++	if (!info)
++		return -EINVAL;
++	par = info->par;
++	if (par) {
++		fbtft_par_dbg(DEBUG_DRIVER_INIT_FUNCTIONS, par,
++			"%s()\n", __func__);
++		if (par->extra)
++			kfree(par->extra);
++	}
++	fbtft_unregister_framebuffer(info);
++	fbtft_framebuffer_release(info);
++
++	return 0;
++}
++EXPORT_SYMBOL(fbtft_remove_common);
++
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/fbtft-io.c b/drivers/video/fbtft/fbtft-io.c
+new file mode 100644
+index 0000000..dfa2c46
+--- /dev/null
++++ b/drivers/video/fbtft/fbtft-io.c
+@@ -0,0 +1,409 @@
++#include <linux/export.h>
++#include <linux/errno.h>
++#include <linux/gpio.h>
++#include <linux/spi/spi.h>
++#ifdef CONFIG_ARCH_BCM2708
++#include <mach/platform.h>
++#endif
++#include "fbtft.h"
++
++int fbtft_write_spi(struct fbtft_par *par, void *buf, size_t len)
++{
++	struct spi_transfer t = {
++		.tx_buf = buf,
++		.len = len,
++	};
++	struct spi_message m;
++
++	fbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,
++		"%s(len=%d): ", __func__, len);
++
++	if (!par->spi) {
++		dev_err(par->info->device,
++			"%s: par->spi is unexpectedly NULL\n", __func__);
++		return -1;
++	}
++
++	spi_message_init(&m);
++	if (par->txbuf.dma && buf == par->txbuf.buf) {
++		t.tx_dma = par->txbuf.dma;
++		m.is_dma_mapped = 1;
++	}
++	spi_message_add_tail(&t, &m);
++	return spi_sync(par->spi, &m);
++}
++EXPORT_SYMBOL(fbtft_write_spi);
++
++/**
++ * fbtft_write_spi_emulate_9() - write SPI emulating 9-bit
++ * @par: Driver data
++ * @buf: Buffer to write
++ * @len: Length of buffer (must be divisible by 8)
++ *
++ * When 9-bit SPI is not available, this function can be used to emulate that.
++ * par->extra must hold a transformation buffer used for transfer.
++ */
++int fbtft_write_spi_emulate_9(struct fbtft_par *par, void *buf, size_t len)
++{
++	u16 *src = buf;
++	u8 *dst = par->extra;
++	size_t size = len / 2;
++	size_t added = 0;
++	int bits, i, j;
++	u64 val, dc, tmp;
++
++	fbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,
++		"%s(len=%d): ", __func__, len);
++
++	if (!par->extra) {
++		dev_err(par->info->device, "%s: error: par->extra is NULL\n",
++			__func__);
++		return -EINVAL;
++	}
++	if ((len % 8) != 0) {
++		dev_err(par->info->device,
++			"%s: error: len=%d must be divisible by 8\n",
++			__func__, len);
++		return -EINVAL;
++	}
++
++	for (i = 0; i < size; i += 8) {
++		tmp = 0;
++		bits = 63;
++		for (j = 0; j < 7; j++) {
++			dc = (*src & 0x0100) ? 1 : 0;
++			val = *src & 0x00FF;
++			tmp |= dc << bits;
++			bits -= 8;
++			tmp |= val << bits--;
++			src++;
++		}
++		tmp |= ((*src & 0x0100) ? 1 : 0);
++		*(u64 *)dst = cpu_to_be64(tmp);
++		dst += 8;
++		*dst++ = (u8)(*src++ & 0x00FF);
++		added++;
++	}
++
++	return spi_write(par->spi, par->extra, size + added);
++}
++EXPORT_SYMBOL(fbtft_write_spi_emulate_9);
++
++int fbtft_read_spi(struct fbtft_par *par, void *buf, size_t len)
++{
++	int ret;
++	u8 txbuf[32] = { 0, };
++	struct spi_transfer	t = {
++			.speed_hz = 2000000,
++			.rx_buf		= buf,
++			.len		= len,
++		};
++	struct spi_message	m;
++
++	if (!par->spi) {
++		dev_err(par->info->device,
++			"%s: par->spi is unexpectedly NULL\n", __func__);
++		return -ENODEV;
++	}
++
++	if (par->startbyte) {
++		if (len > 32) {
++			dev_err(par->info->device,
++				"%s: len=%d can't be larger than 32 when using 'startbyte'\n",
++				__func__, len);
++			return -EINVAL;
++		}
++		txbuf[0] = par->startbyte | 0x3;
++		t.tx_buf = txbuf;
++		fbtft_par_dbg_hex(DEBUG_READ, par, par->info->device, u8,
++			txbuf, len, "%s(len=%d) txbuf => ", __func__, len);
++	}
++
++	spi_message_init(&m);
++	spi_message_add_tail(&t, &m);
++	ret = spi_sync(par->spi, &m);
++	fbtft_par_dbg_hex(DEBUG_READ, par, par->info->device, u8, buf, len,
++		"%s(len=%d) buf <= ", __func__, len);
++
++	return ret;
++}
++EXPORT_SYMBOL(fbtft_read_spi);
++
++
++#ifdef CONFIG_ARCH_BCM2708
++
++/*
++ *  Raspberry Pi
++ *  -  writing directly to the registers is 40-50% faster than
++ *     optimized use of gpiolib
++ */
++
++#define GPIOSET(no, ishigh)           \
++do {                                  \
++	if (ishigh)                   \
++		set |= (1 << (no));   \
++	else                          \
++		reset |= (1 << (no)); \
++} while (0)
++
++int fbtft_write_gpio8_wr(struct fbtft_par *par, void *buf, size_t len)
++{
++	unsigned int set = 0;
++	unsigned int reset = 0;
++	u8 data;
++
++	fbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,
++		"%s(len=%d): ", __func__, len);
++
++	while (len--) {
++		data = *(u8 *) buf;
++		buf++;
++
++		/* Set data */
++		GPIOSET(par->gpio.db[0], (data&0x01));
++		GPIOSET(par->gpio.db[1], (data&0x02));
++		GPIOSET(par->gpio.db[2], (data&0x04));
++		GPIOSET(par->gpio.db[3], (data&0x08));
++		GPIOSET(par->gpio.db[4], (data&0x10));
++		GPIOSET(par->gpio.db[5], (data&0x20));
++		GPIOSET(par->gpio.db[6], (data&0x40));
++		GPIOSET(par->gpio.db[7], (data&0x80));
++		writel(set, __io_address(GPIO_BASE+0x1C));
++		writel(reset, __io_address(GPIO_BASE+0x28));
++
++		/* Pulse /WR low */
++		writel((1<<par->gpio.wr),  __io_address(GPIO_BASE+0x28));
++		writel(0,  __io_address(GPIO_BASE+0x28)); /* used as a delay */
++		writel((1<<par->gpio.wr),  __io_address(GPIO_BASE+0x1C));
++
++		set = 0;
++		reset = 0;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(fbtft_write_gpio8_wr);
++
++int fbtft_write_gpio16_wr(struct fbtft_par *par, void *buf, size_t len)
++{
++	unsigned int set = 0;
++	unsigned int reset = 0;
++	u16 data;
++
++	fbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,
++		"%s(len=%d): ", __func__, len);
++
++	while (len) {
++		len -= 2;
++		data = *(u16 *) buf;
++		buf += 2;
++
++		/* Start writing by pulling down /WR */
++		gpio_set_value(par->gpio.wr, 0);
++
++		/* Set data */
++		GPIOSET(par->gpio.db[0],  (data&0x0001));
++		GPIOSET(par->gpio.db[1],  (data&0x0002));
++		GPIOSET(par->gpio.db[2],  (data&0x0004));
++		GPIOSET(par->gpio.db[3],  (data&0x0008));
++		GPIOSET(par->gpio.db[4],  (data&0x0010));
++		GPIOSET(par->gpio.db[5],  (data&0x0020));
++		GPIOSET(par->gpio.db[6],  (data&0x0040));
++		GPIOSET(par->gpio.db[7],  (data&0x0080));
++
++		GPIOSET(par->gpio.db[8],  (data&0x0100));
++		GPIOSET(par->gpio.db[9],  (data&0x0200));
++		GPIOSET(par->gpio.db[10], (data&0x0400));
++		GPIOSET(par->gpio.db[11], (data&0x0800));
++		GPIOSET(par->gpio.db[12], (data&0x1000));
++		GPIOSET(par->gpio.db[13], (data&0x2000));
++		GPIOSET(par->gpio.db[14], (data&0x4000));
++		GPIOSET(par->gpio.db[15], (data&0x8000));
++
++		writel(set, __io_address(GPIO_BASE+0x1C));
++		writel(reset, __io_address(GPIO_BASE+0x28));
++
++		/* Pullup /WR */
++		gpio_set_value(par->gpio.wr, 1);
++
++		set = 0;
++		reset = 0;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(fbtft_write_gpio16_wr);
++
++int fbtft_write_gpio16_wr_latched(struct fbtft_par *par, void *buf, size_t len)
++{
++	unsigned int set = 0;
++	unsigned int reset = 0;
++	u16 data;
++
++	fbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,
++		"%s(len=%d): ", __func__, len);
++
++	while (len) {
++		len -= 2;
++		data = *(u16 *) buf;
++		buf += 2;
++
++		/* Start writing by pulling down /WR */
++		gpio_set_value(par->gpio.wr, 0);
++
++		/* Low byte */
++		GPIOSET(par->gpio.db[0],  (data&0x0001));
++		GPIOSET(par->gpio.db[1],  (data&0x0002));
++		GPIOSET(par->gpio.db[2],  (data&0x0004));
++		GPIOSET(par->gpio.db[3],  (data&0x0008));
++		GPIOSET(par->gpio.db[4],  (data&0x0010));
++		GPIOSET(par->gpio.db[5],  (data&0x0020));
++		GPIOSET(par->gpio.db[6],  (data&0x0040));
++		GPIOSET(par->gpio.db[7],  (data&0x0080));
++		writel(set, __io_address(GPIO_BASE+0x1C));
++		writel(reset, __io_address(GPIO_BASE+0x28));
++
++		/* Pulse 'latch' high */
++		gpio_set_value(par->gpio.latch, 1);
++		gpio_set_value(par->gpio.latch, 0);
++
++		/* High byte */
++		GPIOSET(par->gpio.db[0], (data&0x0100));
++		GPIOSET(par->gpio.db[1], (data&0x0200));
++		GPIOSET(par->gpio.db[2], (data&0x0400));
++		GPIOSET(par->gpio.db[3], (data&0x0800));
++		GPIOSET(par->gpio.db[4], (data&0x1000));
++		GPIOSET(par->gpio.db[5], (data&0x2000));
++		GPIOSET(par->gpio.db[6], (data&0x4000));
++		GPIOSET(par->gpio.db[7], (data&0x8000));
++		writel(set, __io_address(GPIO_BASE+0x1C));
++		writel(reset, __io_address(GPIO_BASE+0x28));
++
++		/* Pullup /WR */
++		gpio_set_value(par->gpio.wr, 1);
++
++		set = 0;
++		reset = 0;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(fbtft_write_gpio16_wr_latched);
++
++#undef GPIOSET
++
++#else
++
++/*
++ * Optimized use of gpiolib is twice as fast as no optimization
++ * only one driver can use the optimized version at a time
++ */
++int fbtft_write_gpio8_wr(struct fbtft_par *par, void *buf, size_t len)
++{
++	u8 data;
++	int i;
++#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO
++	static u8 prev_data;
++#endif
++
++	fbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,
++		"%s(len=%d): ", __func__, len);
++
++	while (len--) {
++		data = *(u8 *) buf;
++
++		/* Start writing by pulling down /WR */
++		gpio_set_value(par->gpio.wr, 0);
++
++		/* Set data */
++#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO
++		if (data == prev_data) {
++			gpio_set_value(par->gpio.wr, 0); /* used as delay */
++		} else {
++			for (i = 0; i < 8; i++) {
++				if ((data & 1) != (prev_data & 1))
++					gpio_set_value(par->gpio.db[i],
++								(data & 1));
++				data >>= 1;
++				prev_data >>= 1;
++			}
++		}
++#else
++		for (i = 0; i < 8; i++) {
++			gpio_set_value(par->gpio.db[i], (data & 1));
++			data >>= 1;
++		}
++#endif
++
++		/* Pullup /WR */
++		gpio_set_value(par->gpio.wr, 1);
++
++#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO
++		prev_data = *(u8 *) buf;
++#endif
++		buf++;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(fbtft_write_gpio8_wr);
++
++int fbtft_write_gpio16_wr(struct fbtft_par *par, void *buf, size_t len)
++{
++	u16 data;
++	int i;
++#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO
++	static u16 prev_data;
++#endif
++
++	fbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,
++		"%s(len=%d): ", __func__, len);
++
++	while (len) {
++		data = *(u16 *) buf;
++
++		/* Start writing by pulling down /WR */
++		gpio_set_value(par->gpio.wr, 0);
++
++		/* Set data */
++#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO
++		if (data == prev_data) {
++			gpio_set_value(par->gpio.wr, 0); /* used as delay */
++		} else {
++			for (i = 0; i < 16; i++) {
++				if ((data & 1) != (prev_data & 1))
++					gpio_set_value(par->gpio.db[i],
++								(data & 1));
++				data >>= 1;
++				prev_data >>= 1;
++			}
++		}
++#else
++		for (i = 0; i < 16; i++) {
++			gpio_set_value(par->gpio.db[i], (data & 1));
++			data >>= 1;
++		}
++#endif
++
++		/* Pullup /WR */
++		gpio_set_value(par->gpio.wr, 1);
++
++#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO
++		prev_data = *(u16 *) buf;
++#endif
++		buf += 2;
++		len -= 2;
++	}
++
++	return 0;
++}
++EXPORT_SYMBOL(fbtft_write_gpio16_wr);
++
++int fbtft_write_gpio16_wr_latched(struct fbtft_par *par, void *buf, size_t len)
++{
++	dev_err(par->info->device, "%s: function not implemented\n", __func__);
++	return -1;
++}
++EXPORT_SYMBOL(fbtft_write_gpio16_wr_latched);
++
++#endif /* CONFIG_ARCH_BCM2708 */
+diff --git a/drivers/video/fbtft/fbtft-sysfs.c b/drivers/video/fbtft/fbtft-sysfs.c
+new file mode 100644
+index 0000000..fb88232
+--- /dev/null
++++ b/drivers/video/fbtft/fbtft-sysfs.c
+@@ -0,0 +1,222 @@
++#include "fbtft.h"
++
++
++static int get_next_ulong(char **str_p, unsigned long *val, char *sep, int base)
++{
++	char *p_val;
++	int ret;
++
++	if (!str_p || !(*str_p))
++		return -EINVAL;
++
++	p_val = strsep(str_p, sep);
++
++	if (!p_val)
++		return -EINVAL;
++
++	ret = kstrtoul(p_val, base, val);
++	if (ret)
++		return -EINVAL;
++
++	return 0;
++}
++
++int fbtft_gamma_parse_str(struct fbtft_par *par, unsigned long *curves,
++						const char *str, int size)
++{
++	char *str_p, *curve_p = NULL;
++	char *tmp;
++	unsigned long val = 0;
++	int ret = 0;
++	int curve_counter, value_counter;
++
++	fbtft_par_dbg(DEBUG_SYSFS, par, "%s() str=\n", __func__);
++
++	if (!str || !curves)
++		return -EINVAL;
++
++	fbtft_par_dbg(DEBUG_SYSFS, par, "%s\n", str);
++
++	tmp = kmalloc(size+1, GFP_KERNEL);
++	if (!tmp)
++		return -ENOMEM;
++	memcpy(tmp, str, size+1);
++
++	/* replace optional separators */
++	str_p = tmp;
++	while (*str_p) {
++		if (*str_p == ',')
++			*str_p = ' ';
++		if (*str_p == ';')
++			*str_p = '\n';
++		str_p++;
++	}
++
++	str_p = strim(tmp);
++
++	curve_counter = 0;
++	while (str_p) {
++		if (curve_counter == par->gamma.num_curves) {
++			dev_err(par->info->device, "Gamma: Too many curves\n");
++			ret = -EINVAL;
++			goto out;
++		}
++		curve_p = strsep(&str_p, "\n");
++		value_counter = 0;
++		while (curve_p) {
++			if (value_counter == par->gamma.num_values) {
++				dev_err(par->info->device,
++					"Gamma: Too many values\n");
++				ret = -EINVAL;
++				goto out;
++			}
++			ret = get_next_ulong(&curve_p, &val, " ", 16);
++			if (ret)
++				goto out;
++			curves[curve_counter * par->gamma.num_values + value_counter] = val;
++			value_counter++;
++		}
++		if (value_counter != par->gamma.num_values) {
++			dev_err(par->info->device, "Gamma: Too few values\n");
++			ret = -EINVAL;
++			goto out;
++		}
++		curve_counter++;
++	}
++	if (curve_counter != par->gamma.num_curves) {
++		dev_err(par->info->device, "Gamma: Too few curves\n");
++		ret = -EINVAL;
++		goto out;
++	}
++
++out:
++	kfree(tmp);
++	return ret;
++}
++
++static ssize_t
++sprintf_gamma(struct fbtft_par *par, unsigned long *curves, char *buf)
++{
++	ssize_t len = 0;
++	unsigned int i, j;
++
++	mutex_lock(&par->gamma.lock);
++	for (i = 0; i < par->gamma.num_curves; i++) {
++		for (j = 0; j < par->gamma.num_values; j++)
++			len += scnprintf(&buf[len], PAGE_SIZE,
++				"%04lx ", curves[i*par->gamma.num_values + j]);
++		buf[len-1] = '\n';
++	}
++	mutex_unlock(&par->gamma.lock);
++
++	return len;
++}
++
++static ssize_t store_gamma_curve(struct device *device,
++					struct device_attribute *attr,
++					const char *buf, size_t count)
++{
++	struct fb_info *fb_info = dev_get_drvdata(device);
++	struct fbtft_par *par = fb_info->par;
++	unsigned long tmp_curves[FBTFT_GAMMA_MAX_VALUES_TOTAL];
++	int ret;
++
++	ret = fbtft_gamma_parse_str(par, tmp_curves, buf, count);
++	if (ret)
++		return ret;
++
++	ret = par->fbtftops.set_gamma(par, tmp_curves);
++	if (ret)
++		return ret;
++
++	mutex_lock(&par->gamma.lock);
++	memcpy(par->gamma.curves, tmp_curves,
++		par->gamma.num_curves * par->gamma.num_values * sizeof(tmp_curves[0]));
++	mutex_unlock(&par->gamma.lock);
++
++	return count;
++}
++
++static ssize_t show_gamma_curve(struct device *device,
++				struct device_attribute *attr, char *buf)
++{
++	struct fb_info *fb_info = dev_get_drvdata(device);
++	struct fbtft_par *par = fb_info->par;
++
++	return sprintf_gamma(par, par->gamma.curves, buf);
++}
++
++static struct device_attribute gamma_device_attrs[] = {
++	__ATTR(gamma, S_IRUGO | S_IWUGO, show_gamma_curve, store_gamma_curve),
++};
++
++
++void fbtft_expand_debug_value(unsigned long *debug)
++{
++	switch (*debug & 0b111) {
++	case 1:
++		*debug |= DEBUG_LEVEL_1;
++		break;
++	case 2:
++		*debug |= DEBUG_LEVEL_2;
++		break;
++	case 3:
++		*debug |= DEBUG_LEVEL_3;
++		break;
++	case 4:
++		*debug |= DEBUG_LEVEL_4;
++		break;
++	case 5:
++		*debug |= DEBUG_LEVEL_5;
++		break;
++	case 6:
++		*debug |= DEBUG_LEVEL_6;
++		break;
++	case 7:
++		*debug = 0xFFFFFFFF;
++		break;
++	}
++}
++
++static ssize_t store_debug(struct device *device,
++				struct device_attribute *attr,
++				const char *buf, size_t count)
++{
++	struct fb_info *fb_info = dev_get_drvdata(device);
++	struct fbtft_par *par = fb_info->par;
++	int ret;
++
++	ret = kstrtoul(buf, 10, &par->debug);
++	if (ret)
++		return ret;
++	fbtft_expand_debug_value(&par->debug);
++
++	return count;
++}
++
++static ssize_t show_debug(struct device *device,
++				struct device_attribute *attr, char *buf)
++{
++	struct fb_info *fb_info = dev_get_drvdata(device);
++	struct fbtft_par *par = fb_info->par;
++
++	return snprintf(buf, PAGE_SIZE, "%lu\n", par->debug);
++}
++
++static struct device_attribute debug_device_attr = \
++	__ATTR(debug, S_IRUGO | S_IWUGO, show_debug, store_debug);
++
++
++void fbtft_sysfs_init(struct fbtft_par *par)
++{
++	device_create_file(par->info->dev, &debug_device_attr);
++	if (par->gamma.curves && par->fbtftops.set_gamma)
++		device_create_file(par->info->dev, &gamma_device_attrs[0]);
++}
++
++void fbtft_sysfs_exit(struct fbtft_par *par)
++{
++	device_remove_file(par->info->dev, &debug_device_attr);
++	if (par->gamma.curves && par->fbtftops.set_gamma)
++		device_remove_file(par->info->dev, &gamma_device_attrs[0]);
++}
+diff --git a/drivers/video/fbtft/fbtft.h b/drivers/video/fbtft/fbtft.h
+new file mode 100644
+index 0000000..2dffdb0
+--- /dev/null
++++ b/drivers/video/fbtft/fbtft.h
+@@ -0,0 +1,435 @@
++/*
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#ifndef __LINUX_FBTFT_H
++#define __LINUX_FBTFT_H
++
++#include <linux/fb.h>
++#include <linux/spinlock.h>
++#include <linux/spi/spi.h>
++#include <linux/platform_device.h>
++
++
++#define FBTFT_NOP		0x00
++#define FBTFT_SWRESET	0x01
++#define FBTFT_RDDID		0x04
++#define FBTFT_RDDST		0x09
++#define FBTFT_CASET		0x2A
++#define FBTFT_RASET		0x2B
++#define FBTFT_RAMWR		0x2C
++
++#define FBTFT_ONBOARD_BACKLIGHT 2
++
++#define FBTFT_GPIO_NO_MATCH		0xFFFF
++#define FBTFT_GPIO_NAME_SIZE	32
++#define FBTFT_MAX_INIT_SEQUENCE      512
++#define FBTFT_GAMMA_MAX_VALUES_TOTAL 128
++
++/**
++ * struct fbtft_gpio - Structure that holds one pinname to gpio mapping
++ * @name: pinname (reset, dc, etc.)
++ * @gpio: GPIO number
++ *
++ */
++struct fbtft_gpio {
++	char name[FBTFT_GPIO_NAME_SIZE];
++	unsigned gpio;
++};
++
++struct fbtft_par;
++
++/**
++ * struct fbtft_ops - FBTFT operations structure
++ * @write: Writes to interface bus
++ * @read: Reads from interface bus
++ * @write_vmem: Writes video memory to display
++ * @write_reg: Writes to controller register
++ * @set_addr_win: Set the GRAM update window
++ * @reset: Reset the LCD controller
++ * @mkdirty: Marks display lines for update
++ * @update_display: Updates the display
++ * @init_display: Initializes the display
++ * @blank: Blank the display (optional)
++ * @request_gpios_match: Do pinname to gpio matching
++ * @request_gpios: Request gpios from the kernel
++ * @free_gpios: Free previously requested gpios
++ * @verify_gpios: Verify that necessary gpios is present (optional)
++ * @register_backlight: Used to register backlight device (optional)
++ * @unregister_backlight: Unregister backlight device (optional)
++ * @set_var: Configure LCD with values from variables like @rotate and @bgr
++ *           (optional)
++ * @set_gamma: Set Gamma curve (optional)
++ *
++ * Most of these operations have default functions assigned to them in
++ *     fbtft_framebuffer_alloc()
++ */
++struct fbtft_ops {
++	int (*write)(struct fbtft_par *par, void *buf, size_t len);
++	int (*read)(struct fbtft_par *par, void *buf, size_t len);
++	int (*write_vmem)(struct fbtft_par *par, size_t offset, size_t len);
++	void (*write_register)(struct fbtft_par *par, int len, ...);
++
++	void (*set_addr_win)(struct fbtft_par *par,
++		int xs, int ys, int xe, int ye);
++	void (*reset)(struct fbtft_par *par);
++	void (*mkdirty)(struct fb_info *info, int from, int to);
++	void (*update_display)(struct fbtft_par *par,
++				unsigned start_line, unsigned end_line);
++	int (*init_display)(struct fbtft_par *par);
++	int (*blank)(struct fbtft_par *par, bool on);
++
++	unsigned long (*request_gpios_match)(struct fbtft_par *par,
++		const struct fbtft_gpio *gpio);
++	int (*request_gpios)(struct fbtft_par *par);
++	void (*free_gpios)(struct fbtft_par *par);
++	int (*verify_gpios)(struct fbtft_par *par);
++
++	void (*register_backlight)(struct fbtft_par *par);
++	void (*unregister_backlight)(struct fbtft_par *par);
++
++	int (*set_var)(struct fbtft_par *par);
++	int (*set_gamma)(struct fbtft_par *par, unsigned long *curves);
++};
++
++/**
++ * struct fbtft_display - Describes the display properties
++ * @width: Width of display in pixels
++ * @height: Height of display in pixels
++ * @regwidth: LCD Controller Register width in bits
++ * @buswidth: Display interface bus width in bits
++ * @backlight: Backlight type.
++ * @fbtftops: FBTFT operations provided by driver or device (platform_data)
++ * @bpp: Bits per pixel
++ * @fps: Frames per second
++ * @txbuflen: Size of transmit buffer
++ * @init_sequence: Pointer to LCD initialization array
++ * @gamma: String representation of Gamma curve(s)
++ * @gamma_num: Number of Gamma curves
++ * @gamma_len: Number of values per Gamma curve
++ * @debug: Initial debug value
++ *
++ * This structure is not stored by FBTFT except for init_sequence.
++ */
++struct fbtft_display {
++	unsigned width;
++	unsigned height;
++	unsigned regwidth;
++	unsigned buswidth;
++	unsigned backlight;
++	struct fbtft_ops fbtftops;
++	unsigned bpp;
++	unsigned fps;
++	int txbuflen;
++	int *init_sequence;
++	char *gamma;
++	int gamma_num;
++	int gamma_len;
++	unsigned long debug;
++};
++
++/**
++ * struct fbtft_platform_data - Passes display specific data to the driver
++ * @display: Display properties
++ * @gpios: Pointer to an array of piname to gpio mappings
++ * @rotate: Display rotation angle
++ * @bgr: LCD Controller BGR bit
++ * @fps: Frames per second (this will go away, use @fps in @fbtft_display)
++ * @txbuflen: Size of transmit buffer
++ * @startbyte: When set, enables use of Startbyte in transfers
++ * @gamma: String representation of Gamma curve(s)
++ * @extra: A way to pass extra info
++ */
++struct fbtft_platform_data {
++	struct fbtft_display display;
++	const struct fbtft_gpio *gpios;
++	unsigned rotate;
++	bool bgr;
++	unsigned fps;
++	int txbuflen;
++	u8 startbyte;
++	char *gamma;
++	void *extra;
++};
++
++/**
++ * struct fbtft_par - Main FBTFT data structure
++ *
++ * This structure holds all relevant data to operate the display
++ *
++ * See sourcefile for documentation since nested structs is not
++ * supported by kernel-doc.
++ *
++ */
++/* @spi: Set if it is a SPI device
++ * @pdev: Set if it is a platform device
++ * @info: Pointer to framebuffer fb_info structure
++ * @pdata: Pointer to platform data
++ * @ssbuf: Not used
++ * @pseudo_palette: Used by fb_set_colreg()
++ * @txbuf.buf: Transmit buffer
++ * @txbuf.len: Transmit buffer length
++ * @buf: Small buffer used when writing init data over SPI
++ * @startbyte: Used by some controllers when in SPI mode.
++ *             Format: 6 bit Device id + RS bit + RW bit
++ * @fbtftops: FBTFT operations provided by driver or device (platform_data)
++ * @dirty_lock: Protects dirty_lines_start and dirty_lines_end
++ * @dirty_lines_start: Where to begin updating display
++ * @dirty_lines_end: Where to end updating display
++ * @gpio.reset: GPIO used to reset display
++ * @gpio.dc: Data/Command signal, also known as RS
++ * @gpio.rd: Read latching signal
++ * @gpio.wr: Write latching signal
++ * @gpio.latch: Bus latch signal, eg. 16->8 bit bus latch
++ * @gpio.cs: LCD Chip Select with parallel interface bus
++ * @gpio.db[16]: Parallel databus
++ * @gpio.led[16]: Led control signals
++ * @gpio.aux[16]: Auxillary signals, not used by core
++ * @init_sequence: Pointer to LCD initialization array
++ * @gamma.lock: Mutex for Gamma curve locking
++ * @gamma.curves: Pointer to Gamma curve array
++ * @gamma.num_values: Number of values per Gamma curve
++ * @gamma.num_curves: Number of Gamma curves
++ * @debug: Pointer to debug value
++ * @current_debug:
++ * @first_update_done: Used to only time the first display update
++ * @update_time: Used to calculate 'fps' in debug output
++ * @bgr: BGR mode/\n
++ * @extra: Extra info needed by driver
++ */
++struct fbtft_par {
++	struct spi_device *spi;
++	struct platform_device *pdev;
++	struct fb_info *info;
++	struct fbtft_platform_data *pdata;
++	u16 *ssbuf;
++	u32 pseudo_palette[16];
++	struct {
++		void *buf;
++		dma_addr_t dma;
++		size_t len;
++	} txbuf;
++	u8 *buf;
++	u8 startbyte;
++	struct fbtft_ops fbtftops;
++	spinlock_t dirty_lock;
++	unsigned dirty_lines_start;
++	unsigned dirty_lines_end;
++	struct {
++		int reset;
++		int dc;
++		int rd;
++		int wr;
++		int latch;
++		int cs;
++		int db[16];
++		int led[16];
++		int aux[16];
++	} gpio;
++	int *init_sequence;
++	struct {
++		struct mutex lock;
++		unsigned long *curves;
++		int num_values;
++		int num_curves;
++	} gamma;
++	unsigned long debug;
++	bool first_update_done;
++	struct timespec update_time;
++	bool bgr;
++	void *extra;
++};
++
++#define NUMARGS(...)  (sizeof((int[]){__VA_ARGS__})/sizeof(int))
++
++#define write_reg(par, ...)                                              \
++do {                                                                     \
++	par->fbtftops.write_register(par, NUMARGS(__VA_ARGS__), __VA_ARGS__); \
++} while (0)
++
++/* fbtft-core.c */
++extern void fbtft_dbg_hex(const struct device *dev,
++	int groupsize, void *buf, size_t len, const char *fmt, ...);
++extern struct fb_info *fbtft_framebuffer_alloc(struct fbtft_display *display,
++	struct device *dev);
++extern void fbtft_framebuffer_release(struct fb_info *info);
++extern int fbtft_register_framebuffer(struct fb_info *fb_info);
++extern int fbtft_unregister_framebuffer(struct fb_info *fb_info);
++extern void fbtft_register_backlight(struct fbtft_par *par);
++extern void fbtft_unregister_backlight(struct fbtft_par *par);
++extern int fbtft_init_display(struct fbtft_par *par);
++extern int fbtft_probe_common(struct fbtft_display *display,
++	struct spi_device *sdev, struct platform_device *pdev);
++extern int fbtft_remove_common(struct device *dev, struct fb_info *info);
++
++/* fbtft-io.c */
++extern int fbtft_write_spi(struct fbtft_par *par, void *buf, size_t len);
++extern int fbtft_write_spi_emulate_9(struct fbtft_par *par,
++	void *buf, size_t len);
++extern int fbtft_read_spi(struct fbtft_par *par, void *buf, size_t len);
++extern int fbtft_write_gpio8_wr(struct fbtft_par *par, void *buf, size_t len);
++extern int fbtft_write_gpio16_wr(struct fbtft_par *par, void *buf, size_t len);
++extern int fbtft_write_gpio16_wr_latched(struct fbtft_par *par,
++	void *buf, size_t len);
++
++/* fbtft-bus.c */
++extern int fbtft_write_vmem8_bus8(struct fbtft_par *par, size_t offset, size_t len);
++extern int fbtft_write_vmem16_bus16(struct fbtft_par *par, size_t offset, size_t len);
++extern int fbtft_write_vmem16_bus8(struct fbtft_par *par, size_t offset, size_t len);
++extern int fbtft_write_vmem16_bus9(struct fbtft_par *par, size_t offset, size_t len);
++extern void fbtft_write_reg8_bus8(struct fbtft_par *par, int len, ...);
++extern void fbtft_write_reg8_bus9(struct fbtft_par *par, int len, ...);
++extern void fbtft_write_reg16_bus8(struct fbtft_par *par, int len, ...);
++extern void fbtft_write_reg16_bus16(struct fbtft_par *par, int len, ...);
++
++
++#define FBTFT_REGISTER_DRIVER(_name, _display)                             \
++									   \
++static int fbtft_driver_probe_spi(struct spi_device *spi)                  \
++{                                                                          \
++	return fbtft_probe_common(_display, spi, NULL);                    \
++}                                                                          \
++									   \
++static int fbtft_driver_remove_spi(struct spi_device *spi)                 \
++{                                                                          \
++	struct fb_info *info = spi_get_drvdata(spi);                       \
++									   \
++	return fbtft_remove_common(&spi->dev, info);                       \
++}                                                                          \
++									   \
++static int fbtft_driver_probe_pdev(struct platform_device *pdev)           \
++{                                                                          \
++	return fbtft_probe_common(_display, NULL, pdev);                   \
++}                                                                          \
++									   \
++static int fbtft_driver_remove_pdev(struct platform_device *pdev)          \
++{                                                                          \
++	struct fb_info *info = platform_get_drvdata(pdev);                 \
++									   \
++	return fbtft_remove_common(&pdev->dev, info);                      \
++}                                                                          \
++									   \
++static struct spi_driver fbtft_driver_spi_driver = {                       \
++	.driver = {                                                        \
++		.name   = _name,                                           \
++		.owner  = THIS_MODULE,                                     \
++	},                                                                 \
++	.probe  = fbtft_driver_probe_spi,                                  \
++	.remove = fbtft_driver_remove_spi,                                 \
++};                                                                         \
++									   \
++static struct platform_driver fbtft_driver_platform_driver = {             \
++	.driver = {                                                        \
++		.name   = _name,                                           \
++		.owner  = THIS_MODULE,                                     \
++	},                                                                 \
++	.probe  = fbtft_driver_probe_pdev,                                 \
++	.remove = fbtft_driver_remove_pdev,                                \
++};                                                                         \
++									   \
++static int __init fbtft_driver_module_init(void)                           \
++{                                                                          \
++	int ret;                                                           \
++									   \
++	ret = spi_register_driver(&fbtft_driver_spi_driver);               \
++	if (ret < 0)                                                       \
++		return ret;                                                \
++	return platform_driver_register(&fbtft_driver_platform_driver);    \
++}                                                                          \
++									   \
++static void __exit fbtft_driver_module_exit(void)                          \
++{                                                                          \
++	spi_unregister_driver(&fbtft_driver_spi_driver);                   \
++	platform_driver_unregister(&fbtft_driver_platform_driver);         \
++}                                                                          \
++									   \
++module_init(fbtft_driver_module_init);                                     \
++module_exit(fbtft_driver_module_exit);
++
++
++/* Debug macros */
++
++/* shorthand debug levels */
++#define DEBUG_LEVEL_1	DEBUG_REQUEST_GPIOS
++#define DEBUG_LEVEL_2	(DEBUG_LEVEL_1 | DEBUG_DRIVER_INIT_FUNCTIONS | DEBUG_TIME_FIRST_UPDATE)
++#define DEBUG_LEVEL_3	(DEBUG_LEVEL_2 | DEBUG_RESET | DEBUG_INIT_DISPLAY | DEBUG_BLANK | DEBUG_FREE_GPIOS | DEBUG_VERIFY_GPIOS | DEBUG_BACKLIGHT | DEBUG_SYSFS)
++#define DEBUG_LEVEL_4	(DEBUG_LEVEL_2 | DEBUG_FB_READ | DEBUG_FB_WRITE | DEBUG_FB_FILLRECT | DEBUG_FB_COPYAREA | DEBUG_FB_IMAGEBLIT | DEBUG_FB_BLANK)
++#define DEBUG_LEVEL_5	(DEBUG_LEVEL_3 | DEBUG_UPDATE_DISPLAY)
++#define DEBUG_LEVEL_6	(DEBUG_LEVEL_4 | DEBUG_LEVEL_5)
++#define DEBUG_LEVEL_7	0xFFFFFFFF
++
++#define DEBUG_DRIVER_INIT_FUNCTIONS (1<<3)
++#define DEBUG_TIME_FIRST_UPDATE     (1<<4)
++#define DEBUG_TIME_EACH_UPDATE      (1<<5)
++#define DEBUG_DEFERRED_IO           (1<<6)
++#define DEBUG_FBTFT_INIT_FUNCTIONS  (1<<7)
++
++/* fbops */
++#define DEBUG_FB_READ               (1<<8)
++#define DEBUG_FB_WRITE              (1<<9)
++#define DEBUG_FB_FILLRECT           (1<<10)
++#define DEBUG_FB_COPYAREA           (1<<11)
++#define DEBUG_FB_IMAGEBLIT          (1<<12)
++#define DEBUG_FB_SETCOLREG          (1<<13)
++#define DEBUG_FB_BLANK              (1<<14)
++
++#define DEBUG_SYSFS                 (1<<16)
++
++/* fbtftops */
++#define DEBUG_BACKLIGHT             (1<<17)
++#define DEBUG_READ                  (1<<18)
++#define DEBUG_WRITE                 (1<<19)
++#define DEBUG_WRITE_VMEM            (1<<20)
++#define DEBUG_WRITE_REGISTER        (1<<21)
++#define DEBUG_SET_ADDR_WIN          (1<<22)
++#define DEBUG_RESET                 (1<<23)
++#define DEBUG_MKDIRTY               (1<<24)
++#define DEBUG_UPDATE_DISPLAY        (1<<25)
++#define DEBUG_INIT_DISPLAY          (1<<26)
++#define DEBUG_BLANK                 (1<<27)
++#define DEBUG_REQUEST_GPIOS         (1<<28)
++#define DEBUG_FREE_GPIOS            (1<<29)
++#define DEBUG_REQUEST_GPIOS_MATCH   (1<<30)
++#define DEBUG_VERIFY_GPIOS          (1<<31)
++
++
++#define fbtft_init_dbg(dev, format, arg...)                  \
++do {                                                         \
++	if (unlikely((dev)->platform_data &&                 \
++	    (((struct fbtft_platform_data *)(dev)->platform_data)->display.debug & DEBUG_DRIVER_INIT_FUNCTIONS))) \
++		dev_info(dev, format, ##arg);                \
++} while (0)
++
++#define fbtft_par_dbg(level, par, format, arg...)            \
++do {                                                         \
++	if (unlikely(par->debug & level))                    \
++		dev_info(par->info->device, format, ##arg);  \
++} while (0)
++
++#define fbtft_dev_dbg(level, par, dev, format, arg...)       \
++do {                                                         \
++	if (unlikely(par->debug & level))                    \
++		dev_info(dev, format, ##arg);                \
++} while (0)
++
++#define fbtft_par_dbg_hex(level, par, dev, type, buf, num, format, arg...) \
++do {                                                                       \
++	if (unlikely(par->debug & level))                                  \
++		fbtft_dbg_hex(dev, sizeof(type), buf, num * sizeof(type), format, ##arg); \
++} while (0)
++
++#endif /* __LINUX_FBTFT_H */
+diff --git a/drivers/video/fbtft/fbtft_device.c b/drivers/video/fbtft/fbtft_device.c
+new file mode 100644
+index 0000000..689cb75
+--- /dev/null
++++ b/drivers/video/fbtft/fbtft_device.c
+@@ -0,0 +1,1255 @@
++/*
++ *
++ * Copyright (C) 2013, Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <asm/io.h>
++#include <linux/delay.h>
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/interrupt.h>
++#include <linux/gpio.h>
++#include <linux/spi/spi.h>
++#include <linux/mfd/stmpe.h>
++#include <mach/irqs.h>
++
++#include "fbtft.h"
++
++#define DRVNAME "fbtft_device"
++
++#define MAX_GPIOS 32
++
++#define BCM2708_PERI_BASE	0x20000000
++#define GPIO_BASE		(BCM2708_PERI_BASE + 0x200000)
++
++#define GPIO_REG(g) (gpio_reg + ((g / 10) * 4))
++#define GPIO_GPPUD (0x94)
++#define GPIO_GPCLK0 (0x98)
++#define GPIO_GPCLK(x) (GPIO_GPCLK0 + 4 * ((x) >> 5))
++#define SET_GPIO_ALT(g,a) \
++	__raw_writel(                                                       \
++		(((a) <= 3 ? (a) + 4:(a) == 4 ? 3 : 2)<<(((g) % 10) * 3))   \
++		| (__raw_readl(GPIO_REG(g)) & ( ~(7 << (((g) % 10) * 3)))), \
++		GPIO_REG(g))
++
++#define GPIO_PULL_SET(pin, val) \
++	do { \
++		__raw_writel((val) & 3, gpio_reg + GPIO_GPPUD); \
++		msleep(5); \
++		__raw_writel(1 << ((pin) & 31), gpio_reg + GPIO_GPCLK(pin)); \
++		msleep(5); \
++		__raw_writel(0, gpio_reg + GPIO_GPPUD); \
++		msleep(5); \
++		__raw_writel(0, gpio_reg + GPIO_GPCLK(pin)); \
++		msleep(5); \
++	} while(0);
++#define GPIO_PULL_COMMIT(x)
++static void __iomem *gpio_reg;
++
++#define MAX_DEVS 8
++static struct spi_device *spi_devices[MAX_DEVS];
++static int spi_device_count;
++struct platform_device *p_device;
++
++static char *name;
++module_param(name, charp, 0);
++MODULE_PARM_DESC(name, "Devicename (required). " \
++"name=list => list all supported devices.");
++
++static unsigned rotate;
++module_param(rotate, uint, 0);
++MODULE_PARM_DESC(rotate,
++"Angle to rotate display counter clockwise: 0, 90, 180, 270");
++
++static unsigned busnum;
++module_param(busnum, uint, 0);
++MODULE_PARM_DESC(busnum, "SPI bus number (default=0)");
++
++static unsigned cs;
++module_param(cs, uint, 0);
++MODULE_PARM_DESC(cs, "SPI chip select (default=0)");
++
++static unsigned speed;
++module_param(speed, uint, 0);
++MODULE_PARM_DESC(speed, "SPI speed (override device default)");
++
++static int mode = -1;
++module_param(mode, int, 0);
++MODULE_PARM_DESC(mode, "SPI mode (override device default)");
++
++static char *gpios;
++module_param(gpios, charp, 0);
++MODULE_PARM_DESC(gpios,
++"List of gpios. Comma separated with the form: reset:23,dc:24 " \
++"(when overriding the default, all gpios must be specified)");
++
++static unsigned fps;
++module_param(fps, uint, 0);
++MODULE_PARM_DESC(fps, "Frames per second (override driver default)");
++
++static char *gamma;
++module_param(gamma, charp, 0);
++MODULE_PARM_DESC(gamma,
++"String representation of Gamma Curve(s). Driver specific.");
++
++static int txbuflen;
++module_param(txbuflen, int, 0);
++MODULE_PARM_DESC(txbuflen, "txbuflen (override driver default)");
++
++static int bgr = -1;
++module_param(bgr, int, 0);
++MODULE_PARM_DESC(bgr,
++"BGR bit (supported by some drivers).");
++
++static unsigned startbyte;
++module_param(startbyte, uint, 0);
++MODULE_PARM_DESC(startbyte, "Sets the Start byte used by some SPI displays.");
++
++static bool custom;
++module_param(custom, bool, 0);
++MODULE_PARM_DESC(custom, "Add a custom display device. " \
++"Use speed= argument to make it a SPI device, else platform_device");
++
++static unsigned width;
++module_param(width, uint, 0);
++MODULE_PARM_DESC(width, "Display width, used with the custom argument");
++
++static unsigned height;
++module_param(height, uint, 0);
++MODULE_PARM_DESC(height, "Display height, used with the custom argument");
++
++static unsigned buswidth = 8;
++module_param(buswidth, uint, 0);
++MODULE_PARM_DESC(buswidth, "Display bus width, used with the custom argument");
++
++static int init[FBTFT_MAX_INIT_SEQUENCE];
++static int init_num;
++module_param_array(init, int, &init_num, 0);
++MODULE_PARM_DESC(init, "Init sequence, used with the custom argument");
++
++static unsigned long debug;
++module_param(debug, ulong , 0);
++MODULE_PARM_DESC(debug,
++"level: 0-7 (the remaining 29 bits is for advanced usage)");
++
++static unsigned verbose = 3;
++module_param(verbose, uint, 0);
++MODULE_PARM_DESC(verbose,
++"0 silent, >0 show gpios, >1 show devices, >2 show devices before (default=3)");
++
++static unsigned long frequency = 16000000;
++module_param(frequency, ulong, 0644);
++MODULE_PARM_DESC(frequency,
++"Frequency of the TFT SPI interface");
++
++enum gpio_pull {
++	pull_none = 0,
++	pull_down = 1,
++	pull_up = 2,
++};
++
++struct gpio_setting {
++	uint32_t gpio;
++	enum gpio_pull pull;
++};
++
++struct fbtft_device_display {
++	char *name;
++	struct spi_board_info *spi;
++	struct platform_device *pdev;
++
++	/*
++	 * set to "1" to indicate support device * (e.g. touchscreen
++	 * controller) that doesn't have a standard LCD platform data struct.
++	 */
++	int is_support;
++
++	/* GPIO Pullups/pulldown */
++	struct gpio_setting *gpio_settings;
++	uint32_t gpio_num_settings;
++};
++
++static void fbtft_device_pdev_release(struct device *dev);
++
++static int write_gpio16_wr_slow(struct fbtft_par *par, void *buf, size_t len);
++static void adafruit18_green_tab_set_addr_win(struct fbtft_par *par,
++	int xs, int ys, int xe, int ye);
++
++#define ADAFRUIT18_GAMMA \
++		"02 1c 07 12 37 32 29 2d 29 25 2B 39 00 01 03 10\n" \
++		"03 1d 07 06 2E 2C 29 2D 2E 2E 37 3F 00 00 02 10"
++
++static int hy28b_init_sequence[] = {
++	-1,0x00e7,0x0010,-1,0x0000,0x0001,-1,0x0001,0x0100,-1,0x0002,0x0700,
++	-1,0x0003,0x1030,-1,0x0004,0x0000,-1,0x0008,0x0207,-1,0x0009,0x0000,
++	-1,0x000a,0x0000,-1,0x000c,0x0001,-1,0x000d,0x0000,-1,0x000f,0x0000,
++	-1,0x0010,0x0000,-1,0x0011,0x0007,-1,0x0012,0x0000,-1,0x0013,0x0000,
++	-2,50,-1,0x0010,0x1590,-1,0x0011,0x0227,-2,50,-1,0x0012,0x009c,-2,50,
++	-1,0x0013,0x1900,-1,0x0029,0x0023,-1,0x002b,0x000e,-2,50,
++	-1,0x0020,0x0000,-1,0x0021,0x0000,-2,50,-1,0x0050,0x0000,
++	-1,0x0051,0x00ef,-1,0x0052,0x0000,-1,0x0053,0x013f,-1,0x0060,0xa700,
++	-1,0x0061,0x0001,-1,0x006a,0x0000,-1,0x0080,0x0000,-1,0x0081,0x0000,
++	-1,0x0082,0x0000,-1,0x0083,0x0000,-1,0x0084,0x0000,-1,0x0085,0x0000,
++	-1,0x0090,0x0010,-1,0x0092,0x0000,-1,0x0093,0x0003,-1,0x0095,0x0110,
++	-1,0x0097,0x0000,-1,0x0098,0x0000,-1,0x0007,0x0133,-1,0x0020,0x0000,
++	-1,0x0021,0x0000,-2,100,-3 };
++
++#define HY28B_GAMMA \
++	"04 1F 4 7 7 0 7 7 6 0\n" \
++	"0F 00 1 7 4 0 0 0 6 7"
++
++/* Supported displays in alphabetical order */
++static struct fbtft_device_display displays[] = {
++	{
++		.name = "adafruit18",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_st7735r",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{ "led", 18 },
++					{},
++				},
++				.gamma = ADAFRUIT18_GAMMA,
++			}
++		}
++	}, {
++		.name = "adafruit18_green",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_st7735r",
++			.max_speed_hz = 4000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++					.fbtftops.set_addr_win = \
++					    adafruit18_green_tab_set_addr_win,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{ "led", 18 },
++					{},
++				},
++				.gamma = ADAFRUIT18_GAMMA,
++			}
++		}
++	}, {
++		.name = "adafruit22",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_hx8340bn",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 9,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "led", 23 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "adafruit22a",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ili9340",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{ "led", 18 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "adafruit13m",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ssd1306",
++			.max_speed_hz = 16000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++				},
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{},
++				},
++			}
++		}
++	}, {
++		/* Touch device spi-half of adafruit touchscreen */
++		.name = "adafruitts",
++		.spi = &(struct spi_board_info) {
++			.modalias = "stmpe610",
++			.max_speed_hz = 500000,
++			.mode = SPI_MODE_0,
++			.chip_select = 1,
++			.platform_data = &(struct stmpe_platform_data) {
++				.blocks = STMPE_BLOCK_TOUCHSCREEN | STMPE_BLOCK_GPIO,
++				.irq_over_gpio = 1,
++				.irq_gpio = 24,
++				.irq_trigger = IRQF_TRIGGER_FALLING,
++				.irq_base = GPIO_IRQ_START + GPIO_IRQS,
++				.ts = &(struct stmpe_ts_platform_data) {
++					.sample_time = 4,
++					.mod_12b = 1,
++					.ref_sel = 0,
++					.adc_freq = 2,
++					.ave_ctrl = 3,
++					.touch_det_delay = 4,
++					.settling = 2,
++					.fraction_z = 7,
++					.i_drive = 0,
++				},
++			}
++		},
++		.is_support = 1,
++		.gpio_settings = (struct gpio_setting []) {
++			{
++				.gpio = 24,
++				.pull = pull_up,
++			}
++		},
++		.gpio_num_settings = 1,
++	}, {
++		/* LCD component of adafruit touchscreen */
++		.name = "adafruitts",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ili9340",
++			.max_speed_hz = 16000000,
++			.mode = SPI_MODE_0,
++			.chip_select = 0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "dc", 25 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "flexfb",
++		.spi = &(struct spi_board_info) {
++			.modalias = "flexfb",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "flexpfb",
++		.pdev = &(struct platform_device) {
++			.name = "flexpfb",
++			.id = 0,
++			.dev = {
++			.release = fbtft_device_pdev_release,
++			.platform_data = &(struct fbtft_platform_data) {
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 17 },
++					{ "dc", 1 },
++					{ "wr", 0 },
++					{ "cs", 21 },
++					{ "db00", 9 },
++					{ "db01", 11 },
++					{ "db02", 18 },
++					{ "db03", 23 },
++					{ "db04", 24 },
++					{ "db05", 25 },
++					{ "db06", 8 },
++					{ "db07", 7 },
++					{ "led", 4 },
++					{},
++				},
++			},
++			}
++		}
++	}, {
++		.name = "freetronicsoled128",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ssd1351",
++			.max_speed_hz = 20000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = FBTFT_ONBOARD_BACKLIGHT,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 24 },
++					{ "dc", 25 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "hy28a",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ili9320",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_3,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.startbyte = 0b01110000,
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "led", 18 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "hy28b",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ili9325",
++			.max_speed_hz = 48000000,
++			.mode = SPI_MODE_3,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++					.init_sequence = hy28b_init_sequence,
++				},
++				.startbyte = 0b01110000,
++				.bgr = true,
++				.fps= 50,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "led", 18 },
++					{},
++				},
++				.gamma = HY28B_GAMMA,
++			}
++		}
++	}, {
++		.name = "itdb24",
++		.pdev = &(struct platform_device) {
++			.name = "fb_s6d1121",
++			.id = 0,
++			.dev = {
++			.release = fbtft_device_pdev_release,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.bgr = false,
++				.gpios = (const struct fbtft_gpio []) {
++					/* Wiring for LCD adapter kit */
++					{ "reset", 7 },
++					{ "dc", 0 }, 	/* rev 2: 2 */
++					{ "wr", 1 }, 	/* rev 2: 3 */
++					{ "cs", 8 },
++					{ "db00", 17 },
++					{ "db01", 18 },
++					{ "db02", 21 }, /* rev 2: 27 */
++					{ "db03", 22 },
++					{ "db04", 23 },
++					{ "db05", 24 },
++					{ "db06", 25 },
++					{ "db07", 4 },
++					{}
++				},
++			},
++			}
++		}
++	}, {
++		.name = "itdb28",
++		.pdev = &(struct platform_device) {
++			.name = "fb_ili9325",
++			.id = 0,
++			.dev = {
++			.release = fbtft_device_pdev_release,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{},
++				},
++			},
++			}
++		}
++	}, {
++		.name = "itdb28_spi",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ili9325",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "mi0283qt-2",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_hx8347d",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.startbyte = 0b01110000,
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{ "led", 18 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "mi0283qt-9a",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ili9341",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 9,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "led", 18 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "mi0283qt-v2",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_watterott",
++			.max_speed_hz = 4000000,
++			.mode = SPI_MODE_3,
++			.platform_data = &(struct fbtft_platform_data) {
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "nokia3310",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_pcd8544",
++			.max_speed_hz = 400000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++				},
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{ "led", 23 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "pioled",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ssd1351",
++			.max_speed_hz = 20000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 24 },
++					{ "dc", 25 },
++					{},
++				},
++				.gamma =	"0 2 2 2 2 2 2 2 " \
++						"2 2 2 2 2 2 2 2 " \
++						"2 2 2 2 2 2 2 2 " \
++						"2 2 2 2 2 2 2 3 " \
++						"3 3 3 3 3 3 3 3 " \
++						"3 3 3 3 3 3 3 3 " \
++						"3 3 3 4 4 4 4 4 " \
++						"4 4 4 4 4 4 4"
++			}
++		}
++	}, {
++		.name = "rpi-display",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ili9341",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 23 },
++					{ "dc", 24 },
++					{ "led", 18 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "sainsmart18",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_st7735r",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++				},
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "sainsmart32",
++		.pdev = &(struct platform_device) {
++			.name = "fb_ssd1289",
++			.id = 0,
++			.dev = {
++			.release = fbtft_device_pdev_release,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 16,
++					.txbuflen = -2, /* disable buffer */
++					.backlight = 1,
++					.fbtftops.write = write_gpio16_wr_slow,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{},
++				},
++			},
++		},
++		}
++	}, {
++		.name = "sainsmart32_fast",
++		.pdev = &(struct platform_device) {
++			.name = "fb_ssd1289",
++			.id = 0,
++			.dev = {
++			.release = fbtft_device_pdev_release,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 16,
++					.txbuflen = -2, /* disable buffer */
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{},
++				},
++			},
++		},
++		}
++	}, {
++		.name = "sainsmart32_latched",
++		.pdev = &(struct platform_device) {
++			.name = "fb_ssd1289",
++			.id = 0,
++			.dev = {
++			.release = fbtft_device_pdev_release,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 16,
++					.txbuflen = -2, /* disable buffer */
++					.backlight = 1,
++					.fbtftops.write = \
++						fbtft_write_gpio16_wr_latched,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{},
++				},
++			},
++		},
++		}
++	}, {
++		.name = "sainsmart32_spi",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ssd1289",
++			.max_speed_hz = 16000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "spidev",
++		.spi = &(struct spi_board_info) {
++			.modalias = "spidev",
++			.max_speed_hz = 500000,
++			.bus_num = 0,
++			.chip_select = 0,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.gpios = (const struct fbtft_gpio []) {
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "ssd1331",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ssd1331",
++			.max_speed_hz = 20000000,
++			.mode = SPI_MODE_3,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++				},
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 24 },
++					{ "dc", 25 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "tinylcd35",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_tinylcd",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{ "led", 18 },
++					{},
++				},
++			}
++		}
++	}, {
++		.name = "tm022hdh26",
++		.spi = &(struct spi_board_info) {
++			.modalias = "fb_ili9341",
++			.max_speed_hz = 32000000,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.display = {
++					.buswidth = 8,
++					.backlight = 1,
++				},
++				.bgr = true,
++				.gpios = (const struct fbtft_gpio []) {
++					{ "reset", 25 },
++					{ "dc", 24 },
++					{ "led", 18 },
++					{},
++				},
++			}
++		}
++	}, {
++		/* This should be the last item.
++		   Used with the custom argument */
++		.name = "",
++		.spi = &(struct spi_board_info) {
++			.modalias = "",
++			.max_speed_hz = 0,
++			.mode = SPI_MODE_0,
++			.platform_data = &(struct fbtft_platform_data) {
++				.gpios = (const struct fbtft_gpio []) {
++					{},
++				},
++			}
++		},
++		.pdev = &(struct platform_device) {
++			.name = "",
++			.id = 0,
++			.dev = {
++			.release = fbtft_device_pdev_release,
++			.platform_data = &(struct fbtft_platform_data) {
++				.gpios = (const struct fbtft_gpio []) {
++					{},
++				},
++			},
++		},
++		},
++	}
++};
++
++static int write_gpio16_wr_slow(struct fbtft_par *par, void *buf, size_t len)
++{
++	u16 data;
++	int i;
++#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO
++	static u16 prev_data;
++#endif
++
++	fbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,
++		"%s(len=%d): ", __func__, len);
++
++	while (len) {
++		data = *(u16 *) buf;
++
++		/* Start writing by pulling down /WR */
++		gpio_set_value(par->gpio.wr, 0);
++
++		/* Set data */
++#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO
++		if (data == prev_data) {
++			gpio_set_value(par->gpio.wr, 0); /* used as delay */
++		} else {
++			for (i = 0; i < 16; i++) {
++				if ((data & 1) != (prev_data & 1))
++					gpio_set_value(par->gpio.db[i],
++								(data & 1));
++				data >>= 1;
++				prev_data >>= 1;
++			}
++		}
++#else
++		for (i = 0; i < 16; i++) {
++			gpio_set_value(par->gpio.db[i], (data & 1));
++			data >>= 1;
++		}
++#endif
++
++		/* Pullup /WR */
++		gpio_set_value(par->gpio.wr, 1);
++
++#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO
++		prev_data = *(u16 *) buf;
++#endif
++		buf += 2;
++		len -= 2;
++	}
++
++	return 0;
++}
++
++static void adafruit18_green_tab_set_addr_win(struct fbtft_par *par,
++						int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
++		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++	write_reg(par, 0x2A, 0, xs + 2, 0, xe + 2);
++	write_reg(par, 0x2B, 0, ys + 1, 0, ye + 1);
++	write_reg(par, 0x2C);
++}
++
++/* used if gpios parameter is present */
++static struct fbtft_gpio fbtft_device_param_gpios[MAX_GPIOS+1] = { };
++
++static void fbtft_device_pdev_release(struct device *dev)
++{
++/* Needed to silence this message:
++Device 'xxx' does not have a release() function, it is broken and must be fixed
++*/
++}
++
++static int spi_device_found(struct device *dev, void *data)
++{
++	struct spi_device *spi = container_of(dev, struct spi_device, dev);
++
++	pr_info(DRVNAME":      %s %s %dkHz %d bits mode=0x%02X\n",
++		spi->modalias, dev_name(dev), spi->max_speed_hz/1000,
++		spi->bits_per_word, spi->mode);
++
++	return 0;
++}
++
++static void pr_spi_devices(void)
++{
++	pr_info(DRVNAME":  SPI devices registered:\n");
++	bus_for_each_dev(&spi_bus_type, NULL, NULL, spi_device_found);
++}
++
++static int p_device_found(struct device *dev, void *data)
++{
++	struct platform_device
++	*pdev = container_of(dev, struct platform_device, dev);
++
++	if (strstr(pdev->name, "fb"))
++		pr_info(DRVNAME":      %s id=%d pdata? %s\n",
++				pdev->name, pdev->id,
++				pdev->dev.platform_data ? "yes" : "no");
++
++	return 0;
++}
++
++static void pr_p_devices(void)
++{
++	pr_info(DRVNAME":  'fb' Platform devices registered:\n");
++	bus_for_each_dev(&platform_bus_type, NULL, NULL, p_device_found);
++}
++
++#ifdef MODULE
++static void fbtft_device_spi_delete(struct spi_master *master, unsigned cs)
++{
++	struct device *dev;
++	char str[32];
++
++	snprintf(str, sizeof(str), "%s.%u", dev_name(&master->dev), cs);
++
++	dev = bus_find_device_by_name(&spi_bus_type, NULL, str);
++	if (dev) {
++		pr_err(DRVNAME": Deleting %s (%s)\n", str, dev_name(dev));
++		device_del(dev);
++	}
++}
++
++static int fbtft_device_spi_device_register(struct spi_board_info *spi)
++{
++	struct spi_master *master;
++	struct spi_device *spi_device;
++
++	master = spi_busnum_to_master(spi->bus_num);
++	if (!master) {
++		pr_err(DRVNAME ":  spi_busnum_to_master(%d) returned NULL\n",
++								spi->bus_num);
++		return -EINVAL;
++	}
++	/* make sure it's available */
++	fbtft_device_spi_delete(master, spi->chip_select);
++	spi_device = spi_new_device(master, spi);
++	put_device(&master->dev);
++	if (!spi_device) {
++		pr_err(DRVNAME ":    spi_new_device() returned NULL\n");
++		return -EPERM;
++	}
++	spi_devices[spi_device_count++] = spi_device;
++	return 0;
++}
++#else
++static int fbtft_device_spi_device_register(struct spi_board_info *spi)
++{
++	return spi_register_board_info(spi, 1);
++}
++#endif
++
++static int __init fbtft_device_init(void)
++{
++	struct spi_board_info *spi = NULL;
++	struct fbtft_platform_data *pdata = NULL;
++	const struct fbtft_gpio *gpio = NULL;
++	char *p_gpio, *p_name, *p_num;
++	bool found = false;
++	int i = 0;
++	long val;
++	int ret = 0;
++
++	pr_debug("\n\n"DRVNAME": init\n");
++
++	if (name == NULL) {
++#ifdef MODULE
++		pr_err(DRVNAME":  missing module parameter: 'name'\n");
++		return -EINVAL;
++#else
++		return 0;
++#endif
++	}
++
++	if (init_num > FBTFT_MAX_INIT_SEQUENCE) {
++		pr_err(DRVNAME \
++			":  init parameter: exceeded max array size: %d\n",
++			FBTFT_MAX_INIT_SEQUENCE);
++		return -EINVAL;
++	}
++
++	/* parse module parameter: gpios */
++	while ((p_gpio = strsep(&gpios, ","))) {
++		if (strchr(p_gpio, ':') == NULL) {
++			pr_err(DRVNAME \
++				":  error: missing ':' in gpios parameter: %s\n",
++				p_gpio);
++			return -EINVAL;
++		}
++		p_num = p_gpio;
++		p_name = strsep(&p_num, ":");
++		if (p_name == NULL || p_num == NULL) {
++			pr_err(DRVNAME \
++				":  something bad happened parsing gpios parameter: %s\n",
++				p_gpio);
++			return -EINVAL;
++		}
++		ret = kstrtol(p_num, 10, &val);
++		if (ret) {
++			pr_err(DRVNAME \
++				":  could not parse number in gpios parameter: %s:%s\n",
++				p_name, p_num);
++			return -EINVAL;
++		}
++		strcpy(fbtft_device_param_gpios[i].name, p_name);
++		fbtft_device_param_gpios[i++].gpio = (int) val;
++		if (i == MAX_GPIOS) {
++			pr_err(DRVNAME \
++				":  gpios parameter: exceeded max array size: %d\n",
++				MAX_GPIOS);
++			return -EINVAL;
++		}
++	}
++	if (fbtft_device_param_gpios[0].name[0])
++		gpio = fbtft_device_param_gpios;
++
++	if (verbose > 2)
++		pr_spi_devices(); /* print list of registered SPI devices */
++
++	if (verbose > 2)
++		pr_p_devices(); /* print list of 'fb' platform devices */
++
++	pr_debug(DRVNAME":  name='%s', busnum=%d, cs=%d\n", name, busnum, cs);
++
++	if (rotate > 0 && rotate < 4) {
++		rotate = (4 - rotate) * 90;
++		pr_warn("argument 'rotate' should be an angle. Values 1-3 is deprecated. Setting it to %d.\n",
++			rotate);
++	}
++	if (rotate != 0 && rotate != 90 && rotate != 180 && rotate != 270) {
++		pr_warn("argument 'rotate' illegal value: %d. Setting it to 0.\n",
++			rotate);
++		rotate = 0;
++	}
++
++	/* name=list lists all supported displays */
++	if (strncmp(name, "list", 32) == 0) {
++		pr_info(DRVNAME":  Supported displays:\n");
++
++		for (i = 0; i < ARRAY_SIZE(displays); i++)
++			pr_info(DRVNAME":      %s\n", displays[i].name);
++		return -ECANCELED;
++	}
++
++	if (custom) {
++		i = ARRAY_SIZE(displays) - 1;
++		displays[i].name = name;
++		if (speed == 0) {
++			displays[i].pdev->name = name;
++			displays[i].spi = NULL;
++		} else {
++			strncpy(displays[i].spi->modalias, name, SPI_NAME_SIZE);
++			displays[i].pdev = NULL;
++		}
++	}
++
++	gpio_reg = ioremap(GPIO_BASE, 1024);
++
++	for (i = 0; i < ARRAY_SIZE(displays); i++) {
++		if (strncmp(name, displays[i].name, 32) == 0) {
++			int j;
++			if (displays[i].spi) {
++				int dev_cs;
++				spi = displays[i].spi;
++				dev_cs = spi->chip_select;
++				if (cs)
++					dev_cs = cs;
++				spi->chip_select = dev_cs;
++				spi->bus_num = busnum;
++				if (speed)
++					spi->max_speed_hz = speed;
++				if (mode != -1)
++					spi->mode = mode;
++				if (!displays[i].is_support) {
++					spi->max_speed_hz = frequency;
++					pdata = (void *)spi->platform_data;
++				}
++			} else if (displays[i].pdev) {
++				p_device = displays[i].pdev;
++				if (!displays[i].is_support)
++					pdata = p_device->dev.platform_data;
++			} else {
++				pr_err(DRVNAME": broken displays array\n");
++				return -EINVAL;
++			}
++
++			for (j = 0; j < displays[i].gpio_num_settings; j++) {
++				pr_debug(DRVNAME": Looking at item %d\n", j);
++				pr_debug(DRVNAME": Setting pin %d to %d\n",
++					displays[i].gpio_settings[j].gpio,
++					displays[i].gpio_settings[j].pull);
++				GPIO_PULL_SET(displays[i].gpio_settings[j].gpio,
++					displays[i].gpio_settings[j].pull);
++			}
++
++			if (!displays[i].is_support && pdata) {
++				pdata->rotate = rotate;
++				if (bgr == 0)
++					pdata->bgr = false;
++				else if (bgr == 1)
++					pdata->bgr = true;
++				if (startbyte)
++					pdata->startbyte = startbyte;
++				if (gamma)
++					pdata->gamma = gamma;
++				pdata->display.debug = debug;
++				if (fps)
++					pdata->fps = fps;
++				if (txbuflen)
++					pdata->txbuflen = txbuflen;
++				if (init_num)
++					pdata->display.init_sequence = init;
++				if (gpio)
++					pdata->gpios = gpio;
++				if (custom) {
++					pdata->display.width = width;
++					pdata->display.height = height;
++					pdata->display.buswidth = buswidth;
++					pdata->display.backlight = 1;
++				}
++			}
++
++			if (displays[i].spi) {
++				ret = fbtft_device_spi_device_register(spi);
++				if (ret) {
++					pr_err(DRVNAME \
++						": failed to register SPI device\n");
++					return ret;
++				}
++				if (!displays[i].is_support)
++					found = true;
++			} else {
++				ret = platform_device_register(p_device);
++				if (ret < 0) {
++					pr_err(DRVNAME \
++						":    platform_device_register() returned %d\n",
++						ret);
++					return ret;
++				}
++				if (!displays[i].is_support)
++					found = true;
++			}
++		}
++	}
++
++	if (!found) {
++		pr_err(DRVNAME":  display not supported: '%s'\n", name);
++		return -EINVAL;
++	}
++
++	if (verbose && pdata && pdata->gpios) {
++		gpio = pdata->gpios;
++		pr_info(DRVNAME":  GPIOS used by '%s':\n", name);
++		found = false;
++		while (verbose && gpio->name[0]) {
++			pr_info(DRVNAME":    '%s' = GPIO%d\n",
++				gpio->name, gpio->gpio);
++			gpio++;
++			found = true;
++		}
++		if (!found)
++			pr_info(DRVNAME":    (none)\n");
++	}
++
++	if (spi_device_count && (verbose > 1))
++		pr_spi_devices();
++	if (p_device && (verbose > 1))
++		pr_p_devices();
++
++	return 0;
++}
++
++static void __exit fbtft_device_exit(void)
++{
++	pr_debug(DRVNAME" - exit\n");
++
++	if (spi_device_count) {
++		int i;
++		for (i = 0; i < spi_device_count; i++) {
++			device_del(&spi_devices[i]->dev);
++			kfree(spi_devices[i]);
++		}
++	}
++
++	if (p_device)
++		platform_device_unregister(p_device);
++
++	if (gpio_reg)
++		iounmap(gpio_reg);
++}
++
++arch_initcall(fbtft_device_init);
++module_exit(fbtft_device_exit);
++
++MODULE_DESCRIPTION("Add a FBTFT device.");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/video/fbtft/flexfb.c b/drivers/video/fbtft/flexfb.c
+new file mode 100644
+index 0000000..b6c9d3d
+--- /dev/null
++++ b/drivers/video/fbtft/flexfb.c
+@@ -0,0 +1,595 @@
++/*
++ * Generic FB driver for TFT LCD displays
++ *
++ * Copyright (C) 2013 Noralf Tronnes
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
++ */
++
++#include <linux/module.h>
++#include <linux/kernel.h>
++#include <linux/init.h>
++#include <linux/vmalloc.h>
++#include <linux/gpio.h>
++#include <linux/spi/spi.h>
++#include <linux/delay.h>
++
++#include "fbtft.h"
++
++#define DRVNAME	    "flexfb"
++
++
++static char *chip = NULL;
++module_param(chip, charp, 0);
++MODULE_PARM_DESC(chip, "LCD controller");
++
++static unsigned int width = 0;
++module_param(width, uint, 0);
++MODULE_PARM_DESC(width, "Display width");
++
++static unsigned int height = 0;
++module_param(height, uint, 0);
++MODULE_PARM_DESC(height, "Display height");
++
++static int init[512];
++static int init_num = 0;
++module_param_array(init, int, &init_num, 0);
++MODULE_PARM_DESC(init, "Init sequence");
++
++static unsigned int setaddrwin = 0;
++module_param(setaddrwin, uint, 0);
++MODULE_PARM_DESC(setaddrwin, "Which set_addr_win() implementation to use");
++
++static unsigned int buswidth = 8;
++module_param(buswidth, uint, 0);
++MODULE_PARM_DESC(buswidth, "Width of databus (default: 8)");
++
++static unsigned int regwidth = 8;
++module_param(regwidth, uint, 0);
++MODULE_PARM_DESC(regwidth, "Width of controller register (default: 8)");
++
++static bool nobacklight = false;
++module_param(nobacklight, bool, 0);
++MODULE_PARM_DESC(nobacklight, "Turn off backlight functionality.");
++
++static bool latched = false;
++module_param(latched, bool, 0);
++MODULE_PARM_DESC(latched, "Use with latched 16-bit databus");
++
++
++static int *initp = NULL;
++static int initp_num = 0;
++
++/* default init sequences */
++static int st7735r_init[] = { \
++-1,0x01,-2,150,-1,0x11,-2,500,-1,0xB1,0x01,0x2C,0x2D,-1,0xB2,0x01,0x2C,0x2D,-1,0xB3,0x01,0x2C,0x2D,0x01,0x2C,0x2D, \
++-1,0xB4,0x07,-1,0xC0,0xA2,0x02,0x84,-1,0xC1,0xC5,-1,0xC2,0x0A,0x00,-1,0xC3,0x8A,0x2A,-1,0xC4,0x8A,0xEE,-1,0xC5,0x0E, \
++-1,0x20,-1,0x36,0xC0,-1,0x3A,0x05,-1,0xE0,0x0f,0x1a,0x0f,0x18,0x2f,0x28,0x20,0x22,0x1f,0x1b,0x23,0x37,0x00,0x07,0x02,0x10, \
++-1,0xE1,0x0f,0x1b,0x0f,0x17,0x33,0x2c,0x29,0x2e,0x30,0x30,0x39,0x3f,0x00,0x07,0x03,0x10,-1,0x29,-2,100,-1,0x13,-2,10,-3 };
++
++static int ssd1289_init[] = { \
++-1,0x00,0x0001,-1,0x03,0xA8A4,-1,0x0C,0x0000,-1,0x0D,0x080C,-1,0x0E,0x2B00,-1,0x1E,0x00B7,-1,0x01,0x2B3F,-1,0x02,0x0600, \
++-1,0x10,0x0000,-1,0x11,0x6070,-1,0x05,0x0000,-1,0x06,0x0000,-1,0x16,0xEF1C,-1,0x17,0x0003,-1,0x07,0x0233,-1,0x0B,0x0000, \
++-1,0x0F,0x0000,-1,0x41,0x0000,-1,0x42,0x0000,-1,0x48,0x0000,-1,0x49,0x013F,-1,0x4A,0x0000,-1,0x4B,0x0000,-1,0x44,0xEF00, \
++-1,0x45,0x0000,-1,0x46,0x013F,-1,0x30,0x0707,-1,0x31,0x0204,-1,0x32,0x0204,-1,0x33,0x0502,-1,0x34,0x0507,-1,0x35,0x0204, \
++-1,0x36,0x0204,-1,0x37,0x0502,-1,0x3A,0x0302,-1,0x3B,0x0302,-1,0x23,0x0000,-1,0x24,0x0000,-1,0x25,0x8000,-1,0x4f,0x0000, \
++-1,0x4e,0x0000,-1,0x22,-3 };
++
++static int hx8340bn_init[] = { \
++-1,0xC1,0xFF,0x83,0x40,-1,0x11,-2,150,-1,0xCA,0x70,0x00,0xD9,-1,0xB0,0x01,0x11, \
++-1,0xC9,0x90,0x49,0x10,0x28,0x28,0x10,0x00,0x06,-2,20,-1,0xC2,0x60,0x71,0x01,0x0E,0x05,0x02,0x09,0x31,0x0A, \
++-1,0xC3,0x67,0x30,0x61,0x17,0x48,0x07,0x05,0x33,-2,10,-1,0xB5,0x35,0x20,0x45,-1,0xB4,0x33,0x25,0x4C,-2,10, \
++-1,0x3A,0x05,-1,0x29,-2,10,-3 };
++
++static int ili9225_init[] = { \
++-1,0x0001,0x011C,-1,0x0002,0x0100,-1,0x0003,0x1030,-1,0x0008,0x0808,-1,0x000C,0x0000,-1,0x000F,0x0A01,-1,0x0020,0x0000, \
++-1,0x0021,0x0000,-2,50,-1,0x0010,0x0A00,-1,0x0011,0x1038,-2,50,-1,0x0012,0x1121,-1,0x0013,0x004E,-1,0x0014,0x676F, \
++-1,0x0030,0x0000,-1,0x0031,0x00DB,-1,0x0032,0x0000,-1,0x0033,0x0000,-1,0x0034,0x00DB,-1,0x0035,0x0000,-1,0x0036,0x00AF, \
++-1,0x0037,0x0000,-1,0x0038,0x00DB,-1,0x0039,0x0000,-1,0x0050,0x0000,-1,0x0051,0x060A,-1,0x0052,0x0D0A,-1,0x0053,0x0303, \
++-1,0x0054,0x0A0D,-1,0x0055,0x0A06,-1,0x0056,0x0000,-1,0x0057,0x0303,-1,0x0058,0x0000,-1,0x0059,0x0000,-2,50, \
++-1,0x0007,0x1017,-2,50,-3 };
++
++static int ili9320_init[] = { \
++-1,0x00E5,0x8000,-1,0x0000,0x0001,-1,0x0001,0x0100,-1,0x0002,0x0700,-1,0x0003,0x1030,-1,0x0004,0x0000,-1,0x0008,0x0202, \
++-1,0x0009,0x0000,-1,0x000A,0x0000,-1,0x000C,0x0000,-1,0x000D,0x0000,-1,0x000F,0x0000,-1,0x0010,0x0000,-1,0x0011,0x0007, \
++-1,0x0012,0x0000,-1,0x0013,0x0000,-2,200,-1,0x0010,0x17B0,-1,0x0011,0x0031,-2,50,-1,0x0012,0x0138,-2,50,-1,0x0013,0x1800, \
++-1,0x0029,0x0008,-2,50,-1,0x0020,0x0000,-1,0x0021,0x0000,-1,0x0030,0x0000,-1,0x0031,0x0505,-1,0x0032,0x0004, \
++-1,0x0035,0x0006,-1,0x0036,0x0707,-1,0x0037,0x0105,-1,0x0038,0x0002,-1,0x0039,0x0707,-1,0x003C,0x0704,-1,0x003D,0x0807, \
++-1,0x0050,0x0000,-1,0x0051,0x00EF,-1,0x0052,0x0000,-1,0x0053,0x013F,-1,0x0060,0x2700,-1,0x0061,0x0001,-1,0x006A,0x0000, \
++-1,0x0080,0x0000,-1,0x0081,0x0000,-1,0x0082,0x0000,-1,0x0083,0x0000,-1,0x0084,0x0000,-1,0x0085,0x0000,-1,0x0090,0x0010, \
++-1,0x0092,0x0000,-1,0x0093,0x0003,-1,0x0095,0x0110,-1,0x0097,0x0000,-1,0x0098,0x0000,-1,0x0007,0x0173,-3 };
++
++static int ili9325_init[] = { \
++-1,0x00E3,0x3008,-1,0x00E7,0x0012,-1,0x00EF,0x1231,-1,0x0001,0x0100,-1,0x0002,0x0700,-1,0x0003,0x1030,-1,0x0004,0x0000, \
++-1,0x0008,0x0207,-1,0x0009,0x0000,-1,0x000A,0x0000,-1,0x000C,0x0000,-1,0x000D,0x0000,-1,0x000F,0x0000,-1,0x0010,0x0000, \
++-1,0x0011,0x0007,-1,0x0012,0x0000,-1,0x0013,0x0000,-2,200,-1,0x0010,0x1690,-1,0x0011,0x0223,-2,50,-1,0x0012,0x000D,-2,50, \
++-1,0x0013,0x1200,-1,0x0029,0x000A,-1,0x002B,0x000C,-2,50,-1,0x0020,0x0000,-1,0x0021,0x0000,-1,0x0030,0x0000, \
++-1,0x0031,0x0506,-1,0x0032,0x0104,-1,0x0035,0x0207,-1,0x0036,0x000F,-1,0x0037,0x0306,-1,0x0038,0x0102,-1,0x0039,0x0707, \
++-1,0x003C,0x0702,-1,0x003D,0x1604,-1,0x0050,0x0000,-1,0x0051,0x00EF,-1,0x0052,0x0000,-1,0x0053,0x013F,-1,0x0060,0xA700, \
++-1,0x0061,0x0001,-1,0x006A,0x0000,-1,0x0080,0x0000,-1,0x0081,0x0000,-1,0x0082,0x0000,-1,0x0083,0x0000,-1,0x0084,0x0000, \
++-1,0x0085,0x0000,-1,0x0090,0x0010,-1,0x0092,0x0600,-1,0x0007,0x0133,-3 };
++
++static int ili9341_init[] = { \
++-1,0x28,-2,20,-1,0xCF,0x00,0x83,0x30,-1,0xED,0x64,0x03,0x12,0x81,-1,0xE8,0x85,0x01,0x79, \
++-1,0xCB,0x39,0x2c,0x00,0x34,0x02,-1,0xF7,0x20,-1,0xEA,0x00,0x00,-1,0xC0,0x26,-1,0xC1,0x11, \
++-1,0xC5,0x35,0x3E,-1,0xC7,0xBE,-1,0xB1,0x00,0x1B,-1,0xB6,0x0a,0x82,0x27,0x00,-1,0xB7,0x07, \
++-1,0x3A,0x55,-1,0x36,0x48,-1,0x11,-2,120,-1,0x29,-2,20,-3 };
++
++static int ssd1351_init[] = { -1,0xfd,0x12,-1,0xfd,0xb1,-1,0xae,-1,0xb3,0xf1,-1,0xca,0x7f,-1,0xa0,0x74, \
++                              -1,0x15,0x00,0x7f,-1,0x75,0x00,0x7f,-1,0xa1,0x00,-1,0xa2,0x00,-1,0xb5,0x00, \
++                              -1,0xab,0x01,-1,0xb1,0x32,-1,0xb4,0xa0,0xb5,0x55,-1,0xbb,0x17,-1,0xbe,0x05, \
++                              -1,0xc1,0xc8,0x80,0xc8,-1,0xc7,0x0f,-1,0xb6,0x01,-1,0xa6,-1,0xaf,-3 };
++
++
++/* ili9320, ili9325 */
++static void flexfb_set_addr_win_1(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, "%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++	switch (par->info->var.rotate) {
++	/* R20h = Horizontal GRAM Start Address */
++	/* R21h = Vertical GRAM Start Address */
++	case 0:
++		write_reg(par, 0x0020, xs);
++		write_reg(par, 0x0021, ys);
++		break;
++	case 180:
++		write_reg(par, 0x0020, width - 1 - xs);
++		write_reg(par, 0x0021, height - 1 - ys);
++		break;
++	case 270:
++		write_reg(par, 0x0020, width - 1 - ys);
++		write_reg(par, 0x0021, xs);
++		break;
++	case 90:
++		write_reg(par, 0x0020, ys);
++		write_reg(par, 0x0021, height - 1 - xs);
++		break;
++	}
++	write_reg(par, 0x0022); /* Write Data to GRAM */
++}
++
++/* ssd1289 */
++static void flexfb_set_addr_win_2(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, "%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	switch (par->info->var.rotate) {
++	/* R4Eh - Set GDDRAM X address counter */
++	/* R4Fh - Set GDDRAM Y address counter */
++	case 0:
++		write_reg(par, 0x4e, xs);
++		write_reg(par, 0x4f, ys);
++		break;
++	case 180:
++		write_reg(par, 0x4e, par->info->var.xres - 1 - xs);
++		write_reg(par, 0x4f, par->info->var.yres - 1 - ys);
++		break;
++	case 270:
++		write_reg(par, 0x4e, par->info->var.yres - 1 - ys);
++		write_reg(par, 0x4f, xs);
++		break;
++	case 90:
++		write_reg(par, 0x4e, ys);
++		write_reg(par, 0x4f, par->info->var.xres - 1 - xs);
++		break;
++	}
++
++	/* R22h - RAM data write */
++	write_reg(par, 0x22, 0);
++}
++
++/* ssd1351 */
++static void set_addr_win_3(struct fbtft_par *par, int xs, int ys, int xe, int ye)
++{
++	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par, "%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
++
++	write_reg(par, 0x15, xs, xe);
++	write_reg(par, 0x75, ys, ye);
++	write_reg(par, 0x5C);
++}
++
++static int flexfb_verify_gpios_dc(struct fbtft_par *par)
++{
++	fbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, "%s()\n", __func__);
++
++	if (par->gpio.dc < 0) {
++		dev_err(par->info->device, "Missing info about 'dc' gpio. Aborting.\n");
++		return -EINVAL;
++	}
++
++	return 0;
++}
++
++static int flexfb_verify_gpios_db(struct fbtft_par *par)
++{
++	int i;
++	int num_db = buswidth;
++
++	fbtft_par_dbg(DEBUG_VERIFY_GPIOS, par, "%s()\n", __func__);
++
++	if (par->gpio.dc < 0) {
++		dev_err(par->info->device, "Missing info about 'dc' gpio. Aborting.\n");
++		return -EINVAL;
++	}
++	if (par->gpio.wr < 0) {
++		dev_err(par->info->device, "Missing info about 'wr' gpio. Aborting.\n");
++		return -EINVAL;
++	}
++	if (latched && (par->gpio.latch < 0)) {
++		dev_err(par->info->device, "Missing info about 'latch' gpio. Aborting.\n");
++		return -EINVAL;
++	}
++	if (latched)
++		num_db=buswidth/2;
++	for (i=0;i < num_db;i++) {
++		if (par->gpio.db[i] < 0) {
++			dev_err(par->info->device, "Missing info about 'db%02d' gpio. Aborting.\n", i);
++			return -EINVAL;
++		}
++	}
++
++	return 0;
++}
++
++static struct fbtft_display flex_display = { };
++
++static int flexfb_probe_common(struct spi_device *sdev, struct platform_device *pdev)
++{
++	struct device *dev;
++	struct fb_info *info;
++	struct fbtft_par *par;
++	int ret;
++
++	initp = init;
++	initp_num = init_num;
++
++	if (sdev)
++		dev = &sdev->dev;
++	else
++		dev = &pdev->dev;
++
++	fbtft_init_dbg(dev, "%s(%s)\n", __func__, sdev ? "'SPI device'" : "'Platform device'");
++
++	if (chip) {
++
++		if (!strcmp(chip, "st7735r")) {
++			if (!width)
++				width = 128;
++			if (!height)
++				height = 160;
++			if (init_num == 0) {
++				initp = st7735r_init;
++				initp_num = ARRAY_SIZE(st7735r_init);
++			}
++
++
++		} else if (!strcmp(chip, "hx8340bn")) {
++			if (!width)
++				width = 176;
++			if (!height)
++				height = 220;
++			setaddrwin = 0;
++			if (init_num == 0) {
++				initp = hx8340bn_init;
++				initp_num = ARRAY_SIZE(hx8340bn_init);
++			}
++
++
++		} else if (!strcmp(chip, "ili9225")) {
++			if (!width)
++				width = 176;
++			if (!height)
++				height = 220;
++			setaddrwin = 0;
++			regwidth = 16;
++			if (init_num == 0) {
++				initp = ili9225_init;
++				initp_num = ARRAY_SIZE(ili9225_init);
++			}
++
++
++
++		} else if (!strcmp(chip, "ili9320")) {
++			if (!width)
++				width = 240;
++			if (!height)
++				height = 320;
++			setaddrwin = 1;
++			regwidth = 16;
++			if (init_num == 0) {
++				initp = ili9320_init;
++				initp_num = ARRAY_SIZE(ili9320_init);
++			}
++
++
++		} else if (!strcmp(chip, "ili9325")) {
++			if (!width)
++				width = 240;
++			if (!height)
++				height = 320;
++			setaddrwin = 1;
++			regwidth = 16;
++			if (init_num == 0) {
++				initp = ili9325_init;
++				initp_num = ARRAY_SIZE(ili9325_init);
++			}
++
++		} else if (!strcmp(chip, "ili9341")) {
++			if (!width)
++				width = 240;
++			if (!height)
++				height = 320;
++			setaddrwin = 0;
++			regwidth = 8;
++			if (init_num == 0) {
++				initp = ili9341_init;
++				initp_num = ARRAY_SIZE(ili9341_init);
++			}
++
++
++		} else if (!strcmp(chip, "ssd1289")) {
++			if (!width)
++				width = 240;
++			if (!height)
++				height = 320;
++			setaddrwin = 2;
++			regwidth = 16;
++			if (init_num == 0) {
++				initp = ssd1289_init;
++				initp_num = ARRAY_SIZE(ssd1289_init);
++			}
++
++
++
++		} else if (!strcmp(chip, "ssd1351")) {
++			if (!width)
++				width = 128;
++			if (!height)
++				height = 128;
++			setaddrwin = 3;
++			if (init_num == 0) {
++				initp = ssd1351_init;
++				initp_num = ARRAY_SIZE(ssd1351_init);
++			}
++		} else {
++			dev_err(dev, "chip=%s is not supported\n", chip);
++			return -EINVAL;
++		}
++	}
++
++	if (width == 0 || height == 0) {
++		dev_err(dev, "argument(s) missing: width and height has to be set.\n");
++		return -EINVAL;
++	}
++	flex_display.width = width;
++	flex_display.height = height;
++	fbtft_init_dbg(dev, "Display resolution: %dx%d\n", width, height);
++	fbtft_init_dbg(dev, "chip = %s\n", chip ? chip : "not set");
++	fbtft_init_dbg(dev, "setaddrwin = %d\n", setaddrwin);
++	fbtft_init_dbg(dev, "regwidth = %d\n", regwidth);
++	fbtft_init_dbg(dev, "buswidth = %d\n", buswidth);
++
++	info = fbtft_framebuffer_alloc(&flex_display, dev);
++	if (!info)
++		return -ENOMEM;
++
++	par = info->par;
++	if (sdev)
++		par->spi = sdev;
++	else
++		par->pdev = pdev;
++	if (!par->init_sequence)
++		par->init_sequence = initp;
++	par->fbtftops.init_display = fbtft_init_display;
++
++	/* registerwrite functions */
++	switch (regwidth) {
++	case 8:
++		par->fbtftops.write_register = fbtft_write_reg8_bus8;
++		break;
++	case 16:
++		par->fbtftops.write_register = fbtft_write_reg16_bus8;
++		break;
++	default:
++		dev_err(dev, "argument 'regwidth': %d is not supported.\n", regwidth);
++		return -EINVAL;
++	}
++
++	/* bus functions */
++	if (sdev) {
++		par->fbtftops.write = fbtft_write_spi;
++		switch (buswidth) {
++		case 8:
++			par->fbtftops.write_vmem = fbtft_write_vmem16_bus8;
++			if (!par->startbyte)
++				par->fbtftops.verify_gpios = flexfb_verify_gpios_dc;
++			break;
++		case 9:
++			if (regwidth == 16) {
++				dev_err(dev, "argument 'regwidth': %d is not supported with buswidth=%d and SPI.\n", regwidth, buswidth);
++				return -EINVAL;
++			}
++			par->fbtftops.write_register = fbtft_write_reg8_bus9;
++			par->fbtftops.write_vmem = fbtft_write_vmem16_bus9;
++			sdev->bits_per_word=9;
++			ret = sdev->master->setup(sdev);
++			if (ret) {
++				dev_warn(dev,
++					"9-bit SPI not available, emulating using 8-bit.\n");
++				sdev->bits_per_word = 8;
++				ret = sdev->master->setup(sdev);
++				if (ret)
++					goto out_release;
++				/* allocate buffer with room for dc bits */
++				par->extra = vzalloc(par->txbuf.len +
++						(par->txbuf.len / 8) + 8);
++				if (!par->extra) {
++					ret = -ENOMEM;
++					goto out_release;
++				}
++				par->fbtftops.write = fbtft_write_spi_emulate_9;
++			}
++			break;
++		default:
++			dev_err(dev, "argument 'buswidth': %d is not supported with SPI.\n", buswidth);
++			return -EINVAL;
++		}
++	} else {
++		par->fbtftops.verify_gpios = flexfb_verify_gpios_db;
++		switch (buswidth) {
++		case 8:
++			par->fbtftops.write = fbtft_write_gpio8_wr;
++			par->fbtftops.write_vmem = fbtft_write_vmem16_bus8;
++			break;
++		case 16:
++			par->fbtftops.write_register = fbtft_write_reg16_bus16;
++			if (latched)
++				par->fbtftops.write = fbtft_write_gpio16_wr_latched;
++			else
++				par->fbtftops.write = fbtft_write_gpio16_wr;
++			par->fbtftops.write_vmem = fbtft_write_vmem16_bus16;
++			break;
++		default:
++			dev_err(dev, "argument 'buswidth': %d is not supported with parallel.\n", buswidth);
++			return -EINVAL;
++		}
++	}
++
++	/* set_addr_win function */
++	switch (setaddrwin) {
++	case 0:
++		/* use default */
++		break;
++	case 1:
++		par->fbtftops.set_addr_win = flexfb_set_addr_win_1;
++		break;
++	case 2:
++		par->fbtftops.set_addr_win = flexfb_set_addr_win_2;
++		break;
++	case 3:
++		par->fbtftops.set_addr_win = set_addr_win_3;
++		break;
++	default:
++		dev_err(dev, "argument 'setaddrwin': unknown value %d.\n", setaddrwin);
++		return -EINVAL;
++	}
++
++	if (!nobacklight)
++		par->fbtftops.register_backlight = fbtft_register_backlight;
++
++	ret = fbtft_register_framebuffer(info);
++	if (ret < 0)
++		goto out_release;
++
++	return 0;
++
++out_release:
++	fbtft_framebuffer_release(info);
++
++	return ret;
++}
++
++static int flexfb_remove_common(struct device *dev, struct fb_info *info)
++{
++	struct fbtft_par *par;
++
++	if (!info)
++		return -EINVAL;
++	par = info->par;
++	if (par) {
++		fbtft_par_dbg(DEBUG_DRIVER_INIT_FUNCTIONS, par,
++			"%s()\n", __func__);
++		if (par->extra)
++			vfree(par->extra);
++	}
++	fbtft_unregister_framebuffer(info);
++	fbtft_framebuffer_release(info);
++
++	return 0;
++}
++
++static int flexfb_probe_spi(struct spi_device *spi)
++{
++	return flexfb_probe_common(spi, NULL);
++}
++
++static int flexfb_remove_spi(struct spi_device *spi)
++{
++	struct fb_info *info = spi_get_drvdata(spi);
++
++	return flexfb_remove_common(&spi->dev, info);
++}
++
++static int flexfb_probe_pdev(struct platform_device *pdev)
++{
++	return flexfb_probe_common(NULL, pdev);
++}
++
++static int flexfb_remove_pdev(struct platform_device *pdev)
++{
++	struct fb_info *info = platform_get_drvdata(pdev);
++
++	return flexfb_remove_common(&pdev->dev, info);
++}
++
++static struct spi_driver flexfb_spi_driver = {
++	.driver = {
++		.name   = DRVNAME,
++		.owner  = THIS_MODULE,
++	},
++	.probe  = flexfb_probe_spi,
++	.remove = flexfb_remove_spi,
++};
++
++static const struct platform_device_id flexfb_platform_ids[] = {
++	{ "flexpfb", 0 },
++	{ },
++};
++
++static struct platform_driver flexfb_platform_driver = {
++	.driver = {
++		.name   = DRVNAME,
++		.owner  = THIS_MODULE,
++	},
++	.id_table = flexfb_platform_ids,
++	.probe  = flexfb_probe_pdev,
++	.remove = flexfb_remove_pdev,
++};
++
++static int __init flexfb_init(void)
++{
++	int ret, ret2;
++
++	ret = spi_register_driver(&flexfb_spi_driver);
++	ret2 = platform_driver_register(&flexfb_platform_driver);
++	if (ret < 0)
++		return ret;
++	return ret2;
++}
++
++static void __exit flexfb_exit(void)
++{
++	spi_unregister_driver(&flexfb_spi_driver);
++	platform_driver_unregister(&flexfb_platform_driver);
++}
++
++/* ------------------------------------------------------------------------- */
++
++module_init(flexfb_init);
++module_exit(flexfb_exit);
++
++MODULE_DESCRIPTION("Generic FB driver for TFT LCD displays");
++MODULE_AUTHOR("Noralf Tronnes");
++MODULE_LICENSE("GPL");
+-- 
+1.7.4.4
+
diff --git a/board/raspberrypi/adafruit_ts/overlay/boot/.empty b/board/raspberrypi/adafruit_ts/overlay/boot/.empty
new file mode 100644
index 0000000..e69de29
diff --git a/board/raspberrypi/adafruit_ts/overlay/etc/fstab b/board/raspberrypi/adafruit_ts/overlay/etc/fstab
new file mode 100644
index 0000000..b49884c
--- /dev/null
+++ b/board/raspberrypi/adafruit_ts/overlay/etc/fstab
@@ -0,0 +1,10 @@
+# /etc/fstab: static file system information.
+#
+# <file system> <mount pt>     <type>	<options>         <dump> <pass>
+/dev/root       /              ext2	rw,noauto         0      1
+proc		/proc	       proc     defaults	  0	 0
+devpts		/dev/pts       devpts   defaults,gid=5,mode=620	  0	 0
+tmpfs           /dev/shm       tmpfs    mode=0777         0      0
+tmpfs           /tmp           tmpfs    mode=1777         0      0
+sysfs		/sys	       sysfs    defaults	  0	 0
+/dev/mmcblk0p1	/boot	       vfat	defaults	  0	 0
diff --git a/board/raspberrypi/adafruit_ts/overlay/etc/init.d/S11touchscreen b/board/raspberrypi/adafruit_ts/overlay/etc/init.d/S11touchscreen
new file mode 100755
index 0000000..9cc0e56
--- /dev/null
+++ b/board/raspberrypi/adafruit_ts/overlay/etc/init.d/S11touchscreen
@@ -0,0 +1,27 @@
+#!/bin/sh
+#
+# Starts touchscreen
+#
+
+start() {
+	echo -n "Starting touchscreen: "
+	modprobe spi-bcm2708
+	modprobe fbtft_device name=adafruitts rotate=90
+}
+stop() {
+	echo -n "Stopping touchscreen : "
+}
+
+case "$1" in
+  start)
+  	start
+	;;
+  stop)
+  	stop
+	;;
+  *)
+	echo "Usage: $0 {start|stop"
+	exit 1
+esac
+
+exit $?
diff --git a/board/raspberrypi/adafruit_ts/overlay/etc/inittab b/board/raspberrypi/adafruit_ts/overlay/etc/inittab
new file mode 100644
index 0000000..5865f4d
--- /dev/null
+++ b/board/raspberrypi/adafruit_ts/overlay/etc/inittab
@@ -0,0 +1,43 @@
+# /etc/inittab
+#
+# Copyright (C) 2001 Erik Andersen <andersen@codepoet.org>
+#
+# Note: BusyBox init doesn't support runlevels.  The runlevels field is
+# completely ignored by BusyBox init. If you want runlevels, use
+# sysvinit.
+#
+# Format for each entry: <id>:<runlevels>:<action>:<process>
+#
+# id        == tty to run on, or empty for /dev/console
+# runlevels == ignored
+# action    == one of sysinit, respawn, askfirst, wait, and once
+# process   == program to run
+
+# Startup the system
+null::sysinit:/bin/mount -t proc proc /proc
+null::sysinit:/bin/mount -o remount,rw / # REMOUNT_ROOTFS_RW
+null::sysinit:/bin/mkdir -p /dev/pts
+null::sysinit:/bin/mkdir -p /dev/shm
+null::sysinit:/bin/mount -a
+null::sysinit:/bin/hostname -F /etc/hostname
+# Load french keyboard
+null::sysinit:/usr/bin/loadkeys /usr/share/keymaps/i386/azerty/fr.map.gz
+
+# now run any rc scripts
+::sysinit:/etc/init.d/rcS
+
+# Set up a couple of getty's
+tty1::respawn:/sbin/getty 38400 tty1
+tty2::respawn:/sbin/getty 38400 tty2
+
+# Put a getty on the serial port
+ttyAMA0::respawn:/sbin/getty -L ttyAMA0 115200 vt100 # GENERIC_SERIAL
+
+# Stuff to do for the 3-finger salute
+::ctrlaltdel:/sbin/reboot
+
+# Stuff to do before rebooting
+null::shutdown:/etc/init.d/rcK
+null::shutdown:/bin/umount -a -r
+null::shutdown:/sbin/swapoff -a
+
diff --git a/board/raspberrypi/adafruit_ts/overlay/etc/udev/rules.d/95-stmpe.rules b/board/raspberrypi/adafruit_ts/overlay/etc/udev/rules.d/95-stmpe.rules
new file mode 100644
index 0000000..ddc03bf
--- /dev/null
+++ b/board/raspberrypi/adafruit_ts/overlay/etc/udev/rules.d/95-stmpe.rules
@@ -0,0 +1 @@
+SUBSYSTEM=="input", ATTRS{name}=="stmpe-ts", ENV{DEVNAME}=="*event*", SYMLINK+="input/touchscreen" 
diff --git a/board/raspberrypi/adafruit_ts/overlay/root/.directfbrc b/board/raspberrypi/adafruit_ts/overlay/root/.directfbrc
new file mode 100644
index 0000000..1757dd9
--- /dev/null
+++ b/board/raspberrypi/adafruit_ts/overlay/root/.directfbrc
@@ -0,0 +1,2 @@
+disable-module=linux_input
+tslib_devices=/dev/input/touchscreen
diff --git a/board/raspberrypi/adafruit_ts/overlay/root/.profile b/board/raspberrypi/adafruit_ts/overlay/root/.profile
new file mode 100644
index 0000000..8b12cd2
--- /dev/null
+++ b/board/raspberrypi/adafruit_ts/overlay/root/.profile
@@ -0,0 +1,9 @@
+export TSLIB_TSDEVICE=/dev/input/touchscreen
+export TSLIB_FBDEVICE=/dev/fb1
+export FRAMEBUFFER=/dev/fb1
+export QWS_MOUSE_PROTO=tslib:/dev/input/touchscreen
+export QWS_DISPLAY=linuxfb:/dev/fb1
+
+if [ ! -r /etc/pointercal ]; then
+	ts_calibrate
+fi
diff --git a/board/raspberrypi/build_sdcard.sh b/board/raspberrypi/build_sdcard.sh
new file mode 100755
index 0000000..5ada827
--- /dev/null
+++ b/board/raspberrypi/build_sdcard.sh
@@ -0,0 +1,87 @@
+#!/bin/sh
+#
+# Create an image that can by written onto a SD card using dd.
+#
+# The disk layout used is:
+#
+#    0                      -> IMAGE_ROOTFS_ALIGNMENT         - reserved for other data
+#    IMAGE_ROOTFS_ALIGNMENT -> BOOT_SPACE                     - bootloader and kernel
+#    BOOT_SPACE             -> SDIMG_SIZE                     - rootfs
+#
+#
+#                                                     Default Free space = 1.3x
+#                                                     Use IMAGE_OVERHEAD_FACTOR to add more space
+#                                                     <--------->
+#            4MiB              20MiB           SDIMG_ROOTFS
+# <-----------------------> <----------> <---------------------->
+#  ------------------------ ------------ ------------------------
+# | IMAGE_ROOTFS_ALIGNMENT | BOOT_SPACE | ROOTFS_SIZE            |
+#  ------------------------ ------------ ------------------------
+# ^                        ^            ^                        ^
+# |                        |            |                        |
+# 0                      4MiB     4MiB + 20MiB       4MiB + 20Mib + SDIMG_ROOTFS
+
+CURRENT_DIR=$1
+
+# SD Card image
+SDIMG=${CURRENT_DIR}/rpi-sdcard.img
+
+echo
+echo "*** Building SD-card `basename ${SDIMG}` ***"
+echo
+# Boot partition size [in KiB] (will be rounded up to IMAGE_ROOTFS_ALIGNMENT)
+
+BOOT_SPACE="20480"
+
+# Set alignment to 4MB [in KiB]
+IMAGE_ROOTFS_ALIGNMENT="4096"
+
+# Use an uncompressed ext2/3/4 by default as rootfs
+SDIMG_ROOTFS_TYPE="ext2"
+SDIMG_ROOTFS="${CURRENT_DIR}/rootfs.${SDIMG_ROOTFS_TYPE}"
+
+# Additional files and/or directories to be copied into the vfat partition from the IMAGE_ROOTFS.
+FATPAYLOAD=""
+
+# Align partitions
+BOOT_SPACE_ALIGNED=$(expr ${BOOT_SPACE} + ${IMAGE_ROOTFS_ALIGNMENT} - 1)
+BOOT_SPACE_ALIGNED=$(expr ${BOOT_SPACE_ALIGNED} - ${BOOT_SPACE_ALIGNED} % ${IMAGE_ROOTFS_ALIGNMENT})
+ROOTFS_SIZE=`du -bks ${SDIMG_ROOTFS} | awk '{print $1}'`
+# Round up RootFS size to the alignment size as well
+ROOTFS_SIZE_ALIGNED=$(expr ${ROOTFS_SIZE} + ${IMAGE_ROOTFS_ALIGNMENT} - 1)
+ROOTFS_SIZE_ALIGNED=$(expr ${ROOTFS_SIZE_ALIGNED} - ${ROOTFS_SIZE_ALIGNED} % ${IMAGE_ROOTFS_ALIGNMENT})
+SDIMG_SIZE=$(expr ${IMAGE_ROOTFS_ALIGNMENT} + ${BOOT_SPACE_ALIGNED} + ${ROOTFS_SIZE_ALIGNED})
+
+echo "Creating filesystem with Boot partition ${BOOT_SPACE_ALIGNED} KiB and RootFS ${ROOTFS_SIZE_ALIGNED} KiB"
+
+# Initialize sdcard image file
+dd if=/dev/zero of=${SDIMG} bs=1024 count=0 seek=${SDIMG_SIZE}
+
+# Create partition table
+parted -s ${SDIMG} mklabel msdos
+# Create boot partition and mark it as bootable
+parted -s ${SDIMG} unit KiB mkpart primary fat32 ${IMAGE_ROOTFS_ALIGNMENT} $(expr ${BOOT_SPACE_ALIGNED} \+ ${IMAGE_ROOTFS_ALIGNMENT})
+parted -s ${SDIMG} set 1 boot on
+# Create rootfs partition to the end of disk
+parted -s ${SDIMG} -- unit KiB mkpart primary ext2 $(expr ${BOOT_SPACE_ALIGNED} \+ ${IMAGE_ROOTFS_ALIGNMENT}) -1s
+
+# Create a vfat image with boot files
+BOOT_BLOCKS=$(LC_ALL=C parted -s ${SDIMG} unit b print | awk '/ 1 / { print substr($4, 1, length($4 -1)) / 512 /2 }')
+mkfs.vfat -n "Boot" -S 512 -C ${CURRENT_DIR}/boot.img $BOOT_BLOCKS
+
+# Update cmdline.txt with optional boot params
+shift
+cat $CURRENT_DIR/../../board/raspberrypi/cmdline.txt | sed -e "s/EXTRA_OPTS/$*/g" > $CURRENT_DIR/rpi-firmware/cmdline.txt
+# Copy boot files
+mcopy -i ${CURRENT_DIR}/boot.img -s ${CURRENT_DIR}/rpi-firmware/* ::/
+# Copy kernel
+mcopy -i ${CURRENT_DIR}/boot.img -s ${CURRENT_DIR}/zImage ::zImage
+
+# Burn Partitions
+dd if=${CURRENT_DIR}/boot.img of=${SDIMG} conv=notrunc seek=1 bs=$(expr ${IMAGE_ROOTFS_ALIGNMENT} \* 1024) && sync && sync
+dd if=${SDIMG_ROOTFS} of=${SDIMG} conv=notrunc seek=1 bs=$(expr 1024 \* ${BOOT_SPACE_ALIGNED} + ${IMAGE_ROOTFS_ALIGNMENT} \* 1024) && sync && sync
+rm -f ${CURRENT_DIR}/boot.img
+echo
+echo "**** Done."
+echo "You just have to do 'dd if=$(basename ${SDIMG}) of=<SD card device>'"
+echo 
diff --git a/board/raspberrypi/cmdline.txt b/board/raspberrypi/cmdline.txt
new file mode 100644
index 0000000..b16f371
--- /dev/null
+++ b/board/raspberrypi/cmdline.txt
@@ -0,0 +1,12 @@
+# Kernel command line 
+# Raspbian
+#dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait
+# NFS
+# PREEMPT-RT => sdhci-bcm2708.enable_llm=0
+#dwc_otg.lpm_enable=0 sdhci-bcm2708.enable_llm=0 console=ttyAMA0,115200 root=/dev/nfs rootfstype=nfs nfsroot=10.5.20.63:/home/pierre/rootfs_rpi_preempt ip=dhcp
+# Std / Xenomai
+#dwc_otg.lpm_enable=0 console=ttyAMA0,115200 root=/dev/nfs rootfstype=nfs nfsroot=192.168.2.1:/home/stage/rootfs_rpi_br ip=dhcp
+# Statique
+#dwc_otg.lpm_enable=0 console=ttyAMA0,115200 root=/dev/nfs rootfstype=nfs nfsroot=192.168.2.1:/home/stage/rootfs_rpi ip=192.168.2.2:::::eth0:off
+# BR SD Card
+dwc_otg.lpm_enable=0 console=ttyAMA0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait EXTRA_OPTS
diff --git a/configs/raspberrypi_qt4_ts_defconfig b/configs/raspberrypi_qt4_ts_defconfig
new file mode 100644
index 0000000..fd1ab53
--- /dev/null
+++ b/configs/raspberrypi_qt4_ts_defconfig
@@ -0,0 +1,53 @@
+BR2_arm=y
+BR2_arm1176jzf_s=y
+BR2_TOOLCHAIN_EXTERNAL=y
+BR2_TOOLCHAIN_EXTERNAL_CODESOURCERY_ARM201203=y
+BR2_TARGET_GENERIC_HOSTNAME="rpi"
+BR2_TARGET_GENERIC_ISSUE="Welcome to Buildroot (Qt/TS)"
+BR2_ROOTFS_DEVICE_CREATION_DYNAMIC_EUDEV=y
+BR2_TARGET_GENERIC_GETTY_PORT="ttyAMA0"
+BR2_ROOTFS_OVERLAY="board/raspberrypi/adafruit_ts/overlay"
+BR2_ROOTFS_POST_IMAGE_SCRIPT="board/raspberrypi/build_sdcard.sh"
+BR2_ROOTFS_POST_SCRIPT_ARGS="fbcon=map:10 fbcon=font:MINI4x6"
+BR2_LINUX_KERNEL=y
+BR2_LINUX_KERNEL_CUSTOM_GIT=y
+BR2_LINUX_KERNEL_CUSTOM_REPO_URL="git://github.com/raspberrypi/linux.git"
+BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION="2a8d45ec0883e3cbdce920855b3461ac77308a5f"
+BR2_LINUX_KERNEL_PATCH="board/raspberrypi/adafruit_ts"
+BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG=y
+BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE="board/raspberrypi/adafruit_ts/config-linux-3.6.11-adafruit_ts+git"
+BR2_LINUX_KERNEL_ZIMAGE=y
+BR2_PACKAGE_RT_TESTS=y
+BR2_PACKAGE_STRESS=y
+BR2_PACKAGE_DIRECTFB=y
+# BR2_PACKAGE_DIRECTFB_PS2MOUSE is not set
+# BR2_PACKAGE_DIRECTFB_SERIALMOUSE is not set
+# BR2_PACKAGE_DIRECTFB_GIF is not set
+BR2_PACKAGE_DIRECTFB_EXAMPLES=y
+BR2_PACKAGE_DIRECTFB_EXAMPLES_ANDI=y
+BR2_PACKAGE_DIRECTFB_EXAMPLES_INPUT=y
+BR2_PACKAGE_DIRECTFB_EXAMPLES_WINDOW=y
+BR2_PACKAGE_FBV=y
+BR2_PACKAGE_QT=y
+BR2_PACKAGE_QT_EXAMPLES=y
+BR2_PACKAGE_QT_LICENSE_APPROVED=y
+BR2_PACKAGE_QT_QTJPEG=y
+BR2_PACKAGE_QT_QTPNG=y
+BR2_PACKAGE_QT_MOUSE_PC=y
+BR2_PACKAGE_QT_MOUSE_LINUXTP=y
+BR2_PACKAGE_QT_MOUSE_LINUXINPUT=y
+BR2_PACKAGE_QT_MOUSE_TSLIB=y
+BR2_PACKAGE_QT_MOUSE_QVFB=y
+BR2_PACKAGE_QT_KEYBOARD_TTY=y
+BR2_PACKAGE_QT_KEYBOARD_LINUXINPUT=y
+BR2_PACKAGE_QT_KEYBOARD_QVFB=y
+BR2_PACKAGE_RPI_FIRMWARE=y
+BR2_PACKAGE_EVTEST=y
+BR2_PACKAGE_KBD=y
+BR2_PACKAGE_LIBCOFI=y
+BR2_PACKAGE_PCRE=y
+BR2_PACKAGE_PCRE_16=y
+BR2_PACKAGE_DROPBEAR=y
+BR2_TARGET_ROOTFS_EXT2=y
+BR2_TARGET_ROOTFS_EXT2_3=y
+BR2_TARGET_ROOTFS_TAR_GZIP=y
-- 
1.7.9.5

